{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/Acetolog-hexo/source/assets/svg_icons.svg","path":"assets/svg_icons.svg","modified":0,"renderable":1},{"_id":"themes/Acetolog-hexo/source/javascripts/acelog.js","path":"javascripts/acelog.js","modified":0,"renderable":1},{"_id":"themes/Acetolog-hexo/source/javascripts/highlight.pack.js","path":"javascripts/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/Acetolog-hexo/source/javascripts/acelog.js.map","path":"javascripts/acelog.js.map","modified":0,"renderable":1},{"_id":"themes/Acetolog-hexo/source/assets/JosefinSans-Regular.ttf","path":"assets/JosefinSans-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/Acetolog-hexo/source/assets/JosefinSans-SemiBoldItalic.ttf","path":"assets/JosefinSans-SemiBoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/Acetolog-hexo/source/css/dracula.css","path":"css/dracula.css","modified":0,"renderable":1},{"_id":"themes/Acetolog-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Acetolog-hexo/.gitignore","hash":"41acbb667c228d6b171286fef91534b436e39b5b","modified":1611800885089},{"_id":"source/CNAME","hash":"3bbf17ddb663f64c1f46bd09925424e288211a99","modified":1567948075000},{"_id":"themes/Acetolog-hexo/_config.yml","hash":"58a2cadc02ae933707f4dd3b08aec80dd98c7f2a","modified":1584023413483},{"_id":"themes/Acetolog-hexo/README.md","hash":"0f8ac24d6f9ccd6cf152cf36ca139a49fe80a0c7","modified":1611800885163},{"_id":"themes/Acetolog-hexo/LICENSE","hash":"a6c627c1c73474db7ae5f62ffd138d60e3579a7f","modified":1576670935000},{"_id":"themes/Acetolog-hexo/babel.config.json","hash":"9e62a6429ebf546c4058938d6f45141b147a331d","modified":1582082837431},{"_id":"themes/Acetolog-hexo/.DS_Store","hash":"f09a86bb4ce7d04901ec1bb4cb55bee99909840c","modified":1611146523187},{"_id":"themes/Acetolog-hexo/package.json","hash":"aee0934ec65ca961b066a1af33118599ba288f66","modified":1611800844023},{"_id":"themes/Acetolog-hexo/webpack.config.js","hash":"02d263b1078dd6d3a83ee88e48bd74d05e592368","modified":1611800844030},{"_id":"source/_posts/Acetolog-创作之路.md","hash":"b36ddfef7309cd6e938a15dd38af1760f81e8c4d","modified":1584281983239},{"_id":"source/_posts/Chrome-Inspect-iOS-UI-WK-WebView.md","hash":"3fedfa9c9d15c11bffd0a986cf78d4b7f5f33ae8","modified":1578037991000},{"_id":"source/_posts/Debug-electron-main-process-on-VSCode.md","hash":"c21f9d5b1572793d8f30a191cb98b73846cf5c77","modified":1556626403000},{"_id":"source/_posts/hello-world.md","hash":"0849589a84decd745230559907079aad2a874429","modified":1556626393000},{"_id":"source/_posts/复盘-2018.md","hash":"b2b06c34522089a57ab162d1fb466ad86da57769","modified":1556626222000},{"_id":"source/_posts/Electron-进程间通讯详解.md","hash":"26c203141d87ebc68291f5e59b941b860692573b","modified":1561870697000},{"_id":"source/_posts/Electron-asar-格式详解.md","hash":"b199d2d056b47f6b2e49edc5ca2308386a5e2db3","modified":1556626214000},{"_id":"source/_posts/大端与小端.md","hash":"0bc9e8b5b3c504a6b05879e6b5fe0defcb08cd91","modified":1556626238000},{"_id":"source/_posts/终于入手了人生第一台黑苹果.md","hash":"5afd1c7c11f9748d31cf312d8b59278e30bd258e","modified":1566981839000},{"_id":"themes/Acetolog-hexo/.github/FUNDING.yml","hash":"23bc50e5d30680b7aef2a9a985f224a575d71fbc","modified":1582446263154},{"_id":"themes/Acetolog-hexo/layout/index.pug","hash":"b6932e8c8d0ef6be3451f64c4fb25d1c036e259d","modified":1584023416647},{"_id":"themes/Acetolog-hexo/layout/post.pug","hash":"4d86f1f68fff8447b2fb1f880ab270445cae9478","modified":1583162555542},{"_id":"themes/Acetolog-hexo/source/.DS_Store","hash":"b73d1ffe2e3227ae822fed4d5a3473f2b4d1022c","modified":1582442438358},{"_id":"themes/Acetolog-hexo/src/index.js","hash":"4ac3dea10d8f86a8ecdb367b9aef290464b7e435","modified":1582446263156},{"_id":"themes/Acetolog-hexo/src/.DS_Store","hash":"f89e8bf442063e3228c1d2e3f6a01f80a1fc400a","modified":1581757844542},{"_id":"themes/Acetolog-hexo/yarn.lock","hash":"74e9ab569c11ba877706f45af19983b363fe768b","modified":1581755793224},{"_id":"themes/Acetolog-hexo/layout/includes/base.pug","hash":"943f2ea248ebf06768df27ccfec947c1c3d34219","modified":1582096034361},{"_id":"themes/Acetolog-hexo/layout/includes/footer.pug","hash":"a3bb82bdf331d68cedbe63c43bbf1da24408faee","modified":1582082837431},{"_id":"themes/Acetolog-hexo/layout/includes/head.pug","hash":"c81ec21fc3f28bf1a52e87f7e8734c34331ec35b","modified":1583162555541},{"_id":"themes/Acetolog-hexo/layout/includes/headerbar.pug","hash":"aa5633e19fd617a8b2fc91acb3b0473eb3f8bdc7","modified":1582446263155},{"_id":"themes/Acetolog-hexo/layout/includes/sidebar.pug","hash":"0e8736f5802bfa4d3c401778ff8e09bdc5bc6748","modified":1583163201499},{"_id":"themes/Acetolog-hexo/source/scss/_background.scss","hash":"fb0df007e4adfad7056f2fd33f62f0837e9d2dda","modified":1582082837433},{"_id":"themes/Acetolog-hexo/source/assets/svg_icons.svg","hash":"988cda366837940196ff88333186d9707feee8ac","modified":1611800844024},{"_id":"themes/Acetolog-hexo/source/scss/_container.scss","hash":"5b952929aaa3e19a51acdd542b33377744658f52","modified":1584023416648},{"_id":"themes/Acetolog-hexo/source/scss/_darkTheme.scss","hash":"e3f6b856869dc8c6d590df38bf6e6ceaf67da4f6","modified":1584023416648},{"_id":"themes/Acetolog-hexo/source/scss/_font.scss","hash":"cb1172042bc395e0bacc0542033c1678bbb22a3f","modified":1584023416648},{"_id":"themes/Acetolog-hexo/source/scss/_global.scss","hash":"2acfe552325cc5f0d0798ca26357247a73304103","modified":1584023416648},{"_id":"themes/Acetolog-hexo/source/scss/_page.scss","hash":"c73a56a835fb7a25fad08ad58f0d3d920e4a49f3","modified":1578371910000},{"_id":"themes/Acetolog-hexo/source/scss/_header.scss","hash":"006a845d759dc5e4946769d5e5bd624beadd0694","modified":1582277791144},{"_id":"themes/Acetolog-hexo/source/scss/_pageOutline.scss","hash":"834640ab1f63f30add40769b1bdd299977b34a0c","modified":1584023416649},{"_id":"themes/Acetolog-hexo/source/scss/_pageContent.scss","hash":"41f58ee4711550ffe1a7a03739f5436998659732","modified":1576670961000},{"_id":"themes/Acetolog-hexo/source/scss/_postList.scss","hash":"8b1cd80ebdc6c41e14f3a68433da672ade69a4af","modified":1584023416649},{"_id":"themes/Acetolog-hexo/source/scss/_sidebar.scss","hash":"721476e0a910eba74a4ea17a011df12eec402fed","modified":1584023416649},{"_id":"themes/Acetolog-hexo/source/scss/_var.scss","hash":"8dc0d18fb85d9aa5f09d93f832509982d7c1e279","modified":1584023416649},{"_id":"themes/Acetolog-hexo/source/javascripts/acelog.js","hash":"230cb0545de6fb7c0935eb278b20bf2ca2971d37","modified":1611800844024},{"_id":"themes/Acetolog-hexo/source/javascripts/highlight.pack.js","hash":"aaac7fbc3ae1b46bf01b4bae2a8b1829ea370405","modified":1611800844025},{"_id":"themes/Acetolog-hexo/src/util/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1581757281662},{"_id":"themes/Acetolog-hexo/screenshot/1.png","hash":"27f8db9ead88cd090e7392a12ca033e9f8c8c806","modified":1576670961000},{"_id":"themes/Acetolog-hexo/src/util/jquery_polyfill.js","hash":"74b96752dd62e80e76e88cdaea4c1e32ec0b0834","modified":1583162555542},{"_id":"themes/Acetolog-hexo/source/css/style.scss","hash":"d96cc07d0bfa55cc3805d80c524f55d04b088cc8","modified":1584023416648},{"_id":"themes/Acetolog-hexo/source/css/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1576670961000},{"_id":"themes/Acetolog-hexo/source/css/highlightjs.default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1576670961000},{"_id":"themes/Acetolog-hexo/source/javascripts/acelog.js.map","hash":"3630730bae759b90bdca7a63216fa875448809f0","modified":1583163224077},{"_id":"themes/Acetolog-hexo/source/assets/JosefinSans-Regular.ttf","hash":"7bc8324d2ff6a6fc28794c8ba607e30f47a2161a","modified":1576670961000},{"_id":"themes/Acetolog-hexo/source/assets/JosefinSans-SemiBoldItalic.ttf","hash":"b8ec4d6c33033901489df706156609e528ed3d0f","modified":1576670961000},{"_id":"themes/Acetolog-hexo/layout/includes/plugin/baiduAnalytice.pug","hash":"1df654f847b2c7faddbaf4332ab10758f4b479e5","modified":1582082837438},{"_id":"themes/Acetolog-hexo/layout/includes/plugin/disqus.pug","hash":"15f2fdb3aa602b3e59000aa0fbf3c039cde95ef9","modified":1582082837438},{"_id":"themes/Acetolog-hexo/layout/includes/plugin/gitalk.pug","hash":"7caa974f5be2f9f6f48e9b9fc833a2185631da1a","modified":1582446263155},{"_id":"themes/Acetolog-hexo/layout/includes/plugin/googleAnalytice.pug","hash":"a3cf2ce00ff82dc056659343255783c4634590ca","modified":1582082837438},{"_id":"themes/Acetolog-hexo/layout/includes/plugin/mtaTencentAnalytice.pug","hash":"3d0f01ddcbc53670094f79f683027cc67174b099","modified":1582082837438},{"_id":"themes/Acetolog-hexo/layout/includes/plugin/plugin.pug","hash":"db51c41b4de00e3cf4b4d19358e89cbb9b680f26","modified":1582082837432},{"_id":"public/2020/02/21/Acetolog-创作之路/index.html","hash":"4586ba0e1d4e6cac84c50c6c606b9afd19b4121e","modified":1611801175368},{"_id":"public/2020/01/03/Chrome-Inspect-iOS-UI-WK-WebView/index.html","hash":"fd8faa75986a0b1f692f11993bee4ec4fad1da73","modified":1611801175368},{"_id":"public/2019/03/19/Electron-asar-格式详解/index.html","hash":"20936190f93441b1bf161ed2f10aa93820fcedc2","modified":1611801175368},{"_id":"public/2019/01/15/Debug-electron-main-process-on-VSCode/index.html","hash":"cadc6bfba3eaa13778a29d73fb4680b4f9bac6b1","modified":1611801175368},{"_id":"public/2019/01/01/大端与小端/index.html","hash":"ea8cca753edf193982e1d9f5eb6b1ac3d8ab9228","modified":1611801175368},{"_id":"public/1970/01/01/hello-world/index.html","hash":"ac7cad1e148b57a788460dab601f3199a61a29a9","modified":1611801175368},{"_id":"public/2019/08/28/终于入手了人生第一台黑苹果/index.html","hash":"869cc035af4d08395db4180da78929d4ded639f6","modified":1611801175368},{"_id":"public/2019/06/30/Electron-进程间通讯详解/index.html","hash":"d2f02b3195d7a181c9479ff82a5cce49cbd3a98d","modified":1611801175368},{"_id":"public/2019/03/17/复盘-2018/index.html","hash":"ea1a83bcbfb2698dcbe5dd6618234154f6596dbb","modified":1611801175368},{"_id":"public/archives/index.html","hash":"c50abd5f30ed0aae52289c797e5e86f6b89f59c7","modified":1611801175368},{"_id":"public/archives/1970/index.html","hash":"0c2f5ab6e788071811fe19f54df9923aaa7f5510","modified":1611801175368},{"_id":"public/archives/1970/01/index.html","hash":"0c2f5ab6e788071811fe19f54df9923aaa7f5510","modified":1611801175368},{"_id":"public/archives/2019/index.html","hash":"a6d39b4e83e676770e838e61bb17bc2777ed94dd","modified":1611801175368},{"_id":"public/archives/2019/01/index.html","hash":"b4aaa15928363602cd386a8f340d6668da11a50d","modified":1611801175368},{"_id":"public/archives/2019/03/index.html","hash":"630f73a8173ff5f495099faf660f00ea6f756975","modified":1611801175368},{"_id":"public/archives/2019/06/index.html","hash":"640c8d55d0dc7073c8f81ab65cb6cecea8ac7583","modified":1611801175368},{"_id":"public/archives/2019/08/index.html","hash":"fa9356d6a1fcc9e36aa44bcb518e94b0e473dfdb","modified":1611801175368},{"_id":"public/archives/2020/index.html","hash":"87f89bdce584b2a86425c5a3f0072a0475836943","modified":1611801175368},{"_id":"public/archives/2020/01/index.html","hash":"7082a70c1433be32aa570a9d2ff4cdcb27694595","modified":1611801175368},{"_id":"public/archives/2020/02/index.html","hash":"fefcc8d422203f722cd4722f51e648883ddd1ca8","modified":1611801175368},{"_id":"public/index.html","hash":"c50abd5f30ed0aae52289c797e5e86f6b89f59c7","modified":1611801175368},{"_id":"public/tags/Electron/index.html","hash":"d529ccd30e39880d2020878f3839b4c65fc795f5","modified":1611801175368},{"_id":"public/CNAME","hash":"3bbf17ddb663f64c1f46bd09925424e288211a99","modified":1584282035429},{"_id":"public/assets/svg_icons.svg","hash":"988cda366837940196ff88333186d9707feee8ac","modified":1611800939109},{"_id":"public/javascripts/acelog.js.map","hash":"3630730bae759b90bdca7a63216fa875448809f0","modified":1584282035429},{"_id":"public/assets/JosefinSans-Regular.ttf","hash":"7bc8324d2ff6a6fc28794c8ba607e30f47a2161a","modified":1584282035429},{"_id":"public/assets/JosefinSans-SemiBoldItalic.ttf","hash":"b8ec4d6c33033901489df706156609e528ed3d0f","modified":1584282035429},{"_id":"public/javascripts/acelog.js","hash":"230cb0545de6fb7c0935eb278b20bf2ca2971d37","modified":1611800939109},{"_id":"public/css/atom-one-dark.css","hash":"a6d28e1c04cee20cd874fc7ac0903d8e2e4bd54e","modified":1584282035429},{"_id":"public/css/style.css","hash":"127595d327be92d6178b39122a8ae27c50efc7d2","modified":1611800939109},{"_id":"public/css/highlightjs.default.css","hash":"fba68624d1b34a5543fe0bf4b2af2ac1ddf65e74","modified":1584282035429},{"_id":"public/javascripts/highlight.pack.js","hash":"aaac7fbc3ae1b46bf01b4bae2a8b1829ea370405","modified":1611800939109},{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1611146511540},{"_id":"themes/Acetolog-hexo/layout/post.swig","hash":"8ec57f1de6b9367bc72a40a38bd579752cc838c9","modified":1611800885142},{"_id":"themes/Acetolog-hexo/layout/index.swig","hash":"059d27299a319eef1f40283afc3e439f30bb642e","modified":1611800844023},{"_id":"themes/Acetolog-hexo/src/index.ts","hash":"79c2437779458e751b1a91e65314f9a1db0a215e","modified":1611800844030},{"_id":"themes/Acetolog-hexo/src/tsconfig.json","hash":"abf0a348f1d9390e895d70586dcbb80a1f931c32","modified":1611800844030},{"_id":"themes/Acetolog-hexo/layout/includes/head.swig","hash":"c758592f7c72a26cbe882e7ac9d015a833542377","modified":1611800885118},{"_id":"themes/Acetolog-hexo/layout/includes/base.swig","hash":"3239d3c38333c901028428d17199365fd4bfe0cf","modified":1611800844019},{"_id":"themes/Acetolog-hexo/layout/includes/footer.swig","hash":"3e1ebe7a1108ffb7585f680e3dcf66b992c45e32","modified":1611800844020},{"_id":"themes/Acetolog-hexo/layout/includes/headerbar.swig","hash":"686f677de6611f933a63f5a17c17965256a798cf","modified":1611800844021},{"_id":"themes/Acetolog-hexo/layout/includes/sidebar.swig","hash":"54711340231b020a55fe9ddcbb8102d271e44290","modified":1611800844022},{"_id":"themes/Acetolog-hexo/source/css/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1611800844024},{"_id":"themes/Acetolog-hexo/source/css/style.styl","hash":"78c5d9cb9594e46a3c88d1f2ed40cec43c64c021","modified":1611800844024},{"_id":"themes/Acetolog-hexo/source/stylus/_background.styl","hash":"d0612a23bf8827fa52028000178f0ce3665b7b37","modified":1611800844046},{"_id":"themes/Acetolog-hexo/source/stylus/_container.styl","hash":"3487a88879b1d64d1dbf6d758ec9eff82c6c3c15","modified":1611800844045},{"_id":"themes/Acetolog-hexo/source/stylus/_darkTheme.styl","hash":"95791393f3f354ba31a78750fa72d20c8bc31ee9","modified":1611800844045},{"_id":"themes/Acetolog-hexo/source/stylus/_font.styl","hash":"cb1172042bc395e0bacc0542033c1678bbb22a3f","modified":1611800844044},{"_id":"themes/Acetolog-hexo/source/stylus/_global.styl","hash":"d121e002d56473f510ba7cecc52ac0f0e3630fe4","modified":1611800844044},{"_id":"themes/Acetolog-hexo/source/stylus/_header.styl","hash":"b98273b7989ce05208071fc691b5f2e609379af8","modified":1611800844043},{"_id":"themes/Acetolog-hexo/source/stylus/_lightbox.styl","hash":"c826434c6dfa55c0fac24064e255693c6d729651","modified":1611800844028},{"_id":"themes/Acetolog-hexo/source/stylus/_pageOutline.styl","hash":"10d566aa2d3f38aedb95603ada0bade6ed591ee0","modified":1611800844042},{"_id":"themes/Acetolog-hexo/source/stylus/_postList.styl","hash":"bbc3acfde57b6be5c637faecfa28a8152d40b03a","modified":1611800844042},{"_id":"themes/Acetolog-hexo/source/stylus/_sidebar.styl","hash":"721476e0a910eba74a4ea17a011df12eec402fed","modified":1611800844041},{"_id":"themes/Acetolog-hexo/source/stylus/_page.styl","hash":"e5a42ad0103ca8e2c7c05b3a17cf5cf7ae640366","modified":1611800885089},{"_id":"themes/Acetolog-hexo/source/stylus/_pageContent.styl","hash":"3a7249f415ec40b4dd58e52ad082fe8c3d120d02","modified":1611800885157},{"_id":"themes/Acetolog-hexo/src/util/jquery_polyfill.ts","hash":"d1fa983c135ae1c7c660a591f53ad02c85d00797","modified":1611800844030},{"_id":"themes/Acetolog-hexo/source/stylus/_var.styl","hash":"06eef6bc52ace2129968dea47fc19bac164aec3b","modified":1611800885157},{"_id":"themes/Acetolog-hexo/layout/includes/plugins/baiduAnalytice.swig","hash":"feece927533d615b4452b1cc674131f94b34b596","modified":1611800844021},{"_id":"themes/Acetolog-hexo/layout/includes/plugins/disqus.swig","hash":"db0888cd04ed03a14a0b8a71874d6c8cb23decbf","modified":1611800844021},{"_id":"themes/Acetolog-hexo/layout/includes/plugins/googleAnalytice.swig","hash":"323d0a95660f51ceb31e1d2239521ee066b4c48c","modified":1611800844022},{"_id":"themes/Acetolog-hexo/layout/includes/plugins/mtaTencentAnalytice.swig","hash":"f1bcdf00494fdb4f446d7628798e7760a7740358","modified":1611800844022},{"_id":"themes/Acetolog-hexo/layout/includes/plugins/plugin.swig","hash":"7b5ca426c6ac0722550397700ddee4af808f4674","modified":1611800844022},{"_id":"themes/Acetolog-hexo/layout/includes/plugins/gitalk.swig","hash":"0a9d2c382fd655cb216011c8aeaf0e3ca7828e86","modified":1611800885124},{"_id":"public/css/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1611800939109}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Acetolog 创作之路","date":"2020-02-21T09:17:25.000Z","_content":"## 前言\n看到陆续有些人使用自己的博客主题 [Acetolog](https://github.com/iGuan7u/Acetolog)，感觉也是时候注水一下关于这个博客主题了。\n\n## 起因\n其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID **iGuan7u** 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到**挑选博客主题**这一步遇到了瓶颈。\n\n能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 [typology](https://demo.mekshq.com/typology/)，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。~~因为它实在是太美了。~~\n\n当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。\n\n## 动手\n当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。~~虽然现在看来甚至还不如不发挥。~~\n\n不过样式部分其实并不属于这个博客的精彩部分。\n\n笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 [hexo-next](https://github.com/theme-next/hexo-theme-next) ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。\n\n![hexo-next](https://cdn.iguan7u.cn/image/hexo-next_resources.png)\n\n![typelogy](https://cdn.iguan7u.cn/image/typology_resources.png)\n\n![acetolog](https://cdn.iguan7u.cn/image/acelog_resources.png)\n\n同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。\n\n虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。\n\n## 感想\n另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。\n\n自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 `jQuery` 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）\n\n甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。\n\n目前阶段 Acetolog 还是以 **tiny** 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。\n\n谢谢。","source":"_posts/Acetolog-创作之路.md","raw":"---\ntitle: Acetolog 创作之路\ndate: 2020-02-21 17:17:25\ntags:\n---\n## 前言\n看到陆续有些人使用自己的博客主题 [Acetolog](https://github.com/iGuan7u/Acetolog)，感觉也是时候注水一下关于这个博客主题了。\n\n## 起因\n其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID **iGuan7u** 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到**挑选博客主题**这一步遇到了瓶颈。\n\n能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 [typology](https://demo.mekshq.com/typology/)，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。~~因为它实在是太美了。~~\n\n当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。\n\n## 动手\n当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。~~虽然现在看来甚至还不如不发挥。~~\n\n不过样式部分其实并不属于这个博客的精彩部分。\n\n笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 [hexo-next](https://github.com/theme-next/hexo-theme-next) ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。\n\n![hexo-next](https://cdn.iguan7u.cn/image/hexo-next_resources.png)\n\n![typelogy](https://cdn.iguan7u.cn/image/typology_resources.png)\n\n![acetolog](https://cdn.iguan7u.cn/image/acelog_resources.png)\n\n同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。\n\n虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。\n\n## 感想\n另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。\n\n自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 `jQuery` 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）\n\n甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。\n\n目前阶段 Acetolog 还是以 **tiny** 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。\n\n谢谢。","slug":"Acetolog-创作之路","published":1,"updated":"2020-03-15T14:19:43.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4malb0000kapcb5df0ear","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到陆续有些人使用自己的博客主题 <a href=\"https://github.com/iGuan7u/Acetolog\" target=\"_blank\" rel=\"noopener\">Acetolog</a>，感觉也是时候注水一下关于这个博客主题了。</p>\n<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID <strong>iGuan7u</strong> 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到<strong>挑选博客主题</strong>这一步遇到了瓶颈。</p>\n<p>能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 <a href=\"https://demo.mekshq.com/typology/\" target=\"_blank\" rel=\"noopener\">typology</a>，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。<del>因为它实在是太美了。</del></p>\n<p>当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。</p>\n<h2 id=\"动手\"><a href=\"#动手\" class=\"headerlink\" title=\"动手\"></a>动手</h2><p>当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。<del>虽然现在看来甚至还不如不发挥。</del></p>\n<p>不过样式部分其实并不属于这个博客的精彩部分。</p>\n<p>笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 <a href=\"https://github.com/theme-next/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">hexo-next</a> ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/hexo-next_resources.png\" alt=\"hexo-next\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/typology_resources.png\" alt=\"typelogy\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/acelog_resources.png\" alt=\"acetolog\"></p>\n<p>同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。</p>\n<p>虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。</p>\n<h2 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h2><p>另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。</p>\n<p>自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 <code>jQuery</code> 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）</p>\n<p>甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。</p>\n<p>目前阶段 Acetolog 还是以 <strong>tiny</strong> 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。</p>\n<p>谢谢。</p>\n","site":{"data":{}},"excerpt":"前言\n看到陆续有些人使用自己的博客主题 Acetolog，感觉也是时候注水一下关于这个博客主题了。\n\n起因\n其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID iGuan7u 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到挑选博客主题这一步遇到","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到陆续有些人使用自己的博客主题 <a href=\"https://github.com/iGuan7u/Acetolog\" target=\"_blank\" rel=\"noopener\">Acetolog</a>，感觉也是时候注水一下关于这个博客主题了。</p>\n<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID <strong>iGuan7u</strong> 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到<strong>挑选博客主题</strong>这一步遇到了瓶颈。</p>\n<p>能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 <a href=\"https://demo.mekshq.com/typology/\" target=\"_blank\" rel=\"noopener\">typology</a>，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。<del>因为它实在是太美了。</del></p>\n<p>当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。</p>\n<h2 id=\"动手\"><a href=\"#动手\" class=\"headerlink\" title=\"动手\"></a>动手</h2><p>当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。<del>虽然现在看来甚至还不如不发挥。</del></p>\n<p>不过样式部分其实并不属于这个博客的精彩部分。</p>\n<p>笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 <a href=\"https://github.com/theme-next/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">hexo-next</a> ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/hexo-next_resources.png\" alt=\"hexo-next\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/typology_resources.png\" alt=\"typelogy\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/acelog_resources.png\" alt=\"acetolog\"></p>\n<p>同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。</p>\n<p>虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。</p>\n<h2 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h2><p>另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。</p>\n<p>自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 <code>jQuery</code> 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）</p>\n<p>甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。</p>\n<p>目前阶段 Acetolog 还是以 <strong>tiny</strong> 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。</p>\n<p>谢谢。</p>\n"},{"title":"Chrome Inspect iOS (UI/WK)WebView","date":"2020-01-03T07:46:03.000Z","_content":"\n## 被 Safari 支配的恐惧\n![Safari_Icoon](https://cdn.iguan7u.cn/image/safari_icon_240.png)\n曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。\n可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在**使用大量能耗**的应用列表上了。\n当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari **曾经**是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。\n\n## ios-webkit-debug-proxy\n[ios-webkit-debug-proxy](https://github.com/google/ios-webkit-debug-proxy) 是我在无意间划水 Github 时发现的一个代理工具，它借助于 [usbmuxd](https://github.com/libimobiledevice/usbmuxd) 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。\n\n借用项目中的示意图：\n\n![](https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png)\n\n### 安装依赖：\n\n- [homebrew](http://brew.sh/)\n\n### 安装方法：\n\n> 为了避免出现 `Could not connect to lockdownd, error code -<number>. Exiting.` 错误，建议不要直接 `brew install ios-webkit-debug-proxy` 安装。  \n\n```shell\n$: brew update\n$: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd\n$: brew install --HEAD usbmuxd\n$: brew install --HEAD libimobiledevice\n$: brew install -s ios-webkit-debug-proxy\n```\n\n### 使用方法：\n\n```shell\n$: ios-webkit-debug-proxy\n```\n\n> ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  \n\n连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 [localhost:9221](h) 查看连接设备列表。\n\n```shell\n$: ios-webkit-debug-proxy\nListing devices on :9221\nConnected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\nDisconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\n```\n\n## Chrome 拯救世人\n当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。\n\n1. 我们就需要启动 Chrome\n2. 打开 [Inspector](chrome://inspect) 页面\n3. 点击 `Discover network targets` 后的 `configure` 按钮\n4. 输入上面展示的设备端口地址：`localhost:9222` ，点击 `done` 按钮\n5. 在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～\n\n不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 [RemoteDebug iOS WebKit Adapter](https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter)，这个使用 ios-webkit-debug-proxy 做底层的一个工具。\n\n## Bug\n笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。","source":"_posts/Chrome-Inspect-iOS-UI-WK-WebView.md","raw":"---\ntitle: Chrome Inspect iOS (UI/WK)WebView\ndate: 2020-01-03 15:46:03\ntags:\n---\n\n## 被 Safari 支配的恐惧\n![Safari_Icoon](https://cdn.iguan7u.cn/image/safari_icon_240.png)\n曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。\n可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在**使用大量能耗**的应用列表上了。\n当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari **曾经**是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。\n\n## ios-webkit-debug-proxy\n[ios-webkit-debug-proxy](https://github.com/google/ios-webkit-debug-proxy) 是我在无意间划水 Github 时发现的一个代理工具，它借助于 [usbmuxd](https://github.com/libimobiledevice/usbmuxd) 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。\n\n借用项目中的示意图：\n\n![](https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png)\n\n### 安装依赖：\n\n- [homebrew](http://brew.sh/)\n\n### 安装方法：\n\n> 为了避免出现 `Could not connect to lockdownd, error code -<number>. Exiting.` 错误，建议不要直接 `brew install ios-webkit-debug-proxy` 安装。  \n\n```shell\n$: brew update\n$: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd\n$: brew install --HEAD usbmuxd\n$: brew install --HEAD libimobiledevice\n$: brew install -s ios-webkit-debug-proxy\n```\n\n### 使用方法：\n\n```shell\n$: ios-webkit-debug-proxy\n```\n\n> ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  \n\n连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 [localhost:9221](h) 查看连接设备列表。\n\n```shell\n$: ios-webkit-debug-proxy\nListing devices on :9221\nConnected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\nDisconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\n```\n\n## Chrome 拯救世人\n当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。\n\n1. 我们就需要启动 Chrome\n2. 打开 [Inspector](chrome://inspect) 页面\n3. 点击 `Discover network targets` 后的 `configure` 按钮\n4. 输入上面展示的设备端口地址：`localhost:9222` ，点击 `done` 按钮\n5. 在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～\n\n不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 [RemoteDebug iOS WebKit Adapter](https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter)，这个使用 ios-webkit-debug-proxy 做底层的一个工具。\n\n## Bug\n笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。","slug":"Chrome-Inspect-iOS-UI-WK-WebView","published":1,"updated":"2020-01-03T07:53:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4malg0001kapc5wnccn50","content":"<h2 id=\"被-Safari-支配的恐惧\"><a href=\"#被-Safari-支配的恐惧\" class=\"headerlink\" title=\"被 Safari 支配的恐惧\"></a>被 Safari 支配的恐惧</h2><p><img src=\"https://cdn.iguan7u.cn/image/safari_icon_240.png\" alt=\"Safari_Icoon\"><br>曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。<br>可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在<strong>使用大量能耗</strong>的应用列表上了。<br>当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari <strong>曾经</strong>是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。</p>\n<h2 id=\"ios-webkit-debug-proxy\"><a href=\"#ios-webkit-debug-proxy\" class=\"headerlink\" title=\"ios-webkit-debug-proxy\"></a>ios-webkit-debug-proxy</h2><p><a href=\"https://github.com/google/ios-webkit-debug-proxy\" target=\"_blank\" rel=\"noopener\">ios-webkit-debug-proxy</a> 是我在无意间划水 Github 时发现的一个代理工具，它借助于 <a href=\"https://github.com/libimobiledevice/usbmuxd\" target=\"_blank\" rel=\"noopener\">usbmuxd</a> 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。</p>\n<p>借用项目中的示意图：</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png\" alt=\"\"></p>\n<h3 id=\"安装依赖：\"><a href=\"#安装依赖：\" class=\"headerlink\" title=\"安装依赖：\"></a>安装依赖：</h3><ul>\n<li><a href=\"http://brew.sh/\" target=\"_blank\" rel=\"noopener\">homebrew</a></li>\n</ul>\n<h3 id=\"安装方法：\"><a href=\"#安装方法：\" class=\"headerlink\" title=\"安装方法：\"></a>安装方法：</h3><blockquote>\n<p>为了避免出现 <code>Could not connect to lockdownd, error code -&lt;number&gt;. Exiting.</code> 错误，建议不要直接 <code>brew install ios-webkit-debug-proxy</code> 安装。  </p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew update</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew install --HEAD usbmuxd</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew install --HEAD libimobiledevice</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew install -s ios-webkit-debug-proxy</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: ios-webkit-debug-proxy</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  </p>\n</blockquote>\n<p>连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 <a href=\"h\">localhost:9221</a> 查看连接设备列表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: ios-webkit-debug-proxy</span></span><br><span class=\"line\">Listing devices on :9221</span><br><span class=\"line\">Connected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)</span><br><span class=\"line\">Disconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Chrome-拯救世人\"><a href=\"#Chrome-拯救世人\" class=\"headerlink\" title=\"Chrome 拯救世人\"></a>Chrome 拯救世人</h2><p>当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。</p>\n<ol>\n<li>我们就需要启动 Chrome</li>\n<li>打开 <a href=\"chrome://inspect\">Inspector</a> 页面</li>\n<li>点击 <code>Discover network targets</code> 后的 <code>configure</code> 按钮</li>\n<li>输入上面展示的设备端口地址：<code>localhost:9222</code> ，点击 <code>done</code> 按钮</li>\n<li>在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～</li>\n</ol>\n<p>不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 <a href=\"https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter\" target=\"_blank\" rel=\"noopener\">RemoteDebug iOS WebKit Adapter</a>，这个使用 ios-webkit-debug-proxy 做底层的一个工具。</p>\n<h2 id=\"Bug\"><a href=\"#Bug\" class=\"headerlink\" title=\"Bug\"></a>Bug</h2><p>笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。</p>\n","site":{"data":{}},"excerpt":"被 Safari 支配的恐惧\n\n曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain, TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。\n可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript","more":"<h2 id=\"被-Safari-支配的恐惧\"><a href=\"#被-Safari-支配的恐惧\" class=\"headerlink\" title=\"被 Safari 支配的恐惧\"></a>被 Safari 支配的恐惧</h2><p><img src=\"https://cdn.iguan7u.cn/image/safari_icon_240.png\" alt=\"Safari_Icoon\"><br>曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。<br>可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在<strong>使用大量能耗</strong>的应用列表上了。<br>当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari <strong>曾经</strong>是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。</p>\n<h2 id=\"ios-webkit-debug-proxy\"><a href=\"#ios-webkit-debug-proxy\" class=\"headerlink\" title=\"ios-webkit-debug-proxy\"></a>ios-webkit-debug-proxy</h2><p><a href=\"https://github.com/google/ios-webkit-debug-proxy\" target=\"_blank\" rel=\"noopener\">ios-webkit-debug-proxy</a> 是我在无意间划水 Github 时发现的一个代理工具，它借助于 <a href=\"https://github.com/libimobiledevice/usbmuxd\" target=\"_blank\" rel=\"noopener\">usbmuxd</a> 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。</p>\n<p>借用项目中的示意图：</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png\" alt=\"\"></p>\n<h3 id=\"安装依赖：\"><a href=\"#安装依赖：\" class=\"headerlink\" title=\"安装依赖：\"></a>安装依赖：</h3><ul>\n<li><a href=\"http://brew.sh/\" target=\"_blank\" rel=\"noopener\">homebrew</a></li>\n</ul>\n<h3 id=\"安装方法：\"><a href=\"#安装方法：\" class=\"headerlink\" title=\"安装方法：\"></a>安装方法：</h3><blockquote>\n<p>为了避免出现 <code>Could not connect to lockdownd, error code -&lt;number&gt;. Exiting.</code> 错误，建议不要直接 <code>brew install ios-webkit-debug-proxy</code> 安装。  </p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew update</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew install --HEAD usbmuxd</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew install --HEAD libimobiledevice</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: brew install -s ios-webkit-debug-proxy</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: ios-webkit-debug-proxy</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  </p>\n</blockquote>\n<p>连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 <a href=\"h\">localhost:9221</a> 查看连接设备列表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: ios-webkit-debug-proxy</span></span><br><span class=\"line\">Listing devices on :9221</span><br><span class=\"line\">Connected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)</span><br><span class=\"line\">Disconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Chrome-拯救世人\"><a href=\"#Chrome-拯救世人\" class=\"headerlink\" title=\"Chrome 拯救世人\"></a>Chrome 拯救世人</h2><p>当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。</p>\n<ol>\n<li>我们就需要启动 Chrome</li>\n<li>打开 <a href=\"chrome://inspect\">Inspector</a> 页面</li>\n<li>点击 <code>Discover network targets</code> 后的 <code>configure</code> 按钮</li>\n<li>输入上面展示的设备端口地址：<code>localhost:9222</code> ，点击 <code>done</code> 按钮</li>\n<li>在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～</li>\n</ol>\n<p>不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 <a href=\"https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter\" target=\"_blank\" rel=\"noopener\">RemoteDebug iOS WebKit Adapter</a>，这个使用 ios-webkit-debug-proxy 做底层的一个工具。</p>\n<h2 id=\"Bug\"><a href=\"#Bug\" class=\"headerlink\" title=\"Bug\"></a>Bug</h2><p>笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。</p>\n"},{"title":"Debug electron main process on VSCode","date":"2019-01-15T12:03:48.000Z","_content":"\n普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。[Electron](https://electronjs.org/) 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。\n\n### 官方指导\n\n在 Electron 官网中，可以找到文档 [使用 VSCode 进行主进程调试 | Electron](https://electronjs.org/docs/tutorial/debugging-main-process-vscode) 指引如何进行调试开发。\n\n### 发现问题\n\nElectron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。\n而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。\n\n### 解决方案\n\nelectron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 [Electron-Vue](https://github.com/SimulatedGREG/electron-vue) 的模版为例。\n\n##### 1. 修改 webpack dev 配置：\n\n在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。\n在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。\n```\n{\n...\n  devServer: {\n    writeToDisk: true,   // 开启磁盘存储功能\n    inline: false        // 关闭内联模式，修复可能 webpack 运行失败问题\n  },\n  devtool: '#source-map' // 保存 sourceMap 文件，断点调试需要\n}\n```\n\n##### 2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\n\n因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。\n除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。\n\n假设构建输出目录为 app/dist，新建一个 terminal，执行下面的命令：\n```\n# 启动主进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.main.config.js --port 9081 --content-base app/dist\n```\n\n同时，在另一个 terminal 中，执行下面的命令：\n```\n# 启动渲染进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.renderer.config.js --port 9080 --content-base app/dist\n```\n\n##### 3. 配置 VSCode debug：\n\n1. 启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；\n2. 在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)\n```\n{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n\t\t\t\"name\": \"Launch\",\n\t\t\t\"type\": \"node\",\n\t\t\t\"request\": \"launch\",\n\t\t\t\"program\": \"${workspaceRoot}/dist/electron/main.js\",\n\t\t\t\"stopOnEntry\": false,\n\t\t\t\"args\": [],\n\t\t\t\"cwd\": \"${workspaceRoot}\",\n                        // this points to the electron task runner\n\t\t\t\"runtimeExecutable\": \"${workspaceRoot}/node_modules/.bin/electron\",\n\t\t\t\"runtimeArgs\": [\n\t\t\t\t\"--nolazy\"\n\t\t\t],\n\t\t\t\"console\": \"integratedTerminal\",\n\t\t\t\"sourceMaps\": true,\n\t\t\t\"outFiles\": []\n    }\n\t]\n}\n```\n3. 选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；\n4. 在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；\n\n#### 热更新\n\n- 主进程跟渲染进程的编辑都能够热更新\n- 编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码\n- 编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码\n\nHave Fun.\n","source":"_posts/Debug-electron-main-process-on-VSCode.md","raw":"---\ntitle: Debug electron main process on VSCode\ndate: 2019-01-15 20:03:48\ntags: Electron\n---\n\n普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。[Electron](https://electronjs.org/) 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。\n\n### 官方指导\n\n在 Electron 官网中，可以找到文档 [使用 VSCode 进行主进程调试 | Electron](https://electronjs.org/docs/tutorial/debugging-main-process-vscode) 指引如何进行调试开发。\n\n### 发现问题\n\nElectron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。\n而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。\n\n### 解决方案\n\nelectron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 [Electron-Vue](https://github.com/SimulatedGREG/electron-vue) 的模版为例。\n\n##### 1. 修改 webpack dev 配置：\n\n在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。\n在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。\n```\n{\n...\n  devServer: {\n    writeToDisk: true,   // 开启磁盘存储功能\n    inline: false        // 关闭内联模式，修复可能 webpack 运行失败问题\n  },\n  devtool: '#source-map' // 保存 sourceMap 文件，断点调试需要\n}\n```\n\n##### 2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\n\n因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。\n除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。\n\n假设构建输出目录为 app/dist，新建一个 terminal，执行下面的命令：\n```\n# 启动主进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.main.config.js --port 9081 --content-base app/dist\n```\n\n同时，在另一个 terminal 中，执行下面的命令：\n```\n# 启动渲染进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.renderer.config.js --port 9080 --content-base app/dist\n```\n\n##### 3. 配置 VSCode debug：\n\n1. 启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；\n2. 在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)\n```\n{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n\t\t\t\"name\": \"Launch\",\n\t\t\t\"type\": \"node\",\n\t\t\t\"request\": \"launch\",\n\t\t\t\"program\": \"${workspaceRoot}/dist/electron/main.js\",\n\t\t\t\"stopOnEntry\": false,\n\t\t\t\"args\": [],\n\t\t\t\"cwd\": \"${workspaceRoot}\",\n                        // this points to the electron task runner\n\t\t\t\"runtimeExecutable\": \"${workspaceRoot}/node_modules/.bin/electron\",\n\t\t\t\"runtimeArgs\": [\n\t\t\t\t\"--nolazy\"\n\t\t\t],\n\t\t\t\"console\": \"integratedTerminal\",\n\t\t\t\"sourceMaps\": true,\n\t\t\t\"outFiles\": []\n    }\n\t]\n}\n```\n3. 选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；\n4. 在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；\n\n#### 热更新\n\n- 主进程跟渲染进程的编辑都能够热更新\n- 编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码\n- 编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码\n\nHave Fun.\n","slug":"Debug-electron-main-process-on-VSCode","published":1,"updated":"2019-04-30T12:13:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4malh0002kapc3lphdqah","content":"<p>普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。<a href=\"https://electronjs.org/\" target=\"_blank\" rel=\"noopener\">Electron</a> 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。</p>\n<h3 id=\"官方指导\"><a href=\"#官方指导\" class=\"headerlink\" title=\"官方指导\"></a>官方指导</h3><p>在 Electron 官网中，可以找到文档 <a href=\"https://electronjs.org/docs/tutorial/debugging-main-process-vscode\" target=\"_blank\" rel=\"noopener\">使用 VSCode 进行主进程调试 | Electron</a> 指引如何进行调试开发。</p>\n<h3 id=\"发现问题\"><a href=\"#发现问题\" class=\"headerlink\" title=\"发现问题\"></a>发现问题</h3><p>Electron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。<br>而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>electron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 <a href=\"https://github.com/SimulatedGREG/electron-vue\" target=\"_blank\" rel=\"noopener\">Electron-Vue</a> 的模版为例。</p>\n<h5 id=\"1-修改-webpack-dev-配置：\"><a href=\"#1-修改-webpack-dev-配置：\" class=\"headerlink\" title=\"1. 修改 webpack dev 配置：\"></a>1. 修改 webpack dev 配置：</h5><p>在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。<br>在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    writeToDisk: true,   &#x2F;&#x2F; 开启磁盘存储功能</span><br><span class=\"line\">    inline: false        &#x2F;&#x2F; 关闭内联模式，修复可能 webpack 运行失败问题</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: &#39;#source-map&#39; &#x2F;&#x2F; 保存 sourceMap 文件，断点调试需要</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\"><a href=\"#2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\" class=\"headerlink\" title=\"2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\"></a>2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：</h5><p>因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。<br>除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。</p>\n<p>假设构建输出目录为 app/dist，新建一个 terminal，执行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 启动主进程构建任务</span><br><span class=\"line\">$: webpack-dev-server --colors --config .&#x2F;.electron-vue&#x2F;webpack.main.config.js --port 9081 --content-base app&#x2F;dist</span><br></pre></td></tr></table></figure>\n\n<p>同时，在另一个 terminal 中，执行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 启动渲染进程构建任务</span><br><span class=\"line\">$: webpack-dev-server --colors --config .&#x2F;.electron-vue&#x2F;webpack.renderer.config.js --port 9080 --content-base app&#x2F;dist</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-配置-VSCode-debug：\"><a href=\"#3-配置-VSCode-debug：\" class=\"headerlink\" title=\"3. 配置 VSCode debug：\"></a>3. 配置 VSCode debug：</h5><ol>\n<li>启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；</li>\n<li>在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; Use IntelliSense to learn about possible Node.js debug attributes.</span><br><span class=\"line\">  &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class=\"line\">  &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class=\"line\">  &quot;configurations&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">222&quot;name&quot;: &quot;Launch&quot;,</span><br><span class=\"line\">222&quot;type&quot;: &quot;node&quot;,</span><br><span class=\"line\">222&quot;request&quot;: &quot;launch&quot;,</span><br><span class=\"line\">222&quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;dist&#x2F;electron&#x2F;main.js&quot;,</span><br><span class=\"line\">222&quot;stopOnEntry&quot;: false,</span><br><span class=\"line\">222&quot;args&quot;: [],</span><br><span class=\"line\">222&quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class=\"line\">                        &#x2F;&#x2F; this points to the electron task runner</span><br><span class=\"line\">222&quot;runtimeExecutable&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;node_modules&#x2F;.bin&#x2F;electron&quot;,</span><br><span class=\"line\">222&quot;runtimeArgs&quot;: [</span><br><span class=\"line\">2222&quot;--nolazy&quot;</span><br><span class=\"line\">222],</span><br><span class=\"line\">222&quot;console&quot;: &quot;integratedTerminal&quot;,</span><br><span class=\"line\">222&quot;sourceMaps&quot;: true,</span><br><span class=\"line\">222&quot;outFiles&quot;: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；</li>\n<li>在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；</li>\n</ol>\n<h4 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h4><ul>\n<li>主进程跟渲染进程的编辑都能够热更新</li>\n<li>编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码</li>\n<li>编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码</li>\n</ul>\n<p>Have Fun.</p>\n","site":{"data":{}},"excerpt":"普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。Electron 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。\n","more":"<p>普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。<a href=\"https://electronjs.org/\" target=\"_blank\" rel=\"noopener\">Electron</a> 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。</p>\n<h3 id=\"官方指导\"><a href=\"#官方指导\" class=\"headerlink\" title=\"官方指导\"></a>官方指导</h3><p>在 Electron 官网中，可以找到文档 <a href=\"https://electronjs.org/docs/tutorial/debugging-main-process-vscode\" target=\"_blank\" rel=\"noopener\">使用 VSCode 进行主进程调试 | Electron</a> 指引如何进行调试开发。</p>\n<h3 id=\"发现问题\"><a href=\"#发现问题\" class=\"headerlink\" title=\"发现问题\"></a>发现问题</h3><p>Electron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。<br>而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>electron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 <a href=\"https://github.com/SimulatedGREG/electron-vue\" target=\"_blank\" rel=\"noopener\">Electron-Vue</a> 的模版为例。</p>\n<h5 id=\"1-修改-webpack-dev-配置：\"><a href=\"#1-修改-webpack-dev-配置：\" class=\"headerlink\" title=\"1. 修改 webpack dev 配置：\"></a>1. 修改 webpack dev 配置：</h5><p>在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。<br>在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    writeToDisk: true,   &#x2F;&#x2F; 开启磁盘存储功能</span><br><span class=\"line\">    inline: false        &#x2F;&#x2F; 关闭内联模式，修复可能 webpack 运行失败问题</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  devtool: &#39;#source-map&#39; &#x2F;&#x2F; 保存 sourceMap 文件，断点调试需要</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\"><a href=\"#2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\" class=\"headerlink\" title=\"2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\"></a>2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：</h5><p>因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。<br>除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。</p>\n<p>假设构建输出目录为 app/dist，新建一个 terminal，执行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 启动主进程构建任务</span><br><span class=\"line\">$: webpack-dev-server --colors --config .&#x2F;.electron-vue&#x2F;webpack.main.config.js --port 9081 --content-base app&#x2F;dist</span><br></pre></td></tr></table></figure>\n\n<p>同时，在另一个 terminal 中，执行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 启动渲染进程构建任务</span><br><span class=\"line\">$: webpack-dev-server --colors --config .&#x2F;.electron-vue&#x2F;webpack.renderer.config.js --port 9080 --content-base app&#x2F;dist</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-配置-VSCode-debug：\"><a href=\"#3-配置-VSCode-debug：\" class=\"headerlink\" title=\"3. 配置 VSCode debug：\"></a>3. 配置 VSCode debug：</h5><ol>\n<li>启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；</li>\n<li>在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; Use IntelliSense to learn about possible Node.js debug attributes.</span><br><span class=\"line\">  &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class=\"line\">  &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class=\"line\">  &quot;configurations&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">222&quot;name&quot;: &quot;Launch&quot;,</span><br><span class=\"line\">222&quot;type&quot;: &quot;node&quot;,</span><br><span class=\"line\">222&quot;request&quot;: &quot;launch&quot;,</span><br><span class=\"line\">222&quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;dist&#x2F;electron&#x2F;main.js&quot;,</span><br><span class=\"line\">222&quot;stopOnEntry&quot;: false,</span><br><span class=\"line\">222&quot;args&quot;: [],</span><br><span class=\"line\">222&quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class=\"line\">                        &#x2F;&#x2F; this points to the electron task runner</span><br><span class=\"line\">222&quot;runtimeExecutable&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;node_modules&#x2F;.bin&#x2F;electron&quot;,</span><br><span class=\"line\">222&quot;runtimeArgs&quot;: [</span><br><span class=\"line\">2222&quot;--nolazy&quot;</span><br><span class=\"line\">222],</span><br><span class=\"line\">222&quot;console&quot;: &quot;integratedTerminal&quot;,</span><br><span class=\"line\">222&quot;sourceMaps&quot;: true,</span><br><span class=\"line\">222&quot;outFiles&quot;: []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">2]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；</li>\n<li>在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；</li>\n</ol>\n<h4 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h4><ul>\n<li>主进程跟渲染进程的编辑都能够热更新</li>\n<li>编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码</li>\n<li>编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码</li>\n</ul>\n<p>Have Fun.</p>\n"},{"title":"Hello World","date":"1969-12-31T16:00:01.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 1970-01-01 00:00:01\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-04-30T12:13:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4mali0003kapc8nt14q0w","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuic","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Electron asar 格式详解","date":"2019-03-19T12:08:11.000Z","_content":"\n## What is asar?\n[asar](https://github.com/electron/asar) —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 [Electron Packager](https://github.com/electron-userland/electron-packager) 或者 [Electron Builder](https://github.com/electron-userland/electron-builder) 等构建工具时，都会默认开启 .asar 归档模式。\n\nasar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：\n\n```json\n{\n   \"files\": {\t\t\t\t// 文件结构起始位置\n      \"tmp\": {\t\t\t// 其中包含了一个 tmp 文件夹\n         \"files\": {}\n      },\n      \"usr\" : {\t\t\t// 其中包含了一个 files 文件夹\n         \"files\": {\n           \"bin\": {\t\t// files 文件夹中存在 bin 文件夹\n             \"files\": {\n               \"ls\": {\t// bin 文件夹有一个 ls 文件\n                 \"offset\": \"0\",\t// 文件起始位置 为 0\n                 \"size\": 100,\t\t// 文件大小是 100\n                 \"executable\": true\t// 该文件可以被执行\n               }\n             }\n           }\n         }\n      }\n   }\n}\n```\n\n通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。\n\n## Why use it?\n在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。\n\n除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。\n\n最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 [UglifyJS](http://lisperator.net/uglifyjs/) 等代码混淆工具。\n\n## How do use it?\n首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。\n\n全局安装 asar，或者通过 npx 命令执行：\n```\n# 全局安装 asar\n$: npm install -g asar\n```\n\n使用 asar 打包资源文件：\n```\n$: asar pack your-app-resource-folder app.asar\n```\n\n将打包资源放到指定路径：\n\tmacOS 中默认放入  `electron/Electron.app/Contents/Resources/app.asar`\n\tWindows 和 Linux 默认放入  `electron/resources/app.asar`\n\n## Other Questions\nQ: **Electron 是怎么读取 asar 文件的？**\nA：Electron 中使用了其自定义的 `fs` `require` 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。\n\nQ：**如何获取 asar 文件的属性？**\nA：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 `original-fs` 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。\n\nQ：**如何解包 asar 文件？**\nA：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：\n\n```shell\n$: asar extract app.asar dest_path\n```\n\n更多的 asar 工具命令，可以通过 `asar --help` 命令查看。\n\nEnjoy it.\n","source":"_posts/Electron-asar-格式详解.md","raw":"---\ntitle: Electron asar 格式详解\ndate: 2019-03-19 20:08:11\ntags:\n---\n\n## What is asar?\n[asar](https://github.com/electron/asar) —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 [Electron Packager](https://github.com/electron-userland/electron-packager) 或者 [Electron Builder](https://github.com/electron-userland/electron-builder) 等构建工具时，都会默认开启 .asar 归档模式。\n\nasar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：\n\n```json\n{\n   \"files\": {\t\t\t\t// 文件结构起始位置\n      \"tmp\": {\t\t\t// 其中包含了一个 tmp 文件夹\n         \"files\": {}\n      },\n      \"usr\" : {\t\t\t// 其中包含了一个 files 文件夹\n         \"files\": {\n           \"bin\": {\t\t// files 文件夹中存在 bin 文件夹\n             \"files\": {\n               \"ls\": {\t// bin 文件夹有一个 ls 文件\n                 \"offset\": \"0\",\t// 文件起始位置 为 0\n                 \"size\": 100,\t\t// 文件大小是 100\n                 \"executable\": true\t// 该文件可以被执行\n               }\n             }\n           }\n         }\n      }\n   }\n}\n```\n\n通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。\n\n## Why use it?\n在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。\n\n除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。\n\n最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 [UglifyJS](http://lisperator.net/uglifyjs/) 等代码混淆工具。\n\n## How do use it?\n首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。\n\n全局安装 asar，或者通过 npx 命令执行：\n```\n# 全局安装 asar\n$: npm install -g asar\n```\n\n使用 asar 打包资源文件：\n```\n$: asar pack your-app-resource-folder app.asar\n```\n\n将打包资源放到指定路径：\n\tmacOS 中默认放入  `electron/Electron.app/Contents/Resources/app.asar`\n\tWindows 和 Linux 默认放入  `electron/resources/app.asar`\n\n## Other Questions\nQ: **Electron 是怎么读取 asar 文件的？**\nA：Electron 中使用了其自定义的 `fs` `require` 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。\n\nQ：**如何获取 asar 文件的属性？**\nA：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 `original-fs` 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。\n\nQ：**如何解包 asar 文件？**\nA：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：\n\n```shell\n$: asar extract app.asar dest_path\n```\n\n更多的 asar 工具命令，可以通过 `asar --help` 命令查看。\n\nEnjoy it.\n","slug":"Electron-asar-格式详解","published":1,"updated":"2019-04-30T12:10:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4malj0004kapc3mcm8s0q","content":"<h2 id=\"What-is-asar\"><a href=\"#What-is-asar\" class=\"headerlink\" title=\"What is asar?\"></a>What is asar?</h2><p><a href=\"https://github.com/electron/asar\" target=\"_blank\" rel=\"noopener\">asar</a> —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 <a href=\"https://github.com/electron-userland/electron-packager\" target=\"_blank\" rel=\"noopener\">Electron Packager</a> 或者 <a href=\"https://github.com/electron-userland/electron-builder\" target=\"_blank\" rel=\"noopener\">Electron Builder</a> 等构建工具时，都会默认开启 .asar 归档模式。</p>\n<p>asar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"files\"</span>: &#123;\t\t\t\t<span class=\"comment\">// 文件结构起始位置</span></span><br><span class=\"line\">      <span class=\"attr\">\"tmp\"</span>: &#123;\t\t\t<span class=\"comment\">// 其中包含了一个 tmp 文件夹</span></span><br><span class=\"line\">         <span class=\"attr\">\"files\"</span>: &#123;&#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"usr\"</span> : &#123;\t\t\t<span class=\"comment\">// 其中包含了一个 files 文件夹</span></span><br><span class=\"line\">         <span class=\"attr\">\"files\"</span>: &#123;</span><br><span class=\"line\">           <span class=\"attr\">\"bin\"</span>: &#123;\t\t<span class=\"comment\">// files 文件夹中存在 bin 文件夹</span></span><br><span class=\"line\">             <span class=\"attr\">\"files\"</span>: &#123;</span><br><span class=\"line\">               <span class=\"attr\">\"ls\"</span>: &#123;\t<span class=\"comment\">// bin 文件夹有一个 ls 文件</span></span><br><span class=\"line\">                 <span class=\"attr\">\"offset\"</span>: <span class=\"string\">\"0\"</span>,\t<span class=\"comment\">// 文件起始位置 为 0</span></span><br><span class=\"line\">                 <span class=\"attr\">\"size\"</span>: <span class=\"number\">100</span>,\t\t<span class=\"comment\">// 文件大小是 100</span></span><br><span class=\"line\">                 <span class=\"attr\">\"executable\"</span>: <span class=\"literal\">true</span>\t<span class=\"comment\">// 该文件可以被执行</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。</p>\n<h2 id=\"Why-use-it\"><a href=\"#Why-use-it\" class=\"headerlink\" title=\"Why use it?\"></a>Why use it?</h2><p>在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。</p>\n<p>除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。</p>\n<p>最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 <a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"noopener\">UglifyJS</a> 等代码混淆工具。</p>\n<h2 id=\"How-do-use-it\"><a href=\"#How-do-use-it\" class=\"headerlink\" title=\"How do use it?\"></a>How do use it?</h2><p>首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。</p>\n<p>全局安装 asar，或者通过 npx 命令执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 全局安装 asar</span><br><span class=\"line\">$: npm install -g asar</span><br></pre></td></tr></table></figure>\n\n<p>使用 asar 打包资源文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$: asar pack your-app-resource-folder app.asar</span><br></pre></td></tr></table></figure>\n\n<p>将打包资源放到指定路径：<br>    macOS 中默认放入  <code>electron/Electron.app/Contents/Resources/app.asar</code><br>    Windows 和 Linux 默认放入  <code>electron/resources/app.asar</code></p>\n<h2 id=\"Other-Questions\"><a href=\"#Other-Questions\" class=\"headerlink\" title=\"Other Questions\"></a>Other Questions</h2><p>Q: <strong>Electron 是怎么读取 asar 文件的？</strong><br>A：Electron 中使用了其自定义的 <code>fs</code> <code>require</code> 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。</p>\n<p>Q：<strong>如何获取 asar 文件的属性？</strong><br>A：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 <code>original-fs</code> 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。</p>\n<p>Q：<strong>如何解包 asar 文件？</strong><br>A：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: asar extract app.asar dest_path</span></span><br></pre></td></tr></table></figure>\n\n<p>更多的 asar 工具命令，可以通过 <code>asar --help</code> 命令查看。</p>\n<p>Enjoy it.</p>\n","site":{"data":{}},"excerpt":"What is asar?\nasar —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:) Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 Electron ","more":"<h2 id=\"What-is-asar\"><a href=\"#What-is-asar\" class=\"headerlink\" title=\"What is asar?\"></a>What is asar?</h2><p><a href=\"https://github.com/electron/asar\" target=\"_blank\" rel=\"noopener\">asar</a> —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 <a href=\"https://github.com/electron-userland/electron-packager\" target=\"_blank\" rel=\"noopener\">Electron Packager</a> 或者 <a href=\"https://github.com/electron-userland/electron-builder\" target=\"_blank\" rel=\"noopener\">Electron Builder</a> 等构建工具时，都会默认开启 .asar 归档模式。</p>\n<p>asar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">\"files\"</span>: &#123;\t\t\t\t<span class=\"comment\">// 文件结构起始位置</span></span><br><span class=\"line\">      <span class=\"attr\">\"tmp\"</span>: &#123;\t\t\t<span class=\"comment\">// 其中包含了一个 tmp 文件夹</span></span><br><span class=\"line\">         <span class=\"attr\">\"files\"</span>: &#123;&#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">\"usr\"</span> : &#123;\t\t\t<span class=\"comment\">// 其中包含了一个 files 文件夹</span></span><br><span class=\"line\">         <span class=\"attr\">\"files\"</span>: &#123;</span><br><span class=\"line\">           <span class=\"attr\">\"bin\"</span>: &#123;\t\t<span class=\"comment\">// files 文件夹中存在 bin 文件夹</span></span><br><span class=\"line\">             <span class=\"attr\">\"files\"</span>: &#123;</span><br><span class=\"line\">               <span class=\"attr\">\"ls\"</span>: &#123;\t<span class=\"comment\">// bin 文件夹有一个 ls 文件</span></span><br><span class=\"line\">                 <span class=\"attr\">\"offset\"</span>: <span class=\"string\">\"0\"</span>,\t<span class=\"comment\">// 文件起始位置 为 0</span></span><br><span class=\"line\">                 <span class=\"attr\">\"size\"</span>: <span class=\"number\">100</span>,\t\t<span class=\"comment\">// 文件大小是 100</span></span><br><span class=\"line\">                 <span class=\"attr\">\"executable\"</span>: <span class=\"literal\">true</span>\t<span class=\"comment\">// 该文件可以被执行</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。</p>\n<h2 id=\"Why-use-it\"><a href=\"#Why-use-it\" class=\"headerlink\" title=\"Why use it?\"></a>Why use it?</h2><p>在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。</p>\n<p>除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。</p>\n<p>最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 <a href=\"http://lisperator.net/uglifyjs/\" target=\"_blank\" rel=\"noopener\">UglifyJS</a> 等代码混淆工具。</p>\n<h2 id=\"How-do-use-it\"><a href=\"#How-do-use-it\" class=\"headerlink\" title=\"How do use it?\"></a>How do use it?</h2><p>首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。</p>\n<p>全局安装 asar，或者通过 npx 命令执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 全局安装 asar</span><br><span class=\"line\">$: npm install -g asar</span><br></pre></td></tr></table></figure>\n\n<p>使用 asar 打包资源文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$: asar pack your-app-resource-folder app.asar</span><br></pre></td></tr></table></figure>\n\n<p>将打包资源放到指定路径：<br>    macOS 中默认放入  <code>electron/Electron.app/Contents/Resources/app.asar</code><br>    Windows 和 Linux 默认放入  <code>electron/resources/app.asar</code></p>\n<h2 id=\"Other-Questions\"><a href=\"#Other-Questions\" class=\"headerlink\" title=\"Other Questions\"></a>Other Questions</h2><p>Q: <strong>Electron 是怎么读取 asar 文件的？</strong><br>A：Electron 中使用了其自定义的 <code>fs</code> <code>require</code> 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。</p>\n<p>Q：<strong>如何获取 asar 文件的属性？</strong><br>A：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 <code>original-fs</code> 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。</p>\n<p>Q：<strong>如何解包 asar 文件？</strong><br>A：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">: asar extract app.asar dest_path</span></span><br></pre></td></tr></table></figure>\n\n<p>更多的 asar 工具命令，可以通过 <code>asar --help</code> 命令查看。</p>\n<p>Enjoy it.</p>\n"},{"title":"大端与小端","date":"2019-01-01T11:34:16.000Z","_content":"\n## 起源\n众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。\n然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。\n\n## 发展\n> Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。  \n> ——《格利佛游记》乔纳森·斯威夫特（Gulliver's Travels by Jonathan Swift）  \n\n在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 [Danny Cohen](https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)) 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：**大端**、**小端**。\n在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为**内存地址**。而大小端的差别，就是根据内存地址存放方式的差别。\n\n### 大端\n高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。\n\n### 小端模式\n低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。\n\n下图表示 12345678 数字在内存中的表现差异：\n\n\n![bigLittleEndian.gif](https://cdn.iguan7u.cn/bigLittleEndian.gif \"bigLittleEndian.gif\")\n\n\n上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。\n\n## 原因\n> 存在即有意义。  \n\n小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：\n小端模式更符合计算运行规律。基本计算都有个铁则：**从低位算起**。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。\n相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。\n而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0/1 表示该数值为正数或者负数）。\n\n## 出现场景\n搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。\n\n","source":"_posts/大端与小端.md","raw":"---\ntitle: 大端与小端\ndate: 2019-01-01 19:34:16\ntags:\n---\n\n## 起源\n众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。\n然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。\n\n## 发展\n> Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。  \n> ——《格利佛游记》乔纳森·斯威夫特（Gulliver's Travels by Jonathan Swift）  \n\n在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 [Danny Cohen](https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)) 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：**大端**、**小端**。\n在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为**内存地址**。而大小端的差别，就是根据内存地址存放方式的差别。\n\n### 大端\n高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。\n\n### 小端模式\n低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。\n\n下图表示 12345678 数字在内存中的表现差异：\n\n\n![bigLittleEndian.gif](https://cdn.iguan7u.cn/bigLittleEndian.gif \"bigLittleEndian.gif\")\n\n\n上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。\n\n## 原因\n> 存在即有意义。  \n\n小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：\n小端模式更符合计算运行规律。基本计算都有个铁则：**从低位算起**。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。\n相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。\n而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0/1 表示该数值为正数或者负数）。\n\n## 出现场景\n搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。\n\n","slug":"大端与小端","published":1,"updated":"2019-04-30T12:10:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4malj0005kapc3xk76imo","content":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。<br>然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。</p>\n<h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><blockquote>\n<p>Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。<br>——《格利佛游记》乔纳森·斯威夫特（Gulliver’s Travels by Jonathan Swift）  </p>\n</blockquote>\n<p>在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 <a href=\"https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)\" target=\"_blank\" rel=\"noopener\">Danny Cohen</a> 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：<strong>大端</strong>、<strong>小端</strong>。<br>在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为<strong>内存地址</strong>。而大小端的差别，就是根据内存地址存放方式的差别。</p>\n<h3 id=\"大端\"><a href=\"#大端\" class=\"headerlink\" title=\"大端\"></a>大端</h3><p>高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。</p>\n<h3 id=\"小端模式\"><a href=\"#小端模式\" class=\"headerlink\" title=\"小端模式\"></a>小端模式</h3><p>低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。</p>\n<p>下图表示 12345678 数字在内存中的表现差异：</p>\n<p><img src=\"https://cdn.iguan7u.cn/bigLittleEndian.gif\" alt=\"bigLittleEndian.gif\" title=\"bigLittleEndian.gif\"></p>\n<p>上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><blockquote>\n<p>存在即有意义。  </p>\n</blockquote>\n<p>小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：<br>小端模式更符合计算运行规律。基本计算都有个铁则：<strong>从低位算起</strong>。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。<br>相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。<br>而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0/1 表示该数值为正数或者负数）。</p>\n<h2 id=\"出现场景\"><a href=\"#出现场景\" class=\"headerlink\" title=\"出现场景\"></a>出现场景</h2><p>搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。</p>\n","site":{"data":{}},"excerpt":"起源\n众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSI","more":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。<br>然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。</p>\n<h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><blockquote>\n<p>Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。<br>——《格利佛游记》乔纳森·斯威夫特（Gulliver’s Travels by Jonathan Swift）  </p>\n</blockquote>\n<p>在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 <a href=\"https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)\" target=\"_blank\" rel=\"noopener\">Danny Cohen</a> 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：<strong>大端</strong>、<strong>小端</strong>。<br>在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为<strong>内存地址</strong>。而大小端的差别，就是根据内存地址存放方式的差别。</p>\n<h3 id=\"大端\"><a href=\"#大端\" class=\"headerlink\" title=\"大端\"></a>大端</h3><p>高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。</p>\n<h3 id=\"小端模式\"><a href=\"#小端模式\" class=\"headerlink\" title=\"小端模式\"></a>小端模式</h3><p>低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。</p>\n<p>下图表示 12345678 数字在内存中的表现差异：</p>\n<p><img src=\"https://cdn.iguan7u.cn/bigLittleEndian.gif\" alt=\"bigLittleEndian.gif\" title=\"bigLittleEndian.gif\"></p>\n<p>上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><blockquote>\n<p>存在即有意义。  </p>\n</blockquote>\n<p>小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：<br>小端模式更符合计算运行规律。基本计算都有个铁则：<strong>从低位算起</strong>。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。<br>相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。<br>而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0/1 表示该数值为正数或者负数）。</p>\n<h2 id=\"出现场景\"><a href=\"#出现场景\" class=\"headerlink\" title=\"出现场景\"></a>出现场景</h2><p>搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。</p>\n"},{"title":"终于入手了人生第一台黑苹果","date":"2019-08-28T08:32:32.000Z","_content":"## 为什么选择黑苹果\n这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。\n\n### 是价钱的问题吗？\n配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。\n\n### 是因为喜欢“白嫖”吗？\n自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。\n\n### 生命在于折腾。\n\n**可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。**\n\n这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。\n我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。\n\n~~最后再升华一下：这是一种人生态度。~~\n\n## 配置\n- CPU：i7 9700K\n- 主板：Gigabyte Z390M Gaming\n- 内存：海盗船复仇者 16G DDR4 3200\n- 显卡：迪兰 RX580 2304sp 8G\n- 硬盘：三星 970evo 500G\n- 网卡：BCM94360CD（包括蓝牙）\n- 电源：EVGA 750P2 全模组\n- 散热：JONSBO 乔思伯 TW3-240\n- 机箱：JONSBO 乔思伯 C3-PLUS\n- 显示器：AOC U2790VQ 27” 4K\n- 键鼠：Magic Keyboard 2 & Mouse 2\n\n### 要不要 AMD Yes?\n\n![INTELvsAMD](https://cdn.iguan7u.cn/image/INTELvsAMD.png)\n\n\n其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。\n\n> 虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要**手动修改安装包，替换为支持 AMD 的内核** （有兴趣了解到，可以到 [AMD OSX](https://amd-osx.com) 论坛中查看一下）。虽然 macOS 内核项目 [XNU(XNU is Not Unix)](https://github.com/apple/darwin-xnu?) 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  \n\n最新的方法是直接通过 Clover 往内核注入 [AMD Patch](https://github.com/AMD-OSX/AMD_Vanilla)，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。\n经过一番挣扎之后，还是放弃 Yes 了… \n\n### 如何挑选主板？\n其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 [Buyer‘s Guide](https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/) 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。\n\n### 如何挑选显卡\n\n![AMDvsNVDIA](https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg)\n\n简单一句话，就是：**AMD Yes!**\n不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。\n当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。\n“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 [WebDrivers](https://www.tonymacx86.com/nvidia-drivers/) 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。[这里还有个小故事](https://www.jianshu.com/p/3753bbd8cd90)\n\n> Sierra Forever, or AMD Yes!  \n\n上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照[黑果小兵](https://blog.daliansky.net/Mojave-Hardware-Support-List.html)的硬件支持列表，选择合适的显卡。\n\n## 安装过程\n这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的[安装教程](https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/)，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。\n\n## 现状\n1. CPU 变频正常\n2. GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示\n3. 蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项\n4. Wi-Fi 正常\n5. 关机正常，断电正常\n6. 睡眠基本正常（蓝牙有几率出现小问题）\n7. iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）\n8. 音频输出正常\n9. 所有 USB 接口正常\n10. Airdrop 正常，handoff 正常\n11. 主板网口正常\n\n老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。\n对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。\n这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。\n\n## 问题\n1. 启动时几率性会遇到 Clover 的 `Couldn't allocate runtime area` 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案\n2. 几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）\n3. 几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒\n4. 启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）\n5. 主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入\n\n这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。\n\n## 最后说一句\n其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！\n\n最后上图一张：\n![成果](https://cdn.iguan7u.cn/image/IMG_0515.jpg)\n\n#折腾/MacOS","source":"_posts/终于入手了人生第一台黑苹果.md","raw":"---\ntitle: 终于入手了人生第一台黑苹果\ndate: 2019-08-28 16:32:32\ntags:\n---\n## 为什么选择黑苹果\n这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。\n\n### 是价钱的问题吗？\n配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。\n\n### 是因为喜欢“白嫖”吗？\n自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。\n\n### 生命在于折腾。\n\n**可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。**\n\n这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。\n我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。\n\n~~最后再升华一下：这是一种人生态度。~~\n\n## 配置\n- CPU：i7 9700K\n- 主板：Gigabyte Z390M Gaming\n- 内存：海盗船复仇者 16G DDR4 3200\n- 显卡：迪兰 RX580 2304sp 8G\n- 硬盘：三星 970evo 500G\n- 网卡：BCM94360CD（包括蓝牙）\n- 电源：EVGA 750P2 全模组\n- 散热：JONSBO 乔思伯 TW3-240\n- 机箱：JONSBO 乔思伯 C3-PLUS\n- 显示器：AOC U2790VQ 27” 4K\n- 键鼠：Magic Keyboard 2 & Mouse 2\n\n### 要不要 AMD Yes?\n\n![INTELvsAMD](https://cdn.iguan7u.cn/image/INTELvsAMD.png)\n\n\n其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。\n\n> 虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要**手动修改安装包，替换为支持 AMD 的内核** （有兴趣了解到，可以到 [AMD OSX](https://amd-osx.com) 论坛中查看一下）。虽然 macOS 内核项目 [XNU(XNU is Not Unix)](https://github.com/apple/darwin-xnu?) 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  \n\n最新的方法是直接通过 Clover 往内核注入 [AMD Patch](https://github.com/AMD-OSX/AMD_Vanilla)，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。\n经过一番挣扎之后，还是放弃 Yes 了… \n\n### 如何挑选主板？\n其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 [Buyer‘s Guide](https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/) 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。\n\n### 如何挑选显卡\n\n![AMDvsNVDIA](https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg)\n\n简单一句话，就是：**AMD Yes!**\n不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。\n当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。\n“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 [WebDrivers](https://www.tonymacx86.com/nvidia-drivers/) 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。[这里还有个小故事](https://www.jianshu.com/p/3753bbd8cd90)\n\n> Sierra Forever, or AMD Yes!  \n\n上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照[黑果小兵](https://blog.daliansky.net/Mojave-Hardware-Support-List.html)的硬件支持列表，选择合适的显卡。\n\n## 安装过程\n这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的[安装教程](https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/)，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。\n\n## 现状\n1. CPU 变频正常\n2. GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示\n3. 蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项\n4. Wi-Fi 正常\n5. 关机正常，断电正常\n6. 睡眠基本正常（蓝牙有几率出现小问题）\n7. iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）\n8. 音频输出正常\n9. 所有 USB 接口正常\n10. Airdrop 正常，handoff 正常\n11. 主板网口正常\n\n老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。\n对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。\n这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。\n\n## 问题\n1. 启动时几率性会遇到 Clover 的 `Couldn't allocate runtime area` 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案\n2. 几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）\n3. 几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒\n4. 启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）\n5. 主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入\n\n这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。\n\n## 最后说一句\n其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！\n\n最后上图一张：\n![成果](https://cdn.iguan7u.cn/image/IMG_0515.jpg)\n\n#折腾/MacOS","slug":"终于入手了人生第一台黑苹果","published":1,"updated":"2019-08-28T08:43:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4malm0006kapcbhne2xjt","content":"<h2 id=\"为什么选择黑苹果\"><a href=\"#为什么选择黑苹果\" class=\"headerlink\" title=\"为什么选择黑苹果\"></a>为什么选择黑苹果</h2><p>这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。</p>\n<h3 id=\"是价钱的问题吗？\"><a href=\"#是价钱的问题吗？\" class=\"headerlink\" title=\"是价钱的问题吗？\"></a>是价钱的问题吗？</h3><p>配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。</p>\n<h3 id=\"是因为喜欢“白嫖”吗？\"><a href=\"#是因为喜欢“白嫖”吗？\" class=\"headerlink\" title=\"是因为喜欢“白嫖”吗？\"></a>是因为喜欢“白嫖”吗？</h3><p>自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。</p>\n<h3 id=\"生命在于折腾。\"><a href=\"#生命在于折腾。\" class=\"headerlink\" title=\"生命在于折腾。\"></a>生命在于折腾。</h3><p><strong>可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。</strong></p>\n<p>这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。<br>我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。</p>\n<p><del>最后再升华一下：这是一种人生态度。</del></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li>CPU：i7 9700K</li>\n<li>主板：Gigabyte Z390M Gaming</li>\n<li>内存：海盗船复仇者 16G DDR4 3200</li>\n<li>显卡：迪兰 RX580 2304sp 8G</li>\n<li>硬盘：三星 970evo 500G</li>\n<li>网卡：BCM94360CD（包括蓝牙）</li>\n<li>电源：EVGA 750P2 全模组</li>\n<li>散热：JONSBO 乔思伯 TW3-240</li>\n<li>机箱：JONSBO 乔思伯 C3-PLUS</li>\n<li>显示器：AOC U2790VQ 27” 4K</li>\n<li>键鼠：Magic Keyboard 2 &amp; Mouse 2</li>\n</ul>\n<h3 id=\"要不要-AMD-Yes\"><a href=\"#要不要-AMD-Yes\" class=\"headerlink\" title=\"要不要 AMD Yes?\"></a>要不要 AMD Yes?</h3><p><img src=\"https://cdn.iguan7u.cn/image/INTELvsAMD.png\" alt=\"INTELvsAMD\"></p>\n<p>其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。</p>\n<blockquote>\n<p>虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要<strong>手动修改安装包，替换为支持 AMD 的内核</strong> （有兴趣了解到，可以到 <a href=\"https://amd-osx.com\" target=\"_blank\" rel=\"noopener\">AMD OSX</a> 论坛中查看一下）。虽然 macOS 内核项目 <a href=\"https://github.com/apple/darwin-xnu?\" target=\"_blank\" rel=\"noopener\">XNU(XNU is Not Unix)</a> 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  </p>\n</blockquote>\n<p>最新的方法是直接通过 Clover 往内核注入 <a href=\"https://github.com/AMD-OSX/AMD_Vanilla\" target=\"_blank\" rel=\"noopener\">AMD Patch</a>，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。<br>经过一番挣扎之后，还是放弃 Yes 了… </p>\n<h3 id=\"如何挑选主板？\"><a href=\"#如何挑选主板？\" class=\"headerlink\" title=\"如何挑选主板？\"></a>如何挑选主板？</h3><p>其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 <a href=\"https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/\" target=\"_blank\" rel=\"noopener\">Buyer‘s Guide</a> 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。</p>\n<h3 id=\"如何挑选显卡\"><a href=\"#如何挑选显卡\" class=\"headerlink\" title=\"如何挑选显卡\"></a>如何挑选显卡</h3><p><img src=\"https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg\" alt=\"AMDvsNVDIA\"></p>\n<p>简单一句话，就是：<strong>AMD Yes!</strong><br>不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。<br>当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。<br>“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 <a href=\"https://www.tonymacx86.com/nvidia-drivers/\" target=\"_blank\" rel=\"noopener\">WebDrivers</a> 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。<a href=\"https://www.jianshu.com/p/3753bbd8cd90\" target=\"_blank\" rel=\"noopener\">这里还有个小故事</a></p>\n<blockquote>\n<p>Sierra Forever, or AMD Yes!  </p>\n</blockquote>\n<p>上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照<a href=\"https://blog.daliansky.net/Mojave-Hardware-Support-List.html\" target=\"_blank\" rel=\"noopener\">黑果小兵</a>的硬件支持列表，选择合适的显卡。</p>\n<h2 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h2><p>这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的<a href=\"https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/\" target=\"_blank\" rel=\"noopener\">安装教程</a>，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><ol>\n<li>CPU 变频正常</li>\n<li>GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示</li>\n<li>蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项</li>\n<li>Wi-Fi 正常</li>\n<li>关机正常，断电正常</li>\n<li>睡眠基本正常（蓝牙有几率出现小问题）</li>\n<li>iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）</li>\n<li>音频输出正常</li>\n<li>所有 USB 接口正常</li>\n<li>Airdrop 正常，handoff 正常</li>\n<li>主板网口正常</li>\n</ol>\n<p>老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。<br>对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。<br>这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>启动时几率性会遇到 Clover 的 <code>Couldn&#39;t allocate runtime area</code> 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案</li>\n<li>几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）</li>\n<li>几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒</li>\n<li>启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）</li>\n<li>主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入</li>\n</ol>\n<p>这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。</p>\n<h2 id=\"最后说一句\"><a href=\"#最后说一句\" class=\"headerlink\" title=\"最后说一句\"></a>最后说一句</h2><p>其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！</p>\n<p>最后上图一张：<br><img src=\"https://cdn.iguan7u.cn/image/IMG_0515.jpg\" alt=\"成果\"></p>\n<p>#折腾/MacOS</p>\n","site":{"data":{}},"excerpt":"为什么选择黑苹果\n这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。\n\n是价钱的问题吗？\n配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减","more":"<h2 id=\"为什么选择黑苹果\"><a href=\"#为什么选择黑苹果\" class=\"headerlink\" title=\"为什么选择黑苹果\"></a>为什么选择黑苹果</h2><p>这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。</p>\n<h3 id=\"是价钱的问题吗？\"><a href=\"#是价钱的问题吗？\" class=\"headerlink\" title=\"是价钱的问题吗？\"></a>是价钱的问题吗？</h3><p>配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。</p>\n<h3 id=\"是因为喜欢“白嫖”吗？\"><a href=\"#是因为喜欢“白嫖”吗？\" class=\"headerlink\" title=\"是因为喜欢“白嫖”吗？\"></a>是因为喜欢“白嫖”吗？</h3><p>自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。</p>\n<h3 id=\"生命在于折腾。\"><a href=\"#生命在于折腾。\" class=\"headerlink\" title=\"生命在于折腾。\"></a>生命在于折腾。</h3><p><strong>可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。</strong></p>\n<p>这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。<br>我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。</p>\n<p><del>最后再升华一下：这是一种人生态度。</del></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li>CPU：i7 9700K</li>\n<li>主板：Gigabyte Z390M Gaming</li>\n<li>内存：海盗船复仇者 16G DDR4 3200</li>\n<li>显卡：迪兰 RX580 2304sp 8G</li>\n<li>硬盘：三星 970evo 500G</li>\n<li>网卡：BCM94360CD（包括蓝牙）</li>\n<li>电源：EVGA 750P2 全模组</li>\n<li>散热：JONSBO 乔思伯 TW3-240</li>\n<li>机箱：JONSBO 乔思伯 C3-PLUS</li>\n<li>显示器：AOC U2790VQ 27” 4K</li>\n<li>键鼠：Magic Keyboard 2 &amp; Mouse 2</li>\n</ul>\n<h3 id=\"要不要-AMD-Yes\"><a href=\"#要不要-AMD-Yes\" class=\"headerlink\" title=\"要不要 AMD Yes?\"></a>要不要 AMD Yes?</h3><p><img src=\"https://cdn.iguan7u.cn/image/INTELvsAMD.png\" alt=\"INTELvsAMD\"></p>\n<p>其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。</p>\n<blockquote>\n<p>虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要<strong>手动修改安装包，替换为支持 AMD 的内核</strong> （有兴趣了解到，可以到 <a href=\"https://amd-osx.com\" target=\"_blank\" rel=\"noopener\">AMD OSX</a> 论坛中查看一下）。虽然 macOS 内核项目 <a href=\"https://github.com/apple/darwin-xnu?\" target=\"_blank\" rel=\"noopener\">XNU(XNU is Not Unix)</a> 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  </p>\n</blockquote>\n<p>最新的方法是直接通过 Clover 往内核注入 <a href=\"https://github.com/AMD-OSX/AMD_Vanilla\" target=\"_blank\" rel=\"noopener\">AMD Patch</a>，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。<br>经过一番挣扎之后，还是放弃 Yes 了… </p>\n<h3 id=\"如何挑选主板？\"><a href=\"#如何挑选主板？\" class=\"headerlink\" title=\"如何挑选主板？\"></a>如何挑选主板？</h3><p>其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 <a href=\"https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/\" target=\"_blank\" rel=\"noopener\">Buyer‘s Guide</a> 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。</p>\n<h3 id=\"如何挑选显卡\"><a href=\"#如何挑选显卡\" class=\"headerlink\" title=\"如何挑选显卡\"></a>如何挑选显卡</h3><p><img src=\"https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg\" alt=\"AMDvsNVDIA\"></p>\n<p>简单一句话，就是：<strong>AMD Yes!</strong><br>不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。<br>当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。<br>“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 <a href=\"https://www.tonymacx86.com/nvidia-drivers/\" target=\"_blank\" rel=\"noopener\">WebDrivers</a> 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。<a href=\"https://www.jianshu.com/p/3753bbd8cd90\" target=\"_blank\" rel=\"noopener\">这里还有个小故事</a></p>\n<blockquote>\n<p>Sierra Forever, or AMD Yes!  </p>\n</blockquote>\n<p>上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照<a href=\"https://blog.daliansky.net/Mojave-Hardware-Support-List.html\" target=\"_blank\" rel=\"noopener\">黑果小兵</a>的硬件支持列表，选择合适的显卡。</p>\n<h2 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h2><p>这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的<a href=\"https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/\" target=\"_blank\" rel=\"noopener\">安装教程</a>，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><ol>\n<li>CPU 变频正常</li>\n<li>GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示</li>\n<li>蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项</li>\n<li>Wi-Fi 正常</li>\n<li>关机正常，断电正常</li>\n<li>睡眠基本正常（蓝牙有几率出现小问题）</li>\n<li>iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）</li>\n<li>音频输出正常</li>\n<li>所有 USB 接口正常</li>\n<li>Airdrop 正常，handoff 正常</li>\n<li>主板网口正常</li>\n</ol>\n<p>老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。<br>对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。<br>这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>启动时几率性会遇到 Clover 的 <code>Couldn&#39;t allocate runtime area</code> 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案</li>\n<li>几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）</li>\n<li>几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒</li>\n<li>启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）</li>\n<li>主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入</li>\n</ol>\n<p>这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。</p>\n<h2 id=\"最后说一句\"><a href=\"#最后说一句\" class=\"headerlink\" title=\"最后说一句\"></a>最后说一句</h2><p>其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！</p>\n<p>最后上图一张：<br><img src=\"https://cdn.iguan7u.cn/image/IMG_0515.jpg\" alt=\"成果\"></p>\n<p>#折腾/MacOS</p>\n"},{"title":"复盘 2018","date":"2019-03-17T12:07:39.000Z","_content":"\n度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。\n从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。\n\n## 2015-2016\n毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。\n\n### Clang Static Analyzer\n\n第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 **clang**，相应的，了解到 **LLVM**、**AST**，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。\n记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。\n假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。\n\n### Fauxpas\n\n那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 [Faux Pas for Xcode](http://fauxpasapp.com/) ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。\n\n优点：\n1. 代码检测规则实用；\n2. 可自行配置实用的规则；\n3. 检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；\n\n缺点：\n1. 收费应用；\n2. 无法自定义规则；\n\n### 持续集成\n\n接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。\n\n## 2016-2017\n众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。\n而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。\n\n##### 热更新\n\n随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 [JSPatch](https://github.com/bang590/JSPatch) 、 [wax](https://github.com/probablycorey/wax) 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。\n在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。\n\n因此热更新修复的流程，及其繁琐：\n1. 开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；\n2. 确认问题，使用原生代码修复该问题；\n3. 改用热更新框架语言，重新实现修复逻辑；\n4. 提单，测试进行介入，确认无误后准备上线现网；\n5. 灰度上线；\n6. 回到主干代码，merge 分支对应修复逻辑；\n7. 测试再次介入，确认问题在主干分支中也同样被解决；\n\n而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。\n在热更新方面，`JSPatch` 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 `wax patch`。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 `JSPatch` 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于**简单语句**，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。\n由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 [ANTLR](https://www.antlr.org)，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。\n\n> 后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  \n\n##### 跨平台开发\n\n在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。\n\n> Code once, run everywhere.  \n\n可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。\n而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。\n然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。\n所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。\n\n## 2017-2018\n终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。\n在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  \n\n与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如**单项数据流**这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。\n\n这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。\n\n而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。\n\n- 在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；\n\t1. JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；\n\t2. JS 逻辑中，根据 `navigator.onLine`属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；\n\t3. Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；\n\n- 离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中\n\t1. 由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护\n\t2. H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：\n\t\t1. sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；\n\t\t2. localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；\n\t\t3. Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案\n\t\t4. Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术\n\t折中取舍，我们最终选择的 localStorage 作为文档操作的存储\t方式。\n\t3. 因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。\n\t4. 离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。\n\n- 作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：\n\t- 考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。\n\t- 虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 `alloc` 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。\n \n老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。\n\n现在，终于可以开始 Enjoy the new beginning! \n","source":"_posts/复盘-2018.md","raw":"---\ntitle: 复盘 2018\ndate: 2019-03-17 20:07:39\ntags:\n---\n\n度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。\n从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。\n\n## 2015-2016\n毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。\n\n### Clang Static Analyzer\n\n第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 **clang**，相应的，了解到 **LLVM**、**AST**，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。\n记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。\n假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。\n\n### Fauxpas\n\n那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 [Faux Pas for Xcode](http://fauxpasapp.com/) ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。\n\n优点：\n1. 代码检测规则实用；\n2. 可自行配置实用的规则；\n3. 检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；\n\n缺点：\n1. 收费应用；\n2. 无法自定义规则；\n\n### 持续集成\n\n接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。\n\n## 2016-2017\n众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。\n而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。\n\n##### 热更新\n\n随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 [JSPatch](https://github.com/bang590/JSPatch) 、 [wax](https://github.com/probablycorey/wax) 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。\n在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。\n\n因此热更新修复的流程，及其繁琐：\n1. 开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；\n2. 确认问题，使用原生代码修复该问题；\n3. 改用热更新框架语言，重新实现修复逻辑；\n4. 提单，测试进行介入，确认无误后准备上线现网；\n5. 灰度上线；\n6. 回到主干代码，merge 分支对应修复逻辑；\n7. 测试再次介入，确认问题在主干分支中也同样被解决；\n\n而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。\n在热更新方面，`JSPatch` 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 `wax patch`。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 `JSPatch` 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于**简单语句**，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。\n由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 [ANTLR](https://www.antlr.org)，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。\n\n> 后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  \n\n##### 跨平台开发\n\n在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。\n\n> Code once, run everywhere.  \n\n可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。\n而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。\n然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。\n所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。\n\n## 2017-2018\n终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。\n在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  \n\n与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如**单项数据流**这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。\n\n这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。\n\n而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。\n\n- 在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；\n\t1. JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；\n\t2. JS 逻辑中，根据 `navigator.onLine`属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；\n\t3. Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；\n\n- 离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中\n\t1. 由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护\n\t2. H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：\n\t\t1. sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；\n\t\t2. localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；\n\t\t3. Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案\n\t\t4. Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术\n\t折中取舍，我们最终选择的 localStorage 作为文档操作的存储\t方式。\n\t3. 因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。\n\t4. 离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。\n\n- 作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：\n\t- 考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。\n\t- 虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 `alloc` 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。\n \n老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。\n\n现在，终于可以开始 Enjoy the new beginning! \n","slug":"复盘-2018","published":1,"updated":"2019-04-30T12:10:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4man50008kapc416v9sli","content":"<p>度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。<br>从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。</p>\n<h2 id=\"2015-2016\"><a href=\"#2015-2016\" class=\"headerlink\" title=\"2015-2016\"></a>2015-2016</h2><p>毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。</p>\n<h3 id=\"Clang-Static-Analyzer\"><a href=\"#Clang-Static-Analyzer\" class=\"headerlink\" title=\"Clang Static Analyzer\"></a>Clang Static Analyzer</h3><p>第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 <strong>clang</strong>，相应的，了解到 <strong>LLVM</strong>、<strong>AST</strong>，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。<br>记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。<br>假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。</p>\n<h3 id=\"Fauxpas\"><a href=\"#Fauxpas\" class=\"headerlink\" title=\"Fauxpas\"></a>Fauxpas</h3><p>那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 <a href=\"http://fauxpasapp.com/\" target=\"_blank\" rel=\"noopener\">Faux Pas for Xcode</a> ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。</p>\n<p>优点：</p>\n<ol>\n<li>代码检测规则实用；</li>\n<li>可自行配置实用的规则；</li>\n<li>检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>收费应用；</li>\n<li>无法自定义规则；</li>\n</ol>\n<h3 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h3><p>接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。</p>\n<h2 id=\"2016-2017\"><a href=\"#2016-2017\" class=\"headerlink\" title=\"2016-2017\"></a>2016-2017</h2><p>众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。<br>而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。</p>\n<h5 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h5><p>随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 <a href=\"https://github.com/bang590/JSPatch\" target=\"_blank\" rel=\"noopener\">JSPatch</a> 、 <a href=\"https://github.com/probablycorey/wax\" target=\"_blank\" rel=\"noopener\">wax</a> 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。<br>在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。</p>\n<p>因此热更新修复的流程，及其繁琐：</p>\n<ol>\n<li>开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；</li>\n<li>确认问题，使用原生代码修复该问题；</li>\n<li>改用热更新框架语言，重新实现修复逻辑；</li>\n<li>提单，测试进行介入，确认无误后准备上线现网；</li>\n<li>灰度上线；</li>\n<li>回到主干代码，merge 分支对应修复逻辑；</li>\n<li>测试再次介入，确认问题在主干分支中也同样被解决；</li>\n</ol>\n<p>而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。<br>在热更新方面，<code>JSPatch</code> 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 <code>wax patch</code>。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 <code>JSPatch</code> 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于<strong>简单语句</strong>，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。<br>由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 <a href=\"https://www.antlr.org\" target=\"_blank\" rel=\"noopener\">ANTLR</a>，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。</p>\n<blockquote>\n<p>后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  </p>\n</blockquote>\n<h5 id=\"跨平台开发\"><a href=\"#跨平台开发\" class=\"headerlink\" title=\"跨平台开发\"></a>跨平台开发</h5><p>在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。</p>\n<blockquote>\n<p>Code once, run everywhere.  </p>\n</blockquote>\n<p>可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。<br>而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。<br>然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。<br>所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。</p>\n<h2 id=\"2017-2018\"><a href=\"#2017-2018\" class=\"headerlink\" title=\"2017-2018\"></a>2017-2018</h2><p>终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。<br>在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：</p>\n<blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  </p>\n</blockquote>\n<p>与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如<strong>单项数据流</strong>这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。</p>\n<p>这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。</p>\n<p>而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。</p>\n<ul>\n<li><p>在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；</p>\n<ol>\n<li>JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；</li>\n<li>JS 逻辑中，根据 <code>navigator.onLine</code>属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；</li>\n<li>Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；</li>\n</ol>\n</li>\n<li><p>离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中</p>\n<ol>\n<li>由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护</li>\n<li>H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：<ol>\n<li>sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；</li>\n<li>localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；</li>\n<li>Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案</li>\n<li>Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术<br>折中取舍，我们最终选择的 localStorage 作为文档操作的存储    方式。</li>\n</ol>\n</li>\n<li>因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。</li>\n<li>离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。</li>\n</ol>\n</li>\n<li><p>作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：</p>\n<ul>\n<li>考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。</li>\n<li>虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 <code>alloc</code> 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。</li>\n</ul>\n</li>\n</ul>\n<p>老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。</p>\n<p>现在，终于可以开始 Enjoy the new beginning! </p>\n","site":{"data":{}},"excerpt":"度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。\n从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。\n\n2015-2016\n毕业刚刚进入公司，对","more":"<p>度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。<br>从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。</p>\n<h2 id=\"2015-2016\"><a href=\"#2015-2016\" class=\"headerlink\" title=\"2015-2016\"></a>2015-2016</h2><p>毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。</p>\n<h3 id=\"Clang-Static-Analyzer\"><a href=\"#Clang-Static-Analyzer\" class=\"headerlink\" title=\"Clang Static Analyzer\"></a>Clang Static Analyzer</h3><p>第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 <strong>clang</strong>，相应的，了解到 <strong>LLVM</strong>、<strong>AST</strong>，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。<br>记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。<br>假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。</p>\n<h3 id=\"Fauxpas\"><a href=\"#Fauxpas\" class=\"headerlink\" title=\"Fauxpas\"></a>Fauxpas</h3><p>那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 <a href=\"http://fauxpasapp.com/\" target=\"_blank\" rel=\"noopener\">Faux Pas for Xcode</a> ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。</p>\n<p>优点：</p>\n<ol>\n<li>代码检测规则实用；</li>\n<li>可自行配置实用的规则；</li>\n<li>检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>收费应用；</li>\n<li>无法自定义规则；</li>\n</ol>\n<h3 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h3><p>接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。</p>\n<h2 id=\"2016-2017\"><a href=\"#2016-2017\" class=\"headerlink\" title=\"2016-2017\"></a>2016-2017</h2><p>众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。<br>而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。</p>\n<h5 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h5><p>随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 <a href=\"https://github.com/bang590/JSPatch\" target=\"_blank\" rel=\"noopener\">JSPatch</a> 、 <a href=\"https://github.com/probablycorey/wax\" target=\"_blank\" rel=\"noopener\">wax</a> 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。<br>在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。</p>\n<p>因此热更新修复的流程，及其繁琐：</p>\n<ol>\n<li>开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；</li>\n<li>确认问题，使用原生代码修复该问题；</li>\n<li>改用热更新框架语言，重新实现修复逻辑；</li>\n<li>提单，测试进行介入，确认无误后准备上线现网；</li>\n<li>灰度上线；</li>\n<li>回到主干代码，merge 分支对应修复逻辑；</li>\n<li>测试再次介入，确认问题在主干分支中也同样被解决；</li>\n</ol>\n<p>而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。<br>在热更新方面，<code>JSPatch</code> 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 <code>wax patch</code>。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 <code>JSPatch</code> 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于<strong>简单语句</strong>，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。<br>由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 <a href=\"https://www.antlr.org\" target=\"_blank\" rel=\"noopener\">ANTLR</a>，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。</p>\n<blockquote>\n<p>后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  </p>\n</blockquote>\n<h5 id=\"跨平台开发\"><a href=\"#跨平台开发\" class=\"headerlink\" title=\"跨平台开发\"></a>跨平台开发</h5><p>在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。</p>\n<blockquote>\n<p>Code once, run everywhere.  </p>\n</blockquote>\n<p>可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。<br>而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。<br>然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。<br>所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。</p>\n<h2 id=\"2017-2018\"><a href=\"#2017-2018\" class=\"headerlink\" title=\"2017-2018\"></a>2017-2018</h2><p>终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。<br>在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：</p>\n<blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  </p>\n</blockquote>\n<p>与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如<strong>单项数据流</strong>这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。</p>\n<p>这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。</p>\n<p>而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。</p>\n<ul>\n<li><p>在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；</p>\n<ol>\n<li>JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；</li>\n<li>JS 逻辑中，根据 <code>navigator.onLine</code>属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；</li>\n<li>Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；</li>\n</ol>\n</li>\n<li><p>离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中</p>\n<ol>\n<li>由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护</li>\n<li>H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：<ol>\n<li>sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；</li>\n<li>localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；</li>\n<li>Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案</li>\n<li>Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术<br>折中取舍，我们最终选择的 localStorage 作为文档操作的存储    方式。</li>\n</ol>\n</li>\n<li>因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。</li>\n<li>离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。</li>\n</ol>\n</li>\n<li><p>作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：</p>\n<ul>\n<li>考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。</li>\n<li>虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 <code>alloc</code> 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。</li>\n</ul>\n</li>\n</ul>\n<p>老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。</p>\n<p>现在，终于可以开始 Enjoy the new beginning! </p>\n"},{"title":"Electron 进程间通讯详解","date":"2019-06-30T04:46:09.000Z","_content":"## Electron 应用架构\nElectron 不同于其他应用的架构，它存在两种进程类型，分别为**主进程**、**渲染进程**，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。\n\n![ElectronProcesses.png](https://cdn.iguan7u.cn/image/ElectronProcesses.png)\n\n### 主进程\nElectron 运行 `package.json` 中的 `main` 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。\n通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。\n主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。\n\n### 渲染进程\nElectron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 `BrowserWindow` 。当主进程每创建一个独立 `BrowserWindow` 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。\n\n## Electron 进程间通讯方式\n在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用**进程间通讯**方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：\n\n- **LocalStorage, window.postMessage**\n在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。\n\n- **IPC (Inner-Process Communication)**\nElectron 中提供了 `ipcRender` 、`ipcMain` 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 [IPC](https://www.chromium.org/developers/design-documents/inter-process-communication) ，能够提供更高的效率以及安全性。\n\n主进程代码：\n```javascript\nconst ipc = require('electron').ipcMain\nipc.on('getMsg', (event, msg) => {\n  console.log(msg)     // You sended a message to main thread.\n})\n```\n\n渲染进程代码：\n```javascript\nconst ipc = require('electron').ipcRenderer\nipc.send('getMsg', 'You sended a message to main thread.')\n```\n\n可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。\n\n- **Remote**\nRemote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 [RMI](https://en.wikipedia.org/wiki/Java_remote_method_invocation)，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。\n\n渲染进程调用主进程模块：\n```javascript\nconst { BrowserWindow } = require('electron').remote\nlet win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('https://github.com')\n```\n\n天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。\nRemote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。\n\n## 进程间通讯问题\n![WeDriveStruct.png](https://cdn.iguan7u.cn/image/WeDriveStruct.png)\n\n在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：\n\n### 1. 应用程序为何会出现卡顿？\n\n随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。\n我们在应用中增加了 `console.time` 以及 `console.timeEnd` 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：\n\n> 在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 `JSON.stringify` 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。  \n> 附上 [测试 demo 代码](https://github.com/iGuan7u/ElectronRemoteBlockDemo)  \n\n![ElectronBlock](https://cdn.iguan7u.cn/image/ElectronTest.gif)\n\n通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 `JSON.stringify` 方法打印完成后，页面的数字才正常的继续更新。\n由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。\n\n### 原因\n\n可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 [官方文档中](https://electronjs.org/docs/api/remote) 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：\n\n> remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送**同步**进程消息。  \n\n那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote [源码](https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js) 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 `remote.getGlobal` 方法为例：\n\nremote.js\n```javascript\n// Get a global object in browser.\nexports.getGlobal = (name) => {\n  const command = 'ELECTRON_BROWSER_GLOBAL'\n  const meta = ipcRendererInternal.sendSync(command, contextId, name)\n  return metaToValue(meta)\n}\n```\n\nrpc-server.js\n```javascript\nhandleRemoteCommand('ELECTRON_BROWSER_GLOBAL', function (event, contextId, globalName) {\n  const customEvent = eventBinding.createWithSender(event.sender)\n  event.sender.emit('remote-get-global', customEvent, globalName)\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getGlobal('${globalName}')`)\n    } else {\n      customEvent.returnValue = global[globalName]\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue)\n})\n```\n\nremote 使用一个内部的 ipc 通道 `ipcRendererInternal` 进行通讯，在调用 getGlobal 时，发送一个 `ELECTRON_BROWSER_GLOBAL` 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。\n在源码中我们发现，remote 模块是通过调用 `ipcRendererInternal` 中的 `sendSync` 方法，同步获取主进程中的对象。而其中的 `sendSync` 方法，我们可以从官方文档中查询到：\n\n> **注意:** 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  \n\n![RemoteCommunicate.png](https://cdn.iguan7u.cn/image/RemoteCommunicate.png)\n\n到这里，我们可以确定 `sendSync` 方法正是导致渲染进程卡顿的罪魁祸首。\n\n其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1/3 秒的时间。\n\n### 2. 应用程序为何会卡顿这么长时间？\n\n由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1/3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？\n\n我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。\n\n我们再细看官方文档中的 remote 模块介绍，其中提到：\n\n> Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  \n\n在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。\n\n### 原因\n\n我们细看一下 remote 中 `metaToValue `方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的**镜像对象**，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。\n\n```javascript\n// Convert meta data from browser into real value.\nfunction metaToValue (meta) {\n\t// diffent types of value should use different methods\n  const types = {\n    value: () => meta.value,\n    array: () => meta.members.map((member) => metaToValue(member)),\n    buffer: () => bufferUtils.metaToBuffer(meta.value),\n    promise: () => resolvePromise({ then: metaToValue(meta.then) }),\n    error: () => metaToPlainObject(meta),\n    date: () => new Date(meta.value),\n    exception: () => { throw errorUtils.deserialize(meta.value) }\n  }\n\n  if (meta.type in types) {\n    return types[meta.type]()\n  } else {\n    let ret\n    // get remote object from the cache\n    ...\n\n    // A shadow class to represent the remote function object.\n    if (meta.type === 'function') {\n      const remoteFunction = function (...args) {\n        let command\n        ...\n        const obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))\n        return metaToValue(obj)\n      }\n      ret = remoteFunction\n    } else {\n      ret = {}\n    }\n\n    setObjectMembers(ret, ret, meta.id, meta.members)\n    setObjectPrototype(ret, ret, meta.id, meta.proto)\n    Object.defineProperty(ret.constructor, 'name', { value: meta.name })\n\n    // Track delegate obj's lifetime & tell browser to clean up when object is GCed.\n    ...\n\n    // set remote object in cache\n    remoteObjectCache.set(meta.id, ret)\n    return ret\n  }\n}\n\n```\n\n![RemoteObject.png](https://cdn.iguan7u.cn/image/RemoteObject.png)\n\n我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 `ipcRendererInternal.sendSync` 同步通知主进程中，根据其中的隐藏字段 `atomId` 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 `event.returnValue` 返回数据。其内部实现与 remote 执行远程方法基本一致。\n\n所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 `sendSync` 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。\n\n### 3. 那我是否不使用 Remote 就好？\n\n上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。\n在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 `blockTheMainProcess` 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：\n```javascript\nfunction blockTheMainProcess() {\n  console.log('now start block the main process')\n  while(1) {\n    // block main process\n  }\n}\n```\n\n（由于录屏无法正常记录鼠标状态，请读者自行测试）\n\n我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。\n\n### 原因\n\n在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。\n\n![ElectronSendSync.png](https://cdn.iguan7u.cn/image/electron-sendSync.png)\n\n通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC `sendSync` 的方法，而这些方法每一个都可能导致渲染进程无法响应。\n\n## 解决方案\nElectron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。\n\n- **在频繁访问的方法建议使用 ipcRenderer/ipcMain 进行通讯**\n由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。\n\n- **不要在主进程中进行 CPU 密集型操作**\n主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。\n\n- **Remote 调用的主进程方法尽量设计为 aync 方法**\n上述提到，因为 remote 底层使用的是 `sendSync` 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。\n\n- **需要调用 remote 的主进程方法，不要返回大量数据**\n上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种**镜像**的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。\n在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 `then` 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。\n因此大量数据的获取我们推荐使用 ipcRenderer/ipcMain 进行获取。\n\n## 进一步的解决方案 —— “架空”主进程\n在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？\n在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。\n\n### worker_threads\n\n其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：\n\n> 在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  \n\n### cluster\n\ncluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。\n\n### child_process\n\n我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。\n\n\n## 总结\nElectron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。\n\n#blog\n","source":"_posts/Electron-进程间通讯详解.md","raw":"---\ntitle: Electron 进程间通讯详解\ndate: 2019-06-30 12:46:09\ntags:\n---\n## Electron 应用架构\nElectron 不同于其他应用的架构，它存在两种进程类型，分别为**主进程**、**渲染进程**，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。\n\n![ElectronProcesses.png](https://cdn.iguan7u.cn/image/ElectronProcesses.png)\n\n### 主进程\nElectron 运行 `package.json` 中的 `main` 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。\n通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。\n主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。\n\n### 渲染进程\nElectron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 `BrowserWindow` 。当主进程每创建一个独立 `BrowserWindow` 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。\n\n## Electron 进程间通讯方式\n在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用**进程间通讯**方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：\n\n- **LocalStorage, window.postMessage**\n在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。\n\n- **IPC (Inner-Process Communication)**\nElectron 中提供了 `ipcRender` 、`ipcMain` 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 [IPC](https://www.chromium.org/developers/design-documents/inter-process-communication) ，能够提供更高的效率以及安全性。\n\n主进程代码：\n```javascript\nconst ipc = require('electron').ipcMain\nipc.on('getMsg', (event, msg) => {\n  console.log(msg)     // You sended a message to main thread.\n})\n```\n\n渲染进程代码：\n```javascript\nconst ipc = require('electron').ipcRenderer\nipc.send('getMsg', 'You sended a message to main thread.')\n```\n\n可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。\n\n- **Remote**\nRemote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 [RMI](https://en.wikipedia.org/wiki/Java_remote_method_invocation)，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。\n\n渲染进程调用主进程模块：\n```javascript\nconst { BrowserWindow } = require('electron').remote\nlet win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('https://github.com')\n```\n\n天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。\nRemote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。\n\n## 进程间通讯问题\n![WeDriveStruct.png](https://cdn.iguan7u.cn/image/WeDriveStruct.png)\n\n在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：\n\n### 1. 应用程序为何会出现卡顿？\n\n随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。\n我们在应用中增加了 `console.time` 以及 `console.timeEnd` 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：\n\n> 在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 `JSON.stringify` 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。  \n> 附上 [测试 demo 代码](https://github.com/iGuan7u/ElectronRemoteBlockDemo)  \n\n![ElectronBlock](https://cdn.iguan7u.cn/image/ElectronTest.gif)\n\n通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 `JSON.stringify` 方法打印完成后，页面的数字才正常的继续更新。\n由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。\n\n### 原因\n\n可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 [官方文档中](https://electronjs.org/docs/api/remote) 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：\n\n> remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送**同步**进程消息。  \n\n那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote [源码](https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js) 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 `remote.getGlobal` 方法为例：\n\nremote.js\n```javascript\n// Get a global object in browser.\nexports.getGlobal = (name) => {\n  const command = 'ELECTRON_BROWSER_GLOBAL'\n  const meta = ipcRendererInternal.sendSync(command, contextId, name)\n  return metaToValue(meta)\n}\n```\n\nrpc-server.js\n```javascript\nhandleRemoteCommand('ELECTRON_BROWSER_GLOBAL', function (event, contextId, globalName) {\n  const customEvent = eventBinding.createWithSender(event.sender)\n  event.sender.emit('remote-get-global', customEvent, globalName)\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getGlobal('${globalName}')`)\n    } else {\n      customEvent.returnValue = global[globalName]\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue)\n})\n```\n\nremote 使用一个内部的 ipc 通道 `ipcRendererInternal` 进行通讯，在调用 getGlobal 时，发送一个 `ELECTRON_BROWSER_GLOBAL` 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。\n在源码中我们发现，remote 模块是通过调用 `ipcRendererInternal` 中的 `sendSync` 方法，同步获取主进程中的对象。而其中的 `sendSync` 方法，我们可以从官方文档中查询到：\n\n> **注意:** 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  \n\n![RemoteCommunicate.png](https://cdn.iguan7u.cn/image/RemoteCommunicate.png)\n\n到这里，我们可以确定 `sendSync` 方法正是导致渲染进程卡顿的罪魁祸首。\n\n其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1/3 秒的时间。\n\n### 2. 应用程序为何会卡顿这么长时间？\n\n由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1/3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？\n\n我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。\n\n我们再细看官方文档中的 remote 模块介绍，其中提到：\n\n> Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  \n\n在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。\n\n### 原因\n\n我们细看一下 remote 中 `metaToValue `方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的**镜像对象**，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。\n\n```javascript\n// Convert meta data from browser into real value.\nfunction metaToValue (meta) {\n\t// diffent types of value should use different methods\n  const types = {\n    value: () => meta.value,\n    array: () => meta.members.map((member) => metaToValue(member)),\n    buffer: () => bufferUtils.metaToBuffer(meta.value),\n    promise: () => resolvePromise({ then: metaToValue(meta.then) }),\n    error: () => metaToPlainObject(meta),\n    date: () => new Date(meta.value),\n    exception: () => { throw errorUtils.deserialize(meta.value) }\n  }\n\n  if (meta.type in types) {\n    return types[meta.type]()\n  } else {\n    let ret\n    // get remote object from the cache\n    ...\n\n    // A shadow class to represent the remote function object.\n    if (meta.type === 'function') {\n      const remoteFunction = function (...args) {\n        let command\n        ...\n        const obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))\n        return metaToValue(obj)\n      }\n      ret = remoteFunction\n    } else {\n      ret = {}\n    }\n\n    setObjectMembers(ret, ret, meta.id, meta.members)\n    setObjectPrototype(ret, ret, meta.id, meta.proto)\n    Object.defineProperty(ret.constructor, 'name', { value: meta.name })\n\n    // Track delegate obj's lifetime & tell browser to clean up when object is GCed.\n    ...\n\n    // set remote object in cache\n    remoteObjectCache.set(meta.id, ret)\n    return ret\n  }\n}\n\n```\n\n![RemoteObject.png](https://cdn.iguan7u.cn/image/RemoteObject.png)\n\n我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 `ipcRendererInternal.sendSync` 同步通知主进程中，根据其中的隐藏字段 `atomId` 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 `event.returnValue` 返回数据。其内部实现与 remote 执行远程方法基本一致。\n\n所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 `sendSync` 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。\n\n### 3. 那我是否不使用 Remote 就好？\n\n上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。\n在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 `blockTheMainProcess` 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：\n```javascript\nfunction blockTheMainProcess() {\n  console.log('now start block the main process')\n  while(1) {\n    // block main process\n  }\n}\n```\n\n（由于录屏无法正常记录鼠标状态，请读者自行测试）\n\n我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。\n\n### 原因\n\n在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。\n\n![ElectronSendSync.png](https://cdn.iguan7u.cn/image/electron-sendSync.png)\n\n通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC `sendSync` 的方法，而这些方法每一个都可能导致渲染进程无法响应。\n\n## 解决方案\nElectron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。\n\n- **在频繁访问的方法建议使用 ipcRenderer/ipcMain 进行通讯**\n由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。\n\n- **不要在主进程中进行 CPU 密集型操作**\n主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。\n\n- **Remote 调用的主进程方法尽量设计为 aync 方法**\n上述提到，因为 remote 底层使用的是 `sendSync` 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。\n\n- **需要调用 remote 的主进程方法，不要返回大量数据**\n上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种**镜像**的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。\n在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 `then` 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。\n因此大量数据的获取我们推荐使用 ipcRenderer/ipcMain 进行获取。\n\n## 进一步的解决方案 —— “架空”主进程\n在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？\n在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。\n\n### worker_threads\n\n其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：\n\n> 在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  \n\n### cluster\n\ncluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。\n\n### child_process\n\n我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。\n\n\n## 总结\nElectron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。\n\n#blog\n","slug":"Electron-进程间通讯详解","published":1,"updated":"2019-06-30T04:58:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7t4man6000akapcbtdufpc0","content":"<h2 id=\"Electron-应用架构\"><a href=\"#Electron-应用架构\" class=\"headerlink\" title=\"Electron 应用架构\"></a>Electron 应用架构</h2><p>Electron 不同于其他应用的架构，它存在两种进程类型，分别为<strong>主进程</strong>、<strong>渲染进程</strong>，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronProcesses.png\" alt=\"ElectronProcesses.png\"></p>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程\"></a>主进程</h3><p>Electron 运行 <code>package.json</code> 中的 <code>main</code> 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。<br>通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。<br>主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。</p>\n<h3 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h3><p>Electron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 <code>BrowserWindow</code> 。当主进程每创建一个独立 <code>BrowserWindow</code> 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。</p>\n<h2 id=\"Electron-进程间通讯方式\"><a href=\"#Electron-进程间通讯方式\" class=\"headerlink\" title=\"Electron 进程间通讯方式\"></a>Electron 进程间通讯方式</h2><p>在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用<strong>进程间通讯</strong>方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：</p>\n<ul>\n<li><p><strong>LocalStorage, window.postMessage</strong><br>在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。</p>\n</li>\n<li><p><strong>IPC (Inner-Process Communication)</strong><br>Electron 中提供了 <code>ipcRender</code> 、<code>ipcMain</code> 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 <a href=\"https://www.chromium.org/developers/design-documents/inter-process-communication\" target=\"_blank\" rel=\"noopener\">IPC</a> ，能够提供更高的效率以及安全性。</p>\n</li>\n</ul>\n<p>主进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ipc = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>).ipcMain</span><br><span class=\"line\">ipc.on(<span class=\"string\">'getMsg'</span>, (event, msg) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg)     <span class=\"comment\">// You sended a message to main thread.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>渲染进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ipc = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>).ipcRenderer</span><br><span class=\"line\">ipc.send(<span class=\"string\">'getMsg'</span>, <span class=\"string\">'You sended a message to main thread.'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。</p>\n<ul>\n<li><strong>Remote</strong><br>Remote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 <a href=\"https://en.wikipedia.org/wiki/Java_remote_method_invocation\" target=\"_blank\" rel=\"noopener\">RMI</a>，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。</li>\n</ul>\n<p>渲染进程调用主进程模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; BrowserWindow &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>).remote</span><br><span class=\"line\"><span class=\"keyword\">let</span> win = <span class=\"keyword\">new</span> BrowserWindow(&#123; <span class=\"attr\">width</span>: <span class=\"number\">800</span>, <span class=\"attr\">height</span>: <span class=\"number\">600</span> &#125;)</span><br><span class=\"line\">win.loadURL(<span class=\"string\">'https://github.com'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。<br>Remote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。</p>\n<h2 id=\"进程间通讯问题\"><a href=\"#进程间通讯问题\" class=\"headerlink\" title=\"进程间通讯问题\"></a>进程间通讯问题</h2><p><img src=\"https://cdn.iguan7u.cn/image/WeDriveStruct.png\" alt=\"WeDriveStruct.png\"></p>\n<p>在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：</p>\n<h3 id=\"1-应用程序为何会出现卡顿？\"><a href=\"#1-应用程序为何会出现卡顿？\" class=\"headerlink\" title=\"1. 应用程序为何会出现卡顿？\"></a>1. 应用程序为何会出现卡顿？</h3><p>随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。<br>我们在应用中增加了 <code>console.time</code> 以及 <code>console.timeEnd</code> 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：</p>\n<blockquote>\n<p>在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 <code>JSON.stringify</code> 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。<br>附上 <a href=\"https://github.com/iGuan7u/ElectronRemoteBlockDemo\" target=\"_blank\" rel=\"noopener\">测试 demo 代码</a>  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronTest.gif\" alt=\"ElectronBlock\"></p>\n<p>通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 <code>JSON.stringify</code> 方法打印完成后，页面的数字才正常的继续更新。<br>由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 <a href=\"https://electronjs.org/docs/api/remote\" target=\"_blank\" rel=\"noopener\">官方文档中</a> 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：</p>\n<blockquote>\n<p>remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送<strong>同步</strong>进程消息。  </p>\n</blockquote>\n<p>那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote <a href=\"https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js\" target=\"_blank\" rel=\"noopener\">源码</a> 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 <code>remote.getGlobal</code> 方法为例：</p>\n<p>remote.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get a global object in browser.</span></span><br><span class=\"line\">exports.getGlobal = <span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> command = <span class=\"string\">'ELECTRON_BROWSER_GLOBAL'</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> meta = ipcRendererInternal.sendSync(command, contextId, name)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> metaToValue(meta)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>rpc-server.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleRemoteCommand(<span class=\"string\">'ELECTRON_BROWSER_GLOBAL'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event, contextId, globalName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> customEvent = eventBinding.createWithSender(event.sender)</span><br><span class=\"line\">  event.sender.emit(<span class=\"string\">'remote-get-global'</span>, customEvent, globalName)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (customEvent.returnValue === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customEvent.defaultPrevented) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Blocked remote.getGlobal('<span class=\"subst\">$&#123;globalName&#125;</span>')`</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      customEvent.returnValue = global[globalName]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> valueToMeta(event.sender, contextId, customEvent.returnValue)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>remote 使用一个内部的 ipc 通道 <code>ipcRendererInternal</code> 进行通讯，在调用 getGlobal 时，发送一个 <code>ELECTRON_BROWSER_GLOBAL</code> 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。<br>在源码中我们发现，remote 模块是通过调用 <code>ipcRendererInternal</code> 中的 <code>sendSync</code> 方法，同步获取主进程中的对象。而其中的 <code>sendSync</code> 方法，我们可以从官方文档中查询到：</p>\n<blockquote>\n<p><strong>注意:</strong> 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteCommunicate.png\" alt=\"RemoteCommunicate.png\"></p>\n<p>到这里，我们可以确定 <code>sendSync</code> 方法正是导致渲染进程卡顿的罪魁祸首。</p>\n<p>其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1/3 秒的时间。</p>\n<h3 id=\"2-应用程序为何会卡顿这么长时间？\"><a href=\"#2-应用程序为何会卡顿这么长时间？\" class=\"headerlink\" title=\"2. 应用程序为何会卡顿这么长时间？\"></a>2. 应用程序为何会卡顿这么长时间？</h3><p>由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1/3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？</p>\n<p>我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。</p>\n<p>我们再细看官方文档中的 remote 模块介绍，其中提到：</p>\n<blockquote>\n<p>Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  </p>\n</blockquote>\n<p>在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。</p>\n<h3 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>我们细看一下 remote 中 <code>metaToValue</code>方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的<strong>镜像对象</strong>，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Convert meta data from browser into real value.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">metaToValue</span> (<span class=\"params\">meta</span>) </span>&#123;</span><br><span class=\"line\">2<span class=\"comment\">// diffent types of value should use different methods</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> types = &#123;</span><br><span class=\"line\">    value: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> meta.value,</span><br><span class=\"line\">    array: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> meta.members.map(<span class=\"function\">(<span class=\"params\">member</span>) =&gt;</span> metaToValue(member)),</span><br><span class=\"line\">    buffer: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> bufferUtils.metaToBuffer(meta.value),</span><br><span class=\"line\">    promise: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolvePromise(&#123; <span class=\"attr\">then</span>: metaToValue(meta.then) &#125;),</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> metaToPlainObject(meta),</span><br><span class=\"line\">    date: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(meta.value),</span><br><span class=\"line\">    exception: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">throw</span> errorUtils.deserialize(meta.value) &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (meta.type <span class=\"keyword\">in</span> types) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> types[meta.type]()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ret</span><br><span class=\"line\">    <span class=\"comment\">// get remote object from the cache</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A shadow class to represent the remote function object.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (meta.type === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> remoteFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> command</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">const</span> obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> metaToValue(obj)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ret = remoteFunction</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ret = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setObjectMembers(ret, ret, meta.id, meta.members)</span><br><span class=\"line\">    setObjectPrototype(ret, ret, meta.id, meta.proto)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(ret.constructor, <span class=\"string\">'name'</span>, &#123; <span class=\"attr\">value</span>: meta.name &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Track delegate obj's lifetime &amp; tell browser to clean up when object is GCed.</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set remote object in cache</span></span><br><span class=\"line\">    remoteObjectCache.set(meta.id, ret)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteObject.png\" alt=\"RemoteObject.png\"></p>\n<p>我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 <code>ipcRendererInternal.sendSync</code> 同步通知主进程中，根据其中的隐藏字段 <code>atomId</code> 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 <code>event.returnValue</code> 返回数据。其内部实现与 remote 执行远程方法基本一致。</p>\n<p>所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 <code>sendSync</code> 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。</p>\n<h3 id=\"3-那我是否不使用-Remote-就好？\"><a href=\"#3-那我是否不使用-Remote-就好？\" class=\"headerlink\" title=\"3. 那我是否不使用 Remote 就好？\"></a>3. 那我是否不使用 Remote 就好？</h3><p>上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。<br>在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 <code>blockTheMainProcess</code> 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">blockTheMainProcess</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'now start block the main process'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// block main process</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（由于录屏无法正常记录鼠标状态，请读者自行测试）</p>\n<p>我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。</p>\n<h3 id=\"原因-2\"><a href=\"#原因-2\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/electron-sendSync.png\" alt=\"ElectronSendSync.png\"></p>\n<p>通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC <code>sendSync</code> 的方法，而这些方法每一个都可能导致渲染进程无法响应。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Electron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。</p>\n<ul>\n<li><p><strong>在频繁访问的方法建议使用 ipcRenderer/ipcMain 进行通讯</strong><br>由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。</p>\n</li>\n<li><p><strong>不要在主进程中进行 CPU 密集型操作</strong><br>主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。</p>\n</li>\n<li><p><strong>Remote 调用的主进程方法尽量设计为 aync 方法</strong><br>上述提到，因为 remote 底层使用的是 <code>sendSync</code> 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。</p>\n</li>\n<li><p><strong>需要调用 remote 的主进程方法，不要返回大量数据</strong><br>上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种<strong>镜像</strong>的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。<br>在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 <code>then</code> 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。<br>因此大量数据的获取我们推荐使用 ipcRenderer/ipcMain 进行获取。</p>\n</li>\n</ul>\n<h2 id=\"进一步的解决方案-——-“架空”主进程\"><a href=\"#进一步的解决方案-——-“架空”主进程\" class=\"headerlink\" title=\"进一步的解决方案 —— “架空”主进程\"></a>进一步的解决方案 —— “架空”主进程</h2><p>在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？<br>在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。</p>\n<h3 id=\"worker-threads\"><a href=\"#worker-threads\" class=\"headerlink\" title=\"worker_threads\"></a>worker_threads</h3><p>其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：</p>\n<blockquote>\n<p>在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  </p>\n</blockquote>\n<h3 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h3><p>cluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。</p>\n<h3 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h3><p>我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Electron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。</p>\n<p>#blog</p>\n","site":{"data":{}},"excerpt":"Electron 应用架构\nElectron 不同于其他应用的架构，它存在两种进程类型，分别为主进程、渲染进程，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。\n\n\n\n主进程\nElectron 运行 package.json 中的 main 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控","more":"<h2 id=\"Electron-应用架构\"><a href=\"#Electron-应用架构\" class=\"headerlink\" title=\"Electron 应用架构\"></a>Electron 应用架构</h2><p>Electron 不同于其他应用的架构，它存在两种进程类型，分别为<strong>主进程</strong>、<strong>渲染进程</strong>，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronProcesses.png\" alt=\"ElectronProcesses.png\"></p>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程\"></a>主进程</h3><p>Electron 运行 <code>package.json</code> 中的 <code>main</code> 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。<br>通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。<br>主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。</p>\n<h3 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h3><p>Electron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 <code>BrowserWindow</code> 。当主进程每创建一个独立 <code>BrowserWindow</code> 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。</p>\n<h2 id=\"Electron-进程间通讯方式\"><a href=\"#Electron-进程间通讯方式\" class=\"headerlink\" title=\"Electron 进程间通讯方式\"></a>Electron 进程间通讯方式</h2><p>在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用<strong>进程间通讯</strong>方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：</p>\n<ul>\n<li><p><strong>LocalStorage, window.postMessage</strong><br>在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。</p>\n</li>\n<li><p><strong>IPC (Inner-Process Communication)</strong><br>Electron 中提供了 <code>ipcRender</code> 、<code>ipcMain</code> 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 <a href=\"https://www.chromium.org/developers/design-documents/inter-process-communication\" target=\"_blank\" rel=\"noopener\">IPC</a> ，能够提供更高的效率以及安全性。</p>\n</li>\n</ul>\n<p>主进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ipc = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>).ipcMain</span><br><span class=\"line\">ipc.on(<span class=\"string\">'getMsg'</span>, (event, msg) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(msg)     <span class=\"comment\">// You sended a message to main thread.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>渲染进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ipc = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>).ipcRenderer</span><br><span class=\"line\">ipc.send(<span class=\"string\">'getMsg'</span>, <span class=\"string\">'You sended a message to main thread.'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。</p>\n<ul>\n<li><strong>Remote</strong><br>Remote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 <a href=\"https://en.wikipedia.org/wiki/Java_remote_method_invocation\" target=\"_blank\" rel=\"noopener\">RMI</a>，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。</li>\n</ul>\n<p>渲染进程调用主进程模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; BrowserWindow &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'electron'</span>).remote</span><br><span class=\"line\"><span class=\"keyword\">let</span> win = <span class=\"keyword\">new</span> BrowserWindow(&#123; <span class=\"attr\">width</span>: <span class=\"number\">800</span>, <span class=\"attr\">height</span>: <span class=\"number\">600</span> &#125;)</span><br><span class=\"line\">win.loadURL(<span class=\"string\">'https://github.com'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。<br>Remote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。</p>\n<h2 id=\"进程间通讯问题\"><a href=\"#进程间通讯问题\" class=\"headerlink\" title=\"进程间通讯问题\"></a>进程间通讯问题</h2><p><img src=\"https://cdn.iguan7u.cn/image/WeDriveStruct.png\" alt=\"WeDriveStruct.png\"></p>\n<p>在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：</p>\n<h3 id=\"1-应用程序为何会出现卡顿？\"><a href=\"#1-应用程序为何会出现卡顿？\" class=\"headerlink\" title=\"1. 应用程序为何会出现卡顿？\"></a>1. 应用程序为何会出现卡顿？</h3><p>随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。<br>我们在应用中增加了 <code>console.time</code> 以及 <code>console.timeEnd</code> 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：</p>\n<blockquote>\n<p>在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 <code>JSON.stringify</code> 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。<br>附上 <a href=\"https://github.com/iGuan7u/ElectronRemoteBlockDemo\" target=\"_blank\" rel=\"noopener\">测试 demo 代码</a>  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronTest.gif\" alt=\"ElectronBlock\"></p>\n<p>通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 <code>JSON.stringify</code> 方法打印完成后，页面的数字才正常的继续更新。<br>由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 <a href=\"https://electronjs.org/docs/api/remote\" target=\"_blank\" rel=\"noopener\">官方文档中</a> 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：</p>\n<blockquote>\n<p>remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送<strong>同步</strong>进程消息。  </p>\n</blockquote>\n<p>那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote <a href=\"https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js\" target=\"_blank\" rel=\"noopener\">源码</a> 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 <code>remote.getGlobal</code> 方法为例：</p>\n<p>remote.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get a global object in browser.</span></span><br><span class=\"line\">exports.getGlobal = <span class=\"function\">(<span class=\"params\">name</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> command = <span class=\"string\">'ELECTRON_BROWSER_GLOBAL'</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> meta = ipcRendererInternal.sendSync(command, contextId, name)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> metaToValue(meta)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>rpc-server.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleRemoteCommand(<span class=\"string\">'ELECTRON_BROWSER_GLOBAL'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event, contextId, globalName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> customEvent = eventBinding.createWithSender(event.sender)</span><br><span class=\"line\">  event.sender.emit(<span class=\"string\">'remote-get-global'</span>, customEvent, globalName)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (customEvent.returnValue === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (customEvent.defaultPrevented) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Blocked remote.getGlobal('<span class=\"subst\">$&#123;globalName&#125;</span>')`</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      customEvent.returnValue = global[globalName]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> valueToMeta(event.sender, contextId, customEvent.returnValue)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>remote 使用一个内部的 ipc 通道 <code>ipcRendererInternal</code> 进行通讯，在调用 getGlobal 时，发送一个 <code>ELECTRON_BROWSER_GLOBAL</code> 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。<br>在源码中我们发现，remote 模块是通过调用 <code>ipcRendererInternal</code> 中的 <code>sendSync</code> 方法，同步获取主进程中的对象。而其中的 <code>sendSync</code> 方法，我们可以从官方文档中查询到：</p>\n<blockquote>\n<p><strong>注意:</strong> 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteCommunicate.png\" alt=\"RemoteCommunicate.png\"></p>\n<p>到这里，我们可以确定 <code>sendSync</code> 方法正是导致渲染进程卡顿的罪魁祸首。</p>\n<p>其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1/3 秒的时间。</p>\n<h3 id=\"2-应用程序为何会卡顿这么长时间？\"><a href=\"#2-应用程序为何会卡顿这么长时间？\" class=\"headerlink\" title=\"2. 应用程序为何会卡顿这么长时间？\"></a>2. 应用程序为何会卡顿这么长时间？</h3><p>由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1/3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？</p>\n<p>我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。</p>\n<p>我们再细看官方文档中的 remote 模块介绍，其中提到：</p>\n<blockquote>\n<p>Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  </p>\n</blockquote>\n<p>在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。</p>\n<h3 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>我们细看一下 remote 中 <code>metaToValue</code>方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的<strong>镜像对象</strong>，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Convert meta data from browser into real value.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">metaToValue</span> (<span class=\"params\">meta</span>) </span>&#123;</span><br><span class=\"line\">2<span class=\"comment\">// diffent types of value should use different methods</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> types = &#123;</span><br><span class=\"line\">    value: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> meta.value,</span><br><span class=\"line\">    array: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> meta.members.map(<span class=\"function\">(<span class=\"params\">member</span>) =&gt;</span> metaToValue(member)),</span><br><span class=\"line\">    buffer: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> bufferUtils.metaToBuffer(meta.value),</span><br><span class=\"line\">    promise: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolvePromise(&#123; <span class=\"attr\">then</span>: metaToValue(meta.then) &#125;),</span><br><span class=\"line\">    error: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> metaToPlainObject(meta),</span><br><span class=\"line\">    date: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(meta.value),</span><br><span class=\"line\">    exception: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">throw</span> errorUtils.deserialize(meta.value) &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (meta.type <span class=\"keyword\">in</span> types) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> types[meta.type]()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ret</span><br><span class=\"line\">    <span class=\"comment\">// get remote object from the cache</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// A shadow class to represent the remote function object.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (meta.type === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> remoteFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> command</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">const</span> obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> metaToValue(obj)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ret = remoteFunction</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ret = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setObjectMembers(ret, ret, meta.id, meta.members)</span><br><span class=\"line\">    setObjectPrototype(ret, ret, meta.id, meta.proto)</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(ret.constructor, <span class=\"string\">'name'</span>, &#123; <span class=\"attr\">value</span>: meta.name &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Track delegate obj's lifetime &amp; tell browser to clean up when object is GCed.</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set remote object in cache</span></span><br><span class=\"line\">    remoteObjectCache.set(meta.id, ret)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteObject.png\" alt=\"RemoteObject.png\"></p>\n<p>我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 <code>ipcRendererInternal.sendSync</code> 同步通知主进程中，根据其中的隐藏字段 <code>atomId</code> 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 <code>event.returnValue</code> 返回数据。其内部实现与 remote 执行远程方法基本一致。</p>\n<p>所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 <code>sendSync</code> 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。</p>\n<h3 id=\"3-那我是否不使用-Remote-就好？\"><a href=\"#3-那我是否不使用-Remote-就好？\" class=\"headerlink\" title=\"3. 那我是否不使用 Remote 就好？\"></a>3. 那我是否不使用 Remote 就好？</h3><p>上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。<br>在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 <code>blockTheMainProcess</code> 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">blockTheMainProcess</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'now start block the main process'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// block main process</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（由于录屏无法正常记录鼠标状态，请读者自行测试）</p>\n<p>我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。</p>\n<h3 id=\"原因-2\"><a href=\"#原因-2\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/electron-sendSync.png\" alt=\"ElectronSendSync.png\"></p>\n<p>通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC <code>sendSync</code> 的方法，而这些方法每一个都可能导致渲染进程无法响应。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Electron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。</p>\n<ul>\n<li><p><strong>在频繁访问的方法建议使用 ipcRenderer/ipcMain 进行通讯</strong><br>由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。</p>\n</li>\n<li><p><strong>不要在主进程中进行 CPU 密集型操作</strong><br>主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。</p>\n</li>\n<li><p><strong>Remote 调用的主进程方法尽量设计为 aync 方法</strong><br>上述提到，因为 remote 底层使用的是 <code>sendSync</code> 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。</p>\n</li>\n<li><p><strong>需要调用 remote 的主进程方法，不要返回大量数据</strong><br>上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种<strong>镜像</strong>的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。<br>在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 <code>then</code> 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。<br>因此大量数据的获取我们推荐使用 ipcRenderer/ipcMain 进行获取。</p>\n</li>\n</ul>\n<h2 id=\"进一步的解决方案-——-“架空”主进程\"><a href=\"#进一步的解决方案-——-“架空”主进程\" class=\"headerlink\" title=\"进一步的解决方案 —— “架空”主进程\"></a>进一步的解决方案 —— “架空”主进程</h2><p>在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？<br>在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。</p>\n<h3 id=\"worker-threads\"><a href=\"#worker-threads\" class=\"headerlink\" title=\"worker_threads\"></a>worker_threads</h3><p>其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：</p>\n<blockquote>\n<p>在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  </p>\n</blockquote>\n<h3 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h3><p>cluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。</p>\n<h3 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h3><p>我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Electron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。</p>\n<p>#blog</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck7t4malh0002kapc3lphdqah","tag_id":"ck7t4malm0007kapcbz8t732c","_id":"ck7t4man60009kapcgv184w7d"}],"Tag":[{"name":"Electron","_id":"ck7t4malm0007kapcbz8t732c"}]}}