{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/Acetolog/source/assets/JosefinSans-SemiBoldItalic.ttf","path":"assets/JosefinSans-SemiBoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/Acetolog/source/assets/JosefinSans-Regular.ttf","path":"assets/JosefinSans-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/Acetolog/source/assets/svg_icons.svg","path":"assets/svg_icons.svg","modified":0,"renderable":1},{"_id":"themes/Acetolog/source/css/dracula.css","path":"css/dracula.css","modified":0,"renderable":1},{"_id":"themes/Acetolog/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Acetolog/source/javascripts/acelog.js","path":"javascripts/acelog.js","modified":0,"renderable":1},{"_id":"themes/Acetolog/source/javascripts/highlight.pack.js","path":"javascripts/highlight.pack.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Acetolog-创作之路.md","hash":"e89ea8897fc61c00740fc363d9d76fe6befb61e6","modified":1645622060094},{"_id":"source/CNAME","hash":"3bbf17ddb663f64c1f46bd09925424e288211a99","modified":1645622060093},{"_id":"source/_posts/Chrome-Inspect-iOS-UI-WK-WebView.md","hash":"3fedfa9c9d15c11bffd0a986cf78d4b7f5f33ae8","modified":1645622060094},{"_id":"source/_posts/Electron-进程间通讯详解.md","hash":"920ad19d42c340c49dee2d931d6cae26ed52478f","modified":1645622060094},{"_id":"source/_posts/Electron-asar-格式详解.md","hash":"b199d2d056b47f6b2e49edc5ca2308386a5e2db3","modified":1645622060094},{"_id":"source/_posts/WKWebView-设置-Cookie-的正确方式.md","hash":"57c4c7cece4e39b6f1036c4c7ffd0ef021d3ff52","modified":1645622060094},{"_id":"source/_posts/Debug-electron-main-process-on-VSCode.md","hash":"c21f9d5b1572793d8f30a191cb98b73846cf5c77","modified":1645622060094},{"_id":"source/_posts/大端与小端.md","hash":"0bc9e8b5b3c504a6b05879e6b5fe0defcb08cd91","modified":1645622060095},{"_id":"source/_posts/关于-Xcode-的资源占用.md","hash":"464d3d6e81edb9220489da9a0a65f7f64c008c96","modified":1645622060095},{"_id":"source/_posts/hello-world.md","hash":"0849589a84decd745230559907079aad2a874429","modified":1645622060094},{"_id":"source/_posts/复盘-2018.md","hash":"b2b06c34522089a57ab162d1fb466ad86da57769","modified":1645622060095},{"_id":"source/_posts/深入了解-Service-Worker.md","hash":"fecec92bd9d8c0efec42f97791c07819d86d0af8","modified":1645622060095},{"_id":"source/_posts/终于入手了人生第一台黑苹果.md","hash":"5afd1c7c11f9748d31cf312d8b59278e30bd258e","modified":1645622060095},{"_id":"source/_posts/密钥文件的用户权限.md","hash":"e06dac786a22253d6e8b862e8f101eab7560f4e2","modified":1645885938692},{"_id":"source/_posts/谈谈敏捷开发.md","hash":"45245d5e2c4ef7ee362431e48815f36a0a39a1b8","modified":1645622060095},{"_id":"themes/Acetolog/.gitignore","hash":"41acbb667c228d6b171286fef91534b436e39b5b","modified":1645669978806},{"_id":"themes/Acetolog/_config.yml","hash":"9bdbbede4f3ac4c4dd9dbddf2d5d915d9b9203cc","modified":1647677763265},{"_id":"themes/Acetolog/package.json","hash":"aee0934ec65ca961b066a1af33118599ba288f66","modified":1645669978808},{"_id":"themes/Acetolog/.github/FUNDING.yml","hash":"23bc50e5d30680b7aef2a9a985f224a575d71fbc","modified":1645669978806},{"_id":"themes/Acetolog/LICENSE","hash":"a6c627c1c73474db7ae5f62ffd138d60e3579a7f","modified":1645669978806},{"_id":"themes/Acetolog/layout/post.njk","hash":"a45d210f6c2fcae443a28c551ab9af1db034f9ea","modified":1645790443636},{"_id":"themes/Acetolog/README.md","hash":"dbe13f94a444d696688c3bd3666e3a28e914ac2b","modified":1645790443630},{"_id":"themes/Acetolog/webpack.config.js","hash":"02d263b1078dd6d3a83ee88e48bd74d05e592368","modified":1645669978814},{"_id":"themes/Acetolog/layout/404.njk","hash":"26a75b95686897b3669c5dae743894fc03405bf2","modified":1656414400893},{"_id":"themes/Acetolog/layout/index.njk","hash":"d48cf36d103f572de9379fe970aee1926cd6daed","modified":1645790443636},{"_id":"themes/Acetolog/src/index.ts","hash":"79c2437779458e751b1a91e65314f9a1db0a215e","modified":1645669978814},{"_id":"themes/Acetolog/src/tsconfig.json","hash":"abf0a348f1d9390e895d70586dcbb80a1f931c32","modified":1645669978814},{"_id":"themes/Acetolog/source/assets/svg_icons.svg","hash":"988cda366837940196ff88333186d9707feee8ac","modified":1645669978811},{"_id":"themes/Acetolog/source/css/style.styl","hash":"78c5d9cb9594e46a3c88d1f2ed40cec43c64c021","modified":1645669978812},{"_id":"themes/Acetolog/source/css/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1645669978812},{"_id":"themes/Acetolog/source/javascripts/acelog.js","hash":"230cb0545de6fb7c0935eb278b20bf2ca2971d37","modified":1645669978812},{"_id":"themes/Acetolog/source/stylus/_container.styl","hash":"3487a88879b1d64d1dbf6d758ec9eff82c6c3c15","modified":1645669978813},{"_id":"themes/Acetolog/source/stylus/_darkTheme.styl","hash":"ab2d267789a7de50db99bc99639ec578a9d49031","modified":1647677770897},{"_id":"themes/Acetolog/source/stylus/_background.styl","hash":"d0612a23bf8827fa52028000178f0ce3665b7b37","modified":1645669978812},{"_id":"themes/Acetolog/source/stylus/_global.styl","hash":"54a68d98bc03a659695b6b083e75d935c9db94fb","modified":1645669978813},{"_id":"themes/Acetolog/source/stylus/_header.styl","hash":"b98273b7989ce05208071fc691b5f2e609379af8","modified":1645669978813},{"_id":"themes/Acetolog/source/stylus/_font.styl","hash":"cb1172042bc395e0bacc0542033c1678bbb22a3f","modified":1645669978813},{"_id":"themes/Acetolog/source/stylus/_lightbox.styl","hash":"c826434c6dfa55c0fac24064e255693c6d729651","modified":1645669978813},{"_id":"themes/Acetolog/source/javascripts/highlight.pack.js","hash":"aaac7fbc3ae1b46bf01b4bae2a8b1829ea370405","modified":1645669978812},{"_id":"themes/Acetolog/source/stylus/_pageContent.styl","hash":"3a7249f415ec40b4dd58e52ad082fe8c3d120d02","modified":1645669978813},{"_id":"themes/Acetolog/source/stylus/_pageOutline.styl","hash":"10d566aa2d3f38aedb95603ada0bade6ed591ee0","modified":1645669978813},{"_id":"themes/Acetolog/source/stylus/_postList.styl","hash":"bbc3acfde57b6be5c637faecfa28a8152d40b03a","modified":1645669978814},{"_id":"themes/Acetolog/source/stylus/_page.styl","hash":"e5a42ad0103ca8e2c7c05b3a17cf5cf7ae640366","modified":1645669978813},{"_id":"themes/Acetolog/source/stylus/_var.styl","hash":"06eef6bc52ace2129968dea47fc19bac164aec3b","modified":1645669978814},{"_id":"themes/Acetolog/source/stylus/_sidebar.styl","hash":"721476e0a910eba74a4ea17a011df12eec402fed","modified":1645669978814},{"_id":"themes/Acetolog/layout/includes/base.njk","hash":"a7b11bdc35c9447556de772c787ba8c8b8953586","modified":1647677770897},{"_id":"themes/Acetolog/layout/includes/footer.njk","hash":"4af4d9f507f314a849ae5c8ffa52feb3ac579af5","modified":1645790443638},{"_id":"themes/Acetolog/layout/includes/head.njk","hash":"12824efdd9e015ede7fa7216667e35a11e4ae5c3","modified":1645790443637},{"_id":"themes/Acetolog/layout/includes/headerbar.njk","hash":"686f677de6611f933a63f5a17c17965256a798cf","modified":1645790443637},{"_id":"themes/Acetolog/layout/includes/sidebar.njk","hash":"7ebd2ab086f8306380d45c28994a60a2b96ad46c","modified":1645790443636},{"_id":"themes/Acetolog/layout/includes/plugins/disqus.njk","hash":"cf2be4c5d3dff82f24691caae50bf17e44bc6a27","modified":1645790443637},{"_id":"themes/Acetolog/layout/includes/plugins/baiduAnalytice.njk","hash":"feece927533d615b4452b1cc674131f94b34b596","modified":1645790443637},{"_id":"themes/Acetolog/src/util/jquery_polyfill.ts","hash":"d1fa983c135ae1c7c660a591f53ad02c85d00797","modified":1645669978814},{"_id":"themes/Acetolog/layout/includes/plugins/gitalk.njk","hash":"7767466b415cdfefe63aa6b5015d6e1a9a1c8caf","modified":1645790443637},{"_id":"themes/Acetolog/layout/includes/plugins/plugin.njk","hash":"676363ec2401702b26e33d2fded746cd8355bbdb","modified":1645790443636},{"_id":"themes/Acetolog/layout/includes/plugins/googleAnalytice.njk","hash":"68cd627a6160ea63078f7dad7928f857a04d9481","modified":1645790443637},{"_id":"themes/Acetolog/layout/includes/plugins/umamiAnalytice.njk","hash":"6f3cbadd6a5563e9f572114ed5cf9ce415036a92","modified":1645790443636},{"_id":"themes/Acetolog/layout/includes/plugins/mtaTencentAnalytice.njk","hash":"f1bcdf00494fdb4f446d7628798e7760a7740358","modified":1645790443636},{"_id":"themes/Acetolog/source/assets/JosefinSans-Regular.ttf","hash":"7bc8324d2ff6a6fc28794c8ba607e30f47a2161a","modified":1645669978810},{"_id":"themes/Acetolog/source/assets/JosefinSans-SemiBoldItalic.ttf","hash":"b8ec4d6c33033901489df706156609e528ed3d0f","modified":1645669978811},{"_id":"themes/Acetolog/screenshot/1.png","hash":"27f8db9ead88cd090e7392a12ca033e9f8c8c806","modified":1645669978809},{"_id":"public/2021/10/10/WKWebView-设置-Cookie-的正确方式/index.html","hash":"018f38fdba80b61a2b2f4a7b8b109cee46e88a62","modified":1656414491423},{"_id":"public/2022/01/25/密钥文件的用户权限/index.html","hash":"4922e507a24c0f11aa3f6aa35282da4aa7be4d0e","modified":1656414491423},{"_id":"public/2021/03/30/关于-Xcode-的资源占用/index.html","hash":"933c7869aa35c6dd87318d792071402ed4bf337a","modified":1656414491423},{"_id":"public/2020/11/08/谈谈敏捷开发/index.html","hash":"21569c7d9160ca2f50f4b5b39c00e000f730759c","modified":1656414491423},{"_id":"public/2020/02/21/Acetolog-创作之路/index.html","hash":"3d6944fa985a7ffc711c4c60663874ebf694f14d","modified":1656414491423},{"_id":"public/2020/01/03/Chrome-Inspect-iOS-UI-WK-WebView/index.html","hash":"ef93db6655c6c6af66e82f5a56f255e256de7604","modified":1656414491423},{"_id":"public/2019/03/19/Electron-asar-格式详解/index.html","hash":"a592d3f712d100af31ddc24f266b5eae85314c24","modified":1656414491423},{"_id":"public/2019/01/15/Debug-electron-main-process-on-VSCode/index.html","hash":"0f4030f4b8fbe0d7f670084758b6f1bdfbd92f9a","modified":1656414491423},{"_id":"public/2019/01/01/大端与小端/index.html","hash":"54b9bb932ba08c866ae9f5a60d4166385e214088","modified":1656414491423},{"_id":"public/1970/01/01/hello-world/index.html","hash":"747b4f67d4787a3aacdcd686fe10876fc35f486b","modified":1656414491423},{"_id":"public/archives/page/2/index.html","hash":"c223713d881781c961c19046c9ecceaef2a294c5","modified":1656414491423},{"_id":"public/archives/1970/index.html","hash":"ec64e04d9f54b48acf5df43b18cf22bf2eed9641","modified":1656414491423},{"_id":"public/archives/1970/01/index.html","hash":"ec64e04d9f54b48acf5df43b18cf22bf2eed9641","modified":1656414491423},{"_id":"public/archives/2019/01/index.html","hash":"161b9c5a16530205a351ec876b56d10e5e312d7f","modified":1656414491423},{"_id":"public/archives/2019/03/index.html","hash":"39b6e766ef1b1d82126c753e26ecbaf4a6c6d01a","modified":1656414491423},{"_id":"public/archives/2019/06/index.html","hash":"018d0e5b4ee1f282b1ec3ad6d677a5d61cc614a6","modified":1656414491423},{"_id":"public/archives/2019/08/index.html","hash":"d860a7ef2d72a45d86204134f9e5b249b0806930","modified":1656414491423},{"_id":"public/archives/2020/index.html","hash":"df83dcecca4bbbcf2e0a3f1981532925e5eb0239","modified":1656414491423},{"_id":"public/archives/2020/01/index.html","hash":"cef3eb69a167df5c061b1bebcf5f017062346be5","modified":1656414491423},{"_id":"public/archives/2020/02/index.html","hash":"cd7597b4f0c6a59225c24bc5abc5b2b0f88f9df9","modified":1656414491423},{"_id":"public/archives/2020/03/index.html","hash":"7409adf0e746ee7ab15db53704740f7ffd0cd7bf","modified":1656414491423},{"_id":"public/archives/2020/11/index.html","hash":"782810098df6b718d0afa5b4fc1be73702efeda5","modified":1656414491423},{"_id":"public/archives/2021/index.html","hash":"c07a56cd2d84a459e4ca5f035644336da406ad2c","modified":1656414491423},{"_id":"public/archives/2021/03/index.html","hash":"e24b75a946bd0b00af787e560117f0bc789e1da8","modified":1656414491423},{"_id":"public/archives/2021/10/index.html","hash":"8cae2f70557493762871b768bd5b8dd3d5fa0f47","modified":1656414491423},{"_id":"public/archives/2022/index.html","hash":"ea8d2bbd51f5d176ce4da64b468156bcd182d0d1","modified":1656414491423},{"_id":"public/archives/2022/01/index.html","hash":"ea8d2bbd51f5d176ce4da64b468156bcd182d0d1","modified":1656414491423},{"_id":"public/page/2/index.html","hash":"a16a2555dfd6d6ef0a5cd164348142908440ce18","modified":1656414491423},{"_id":"public/tags/Electron/index.html","hash":"ba630d189ccc2def5a6ba94499da5a8695647049","modified":1656414491423},{"_id":"public/2020/03/15/深入了解-Service-Worker/index.html","hash":"69a68349848c404d7e3d6c8a8187261f99b1effe","modified":1656414491423},{"_id":"public/2019/08/28/终于入手了人生第一台黑苹果/index.html","hash":"4d80f8731e908a237722415168b4d070bbc73950","modified":1656414491423},{"_id":"public/2019/06/30/Electron-进程间通讯详解/index.html","hash":"17cef14ae36f81eb8524b2819435df8780134e07","modified":1656414491423},{"_id":"public/2019/03/17/复盘-2018/index.html","hash":"bc6db25d84b8e7781d53f01280e92d67bb12414e","modified":1656414491423},{"_id":"public/archives/index.html","hash":"8501112f8b348501e50ecce5187e42663cfed89b","modified":1656414491423},{"_id":"public/archives/2019/index.html","hash":"932d22d662e23e372ec3b035eb8aab32a681161a","modified":1656414491423},{"_id":"public/index.html","hash":"543a7590b0571ff4a1ea86d565c5651c5b33bf5c","modified":1656414491423},{"_id":"public/CNAME","hash":"3bbf17ddb663f64c1f46bd09925424e288211a99","modified":1656414491423},{"_id":"public/assets/svg_icons.svg","hash":"988cda366837940196ff88333186d9707feee8ac","modified":1656414491423},{"_id":"public/javascripts/acelog.js","hash":"230cb0545de6fb7c0935eb278b20bf2ca2971d37","modified":1656414491423},{"_id":"public/css/style.css","hash":"683028554b713149e102326411825ce010a27aea","modified":1656414491423},{"_id":"public/css/dracula.css","hash":"2633f2e84680e9f381e9ac1df344b542e28f9774","modified":1656414491423},{"_id":"public/javascripts/highlight.pack.js","hash":"aaac7fbc3ae1b46bf01b4bae2a8b1829ea370405","modified":1656414491423},{"_id":"public/assets/JosefinSans-SemiBoldItalic.ttf","hash":"b8ec4d6c33033901489df706156609e528ed3d0f","modified":1656414491423},{"_id":"public/assets/JosefinSans-Regular.ttf","hash":"7bc8324d2ff6a6fc28794c8ba607e30f47a2161a","modified":1656414491423},{"_id":"source/404/index.md","hash":"449b1c36ceabd6630e1be04de3f017e937dde37e","modified":1656414918470},{"_id":"public/404.html","hash":"fc13cdc578916e47bb1c5a44c2dc2b3166222a2b","modified":1656414930108}],"Category":[],"Data":[],"Page":[{"title":"404","date":"1969-12-31T16:00:00.000Z","comments":0,"_content":"\n<!-- markdownlint-disable MD039 MD033 -->\n\n## 這是一個不存在的頁面\n\n很抱歉，你目前存取的頁面並不存在。\n\n預計將在約 <span id=\"timeout\">5</span> 秒後返回首頁。\n\n如果你很急著想看文章，你可以 **[點這裡](https://www.iguan7u.cn)** 返回首頁。\n\n<script>\nlet countTime = 5;\n\nfunction count() {\n\n  document.getElementById('timeout').textContent = countTime;\n  countTime -= 1;\n  if(countTime === 0){\n    location.href = 'https://www.iguan7u.cn';\n  }\n  setTimeout(() => {\n    count();\n  }, 1000);\n}\n\ncount();\n</script>\n","source":"404/index.md","raw":"---\ntitle: 404\ndate: 1970-01-01 00:00:00\npermalink: /404.html\ncomments: false\n---\n\n<!-- markdownlint-disable MD039 MD033 -->\n\n## 這是一個不存在的頁面\n\n很抱歉，你目前存取的頁面並不存在。\n\n預計將在約 <span id=\"timeout\">5</span> 秒後返回首頁。\n\n如果你很急著想看文章，你可以 **[點這裡](https://www.iguan7u.cn)** 返回首頁。\n\n<script>\nlet countTime = 5;\n\nfunction count() {\n\n  document.getElementById('timeout').textContent = countTime;\n  countTime -= 1;\n  if(countTime === 0){\n    location.href = 'https://www.iguan7u.cn';\n  }\n  setTimeout(() => {\n    count();\n  }, 1000);\n}\n\ncount();\n</script>\n","updated":"2022-06-28T11:15:18.470Z","path":"/404.html","layout":"page","_id":"cl4y2ojzx0000vz05bzwg05s2","content":"<!-- markdownlint-disable MD039 MD033 -->\n\n<h2 id=\"這是一個不存在的頁面\"><a href=\"#這是一個不存在的頁面\" class=\"headerlink\" title=\"這是一個不存在的頁面\"></a>這是一個不存在的頁面</h2><p>很抱歉，你目前存取的頁面並不存在。</p>\n<p>預計將在約 <span id=\"timeout\">5</span> 秒後返回首頁。</p>\n<p>如果你很急著想看文章，你可以 <strong><a href=\"https://www.iguan7u.cn/\">點這裡</a></strong> 返回首頁。</p>\n<script>\nlet countTime = 5;\n\nfunction count() {\n\n  document.getElementById('timeout').textContent = countTime;\n  countTime -= 1;\n  if(countTime === 0){\n    location.href = 'https://www.iguan7u.cn';\n  }\n  setTimeout(() => {\n    count();\n  }, 1000);\n}\n\ncount();\n</script>\n","site":{"data":{}},"excerpt":"這是一個不存在的頁面\n很抱歉，你目前存取的頁面並不存在。\n\n預計將在約 5 秒後返回首頁。\n\n如果你很急著想看文章，你可以 點這裡 返回首頁。","more":"<!-- markdownlint-disable MD039 MD033 -->\n\n<h2 id=\"這是一個不存在的頁面\"><a href=\"#這是一個不存在的頁面\" class=\"headerlink\" title=\"這是一個不存在的頁面\"></a>這是一個不存在的頁面</h2><p>很抱歉，你目前存取的頁面並不存在。</p>\n<p>預計將在約 <span id=\"timeout\">5</span> 秒後返回首頁。</p>\n<p>如果你很急著想看文章，你可以 <strong><a href=\"https://www.iguan7u.cn/\">點這裡</a></strong> 返回首頁。</p>\n<script>\nlet countTime = 5;\n\nfunction count() {\n\n  document.getElementById('timeout').textContent = countTime;\n  countTime -= 1;\n  if(countTime === 0){\n    location.href = 'https://www.iguan7u.cn';\n  }\n  setTimeout(() => {\n    count();\n  }, 1000);\n}\n\ncount();\n</script>\n"}],"Post":[{"title":"Acetolog 创作之路","date":"2020-02-21T09:17:25.000Z","_content":"## 前言\n看到陆续有些人使用自己的博客主题 [Acetolog](https://github.com/iGuan7u/Acetolog)，感觉也是时候注水一下关于这个博客主题了。\n\n<!-- more -->\n\n## 起因\n其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID **iGuan7u** 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到**挑选博客主题**这一步遇到了瓶颈。\n\n能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 [typology](https://demo.mekshq.com/typology/)，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。~~因为它实在是太美了。~~\n\n当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。\n\n## 动手\n当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。~~虽然现在看来甚至还不如不发挥。~~\n\n不过样式部分其实并不属于这个博客的精彩部分。\n\n笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 [hexo-next](https://github.com/theme-next/hexo-theme-next) ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。\n\n![hexo-next](https://cdn.iguan7u.cn/image/hexo-next_resources.png)\n\n![typelogy](https://cdn.iguan7u.cn/image/typology_resources.png)\n\n![acetolog](https://cdn.iguan7u.cn/image/acelog_resources.png)\n\n同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。\n\n虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。\n\n## 感想\n另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。\n\n自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 `jQuery` 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）\n\n甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。\n\n目前阶段 Acetolog 还是以 **tiny** 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。\n\n谢谢。","source":"_posts/Acetolog-创作之路.md","raw":"---\ntitle: Acetolog 创作之路\ndate: 2020-02-21 17:17:25\ntags:\n---\n## 前言\n看到陆续有些人使用自己的博客主题 [Acetolog](https://github.com/iGuan7u/Acetolog)，感觉也是时候注水一下关于这个博客主题了。\n\n<!-- more -->\n\n## 起因\n其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID **iGuan7u** 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到**挑选博客主题**这一步遇到了瓶颈。\n\n能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 [typology](https://demo.mekshq.com/typology/)，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。~~因为它实在是太美了。~~\n\n当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。\n\n## 动手\n当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。~~虽然现在看来甚至还不如不发挥。~~\n\n不过样式部分其实并不属于这个博客的精彩部分。\n\n笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 [hexo-next](https://github.com/theme-next/hexo-theme-next) ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。\n\n![hexo-next](https://cdn.iguan7u.cn/image/hexo-next_resources.png)\n\n![typelogy](https://cdn.iguan7u.cn/image/typology_resources.png)\n\n![acetolog](https://cdn.iguan7u.cn/image/acelog_resources.png)\n\n同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。\n\n虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。\n\n## 感想\n另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。\n\n自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 `jQuery` 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）\n\n甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。\n\n目前阶段 Acetolog 还是以 **tiny** 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。\n\n谢谢。","slug":"Acetolog-创作之路","published":1,"updated":"2022-02-23T13:14:20.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5h70000rv050n34eqzq","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>看到陆续有些人使用自己的博客主题 <a href=\"https://github.com/iGuan7u/Acetolog\">Acetolog</a>，感觉也是时候注水一下关于这个博客主题了。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID <strong>iGuan7u</strong> 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到<strong>挑选博客主题</strong>这一步遇到了瓶颈。</p>\n<p>能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 <a href=\"https://demo.mekshq.com/typology/\">typology</a>，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。<del>因为它实在是太美了。</del></p>\n<p>当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。</p>\n<h2 id=\"动手\"><a href=\"#动手\" class=\"headerlink\" title=\"动手\"></a>动手</h2><p>当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。<del>虽然现在看来甚至还不如不发挥。</del></p>\n<p>不过样式部分其实并不属于这个博客的精彩部分。</p>\n<p>笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 <a href=\"https://github.com/theme-next/hexo-theme-next\">hexo-next</a> ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/hexo-next_resources.png\" alt=\"hexo-next\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/typology_resources.png\" alt=\"typelogy\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/acelog_resources.png\" alt=\"acetolog\"></p>\n<p>同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。</p>\n<p>虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。</p>\n<h2 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h2><p>另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。</p>\n<p>自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 <code>jQuery</code> 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）</p>\n<p>甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。</p>\n<p>目前阶段 Acetolog 还是以 <strong>tiny</strong> 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。</p>\n<p>谢谢。</p>\n","site":{"data":{}},"excerpt":"前言\n看到陆续有些人使用自己的博客主题 Acetolog，感觉也是时候注水一下关于这个博客主题了。\n\n起因\n其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID iGuan7u 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到挑选博客主题这一步遇到","more":"<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>其实跟很多技术同学的出发点相同，就是想拥有一个自己的技术博客，有机会的话能够将自己的专属 ID <strong>iGuan7u</strong> 发扬光大，然后陆续开始筹备整个方案，购置 VPS、购买域名、选择博客系统、挑选博客主题…然后也跟许多同学的发展路线一致：购置准备相关的东西都是一帆风顺的，直到<strong>挑选博客主题</strong>这一步遇到了瓶颈。</p>\n<p>能够遇到符合自己审美的主题实在太难了，笔者也是寻遍了整个 Google，才偶然遇到了这个主题 <a href=\"https://demo.mekshq.com/typology/\">typology</a>，甚至后来为了这个主题不得已地从其他的博客系统毅然决然地投奔到 wordpress 的怀抱中。<del>因为它实在是太美了。</del></p>\n<p>当然，后面的故事也能想象到：wordpress 对于一个简单的博客系统来说实在是太大了，有很多不必要的功能、同时也因为过于庞大，导致想实现自己的功能都无从下手。另外 typology 虽然非常美观，可是页面加载速度却不甚理想，其中包含了很多自己并不想要的功能跟表现。</p>\n<h2 id=\"动手\"><a href=\"#动手\" class=\"headerlink\" title=\"动手\"></a>动手</h2><p>当然，开始启动的时候，还是希望像素级的还原（抄袭）typology 的主题的，由于自己的懒惰，以及目前本人博客的文章数量还不多，后续对 typology 的功能进行了精简，文章详情部分样式还做了自己的发挥。<del>虽然现在看来甚至还不如不发挥。</del></p>\n<p>不过样式部分其实并不属于这个博客的精彩部分。</p>\n<p>笔者在创作这个主题是其实最关心的部分，是博客所需加载的资源大小。笔者对比过 typology，对比过 hexo 主题界几乎一统江山的 <a href=\"https://github.com/theme-next/hexo-theme-next\">hexo-next</a> ，acetolog 所需加载的资源数量以及资源大小都是有极大优势的。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/hexo-next_resources.png\" alt=\"hexo-next\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/typology_resources.png\" alt=\"typelogy\"></p>\n<p><img src=\"https://cdn.iguan7u.cn/image/acelog_resources.png\" alt=\"acetolog\"></p>\n<p>同时，不同于广泛的博客主题，在 Acetolog 中，Javascript 在其中所发挥的，仅仅是提升用户体验的作用，Acetolog 甚至能在浏览器禁用 Javascript 运行的环境下正常打开。</p>\n<p>虽然这部分优势对于普通的读者来说是毫无作用的，可是对于笔者来说，这取得的成就感可以说是前所未有的。毕竟，搭建博客的过程本身就是一件值得享受的事情。感兴趣的读者可以 fork 一下，跟笔者一起完善这个主题。</p>\n<h2 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h2><p>另外一点关于 Javascript，自从 Google 使用 Javascript ajax 做搜索候选关键字后，Javascript 这门语言可以说得到了飞速的发展，现在的 React、Vue.js 的框架更是将 Javascript 推上了不可撼动的地位，以至于如今的前端页面，没有 Javascript，甚至根本无法正常运行。（有兴趣的读者可以尝试自行在浏览器中关于 Enable Javascript 的选项，看看那个网页还能正常展示）这里并非说 Javascript 不好，只是在目前，这种当初仅仅作为浏览器与网页间沟通的语言，过多地承载了负责展示页面信息的功能，使得前端工作似乎仅仅是把 Javascript 写好而已，其中的 HTML 跟 CSS 就黯然失色。</p>\n<p>自己在下定决心实现这个主题前，自己也有寻找过很多主题，可是实在看不惯很多开发者，在为了简化 DOM 选择、或者是方便 CSS 属性变更，就直接把 <code>jQuery</code> 这个库引入博客资源，这对整个博客的加载速度造成了多大的影响。（扶额）</p>\n<p>甚至，当初 Acetolog 根本不打算引入 Javascript，包括右上角的 Sidebar 功能，笔者都找到了单纯使用的 HTML5 + CSS 解决方案，但是后面发现自己在这个方面有点过于执着了，也极大的限制了这个博客主题的发展，很庆幸自己很快便认清了现实。</p>\n<p>目前阶段 Acetolog 还是以 <strong>tiny</strong> 为主要目的，为大家提供一个精简而又优雅的博客主题。对于功能上的开发会尽可能地克制，至少自己能保证，每一行新增的代码，我都考虑了加载速度的影响。</p>\n<p>谢谢。</p>"},{"title":"Chrome Inspect iOS (UI/WK)WebView","date":"2020-01-03T07:46:03.000Z","_content":"\n## 被 Safari 支配的恐惧\n![Safari_Icoon](https://cdn.iguan7u.cn/image/safari_icon_240.png)\n曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。\n可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在**使用大量能耗**的应用列表上了。\n当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari **曾经**是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。\n\n## ios-webkit-debug-proxy\n[ios-webkit-debug-proxy](https://github.com/google/ios-webkit-debug-proxy) 是我在无意间划水 Github 时发现的一个代理工具，它借助于 [usbmuxd](https://github.com/libimobiledevice/usbmuxd) 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。\n\n借用项目中的示意图：\n\n![](https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png)\n\n### 安装依赖：\n\n- [homebrew](http://brew.sh/)\n\n### 安装方法：\n\n> 为了避免出现 `Could not connect to lockdownd, error code -<number>. Exiting.` 错误，建议不要直接 `brew install ios-webkit-debug-proxy` 安装。  \n\n```shell\n$: brew update\n$: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd\n$: brew install --HEAD usbmuxd\n$: brew install --HEAD libimobiledevice\n$: brew install -s ios-webkit-debug-proxy\n```\n\n### 使用方法：\n\n```shell\n$: ios-webkit-debug-proxy\n```\n\n> ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  \n\n连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 [localhost:9221](h) 查看连接设备列表。\n\n```shell\n$: ios-webkit-debug-proxy\nListing devices on :9221\nConnected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\nDisconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\n```\n\n## Chrome 拯救世人\n当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。\n\n1. 我们就需要启动 Chrome\n2. 打开 [Inspector](chrome://inspect) 页面\n3. 点击 `Discover network targets` 后的 `configure` 按钮\n4. 输入上面展示的设备端口地址：`localhost:9222` ，点击 `done` 按钮\n5. 在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～\n\n不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 [RemoteDebug iOS WebKit Adapter](https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter)，这个使用 ios-webkit-debug-proxy 做底层的一个工具。\n\n## Bug\n笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。","source":"_posts/Chrome-Inspect-iOS-UI-WK-WebView.md","raw":"---\ntitle: Chrome Inspect iOS (UI/WK)WebView\ndate: 2020-01-03 15:46:03\ntags:\n---\n\n## 被 Safari 支配的恐惧\n![Safari_Icoon](https://cdn.iguan7u.cn/image/safari_icon_240.png)\n曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。\n可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在**使用大量能耗**的应用列表上了。\n当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari **曾经**是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。\n\n## ios-webkit-debug-proxy\n[ios-webkit-debug-proxy](https://github.com/google/ios-webkit-debug-proxy) 是我在无意间划水 Github 时发现的一个代理工具，它借助于 [usbmuxd](https://github.com/libimobiledevice/usbmuxd) 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。\n\n借用项目中的示意图：\n\n![](https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png)\n\n### 安装依赖：\n\n- [homebrew](http://brew.sh/)\n\n### 安装方法：\n\n> 为了避免出现 `Could not connect to lockdownd, error code -<number>. Exiting.` 错误，建议不要直接 `brew install ios-webkit-debug-proxy` 安装。  \n\n```shell\n$: brew update\n$: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd\n$: brew install --HEAD usbmuxd\n$: brew install --HEAD libimobiledevice\n$: brew install -s ios-webkit-debug-proxy\n```\n\n### 使用方法：\n\n```shell\n$: ios-webkit-debug-proxy\n```\n\n> ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  \n\n连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 [localhost:9221](h) 查看连接设备列表。\n\n```shell\n$: ios-webkit-debug-proxy\nListing devices on :9221\nConnected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\nDisconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)\n```\n\n## Chrome 拯救世人\n当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。\n\n1. 我们就需要启动 Chrome\n2. 打开 [Inspector](chrome://inspect) 页面\n3. 点击 `Discover network targets` 后的 `configure` 按钮\n4. 输入上面展示的设备端口地址：`localhost:9222` ，点击 `done` 按钮\n5. 在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～\n\n不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 [RemoteDebug iOS WebKit Adapter](https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter)，这个使用 ios-webkit-debug-proxy 做底层的一个工具。\n\n## Bug\n笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。","slug":"Chrome-Inspect-iOS-UI-WK-WebView","published":1,"updated":"2022-02-23T13:14:20.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5h90001rv0585h7ceof","content":"<h2 id=\"被-Safari-支配的恐惧\"><a href=\"#被-Safari-支配的恐惧\" class=\"headerlink\" title=\"被 Safari 支配的恐惧\"></a>被 Safari 支配的恐惧</h2><p><img src=\"https://cdn.iguan7u.cn/image/safari_icon_240.png\" alt=\"Safari_Icoon\"><br>曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。<br>可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在<strong>使用大量能耗</strong>的应用列表上了。<br>当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari <strong>曾经</strong>是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。</p>\n<h2 id=\"ios-webkit-debug-proxy\"><a href=\"#ios-webkit-debug-proxy\" class=\"headerlink\" title=\"ios-webkit-debug-proxy\"></a>ios-webkit-debug-proxy</h2><p><a href=\"https://github.com/google/ios-webkit-debug-proxy\">ios-webkit-debug-proxy</a> 是我在无意间划水 Github 时发现的一个代理工具，它借助于 <a href=\"https://github.com/libimobiledevice/usbmuxd\">usbmuxd</a> 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。</p>\n<p>借用项目中的示意图：</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png\"></p>\n<h3 id=\"安装依赖：\"><a href=\"#安装依赖：\" class=\"headerlink\" title=\"安装依赖：\"></a>安装依赖：</h3><ul>\n<li><a href=\"http://brew.sh/\">homebrew</a></li>\n</ul>\n<h3 id=\"安装方法：\"><a href=\"#安装方法：\" class=\"headerlink\" title=\"安装方法：\"></a>安装方法：</h3><blockquote>\n<p>为了避免出现 <code>Could not connect to lockdownd, error code -&lt;number&gt;. Exiting.</code> 错误，建议不要直接 <code>brew install ios-webkit-debug-proxy</code> 安装。  </p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew update</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew install --HEAD usbmuxd</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew install --HEAD libimobiledevice</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew install -s ios-webkit-debug-proxy</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: ios-webkit-debug-proxy</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  </p>\n</blockquote>\n<p>连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 <a href=\"h\">localhost:9221</a> 查看连接设备列表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: ios-webkit-debug-proxy</span><br>Listing devices on :9221<br>Connected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)<br>Disconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Chrome-拯救世人\"><a href=\"#Chrome-拯救世人\" class=\"headerlink\" title=\"Chrome 拯救世人\"></a>Chrome 拯救世人</h2><p>当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。</p>\n<ol>\n<li>我们就需要启动 Chrome</li>\n<li>打开 <a href=\"chrome://inspect\">Inspector</a> 页面</li>\n<li>点击 <code>Discover network targets</code> 后的 <code>configure</code> 按钮</li>\n<li>输入上面展示的设备端口地址：<code>localhost:9222</code> ，点击 <code>done</code> 按钮</li>\n<li>在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～</li>\n</ol>\n<p>不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 <a href=\"https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter\">RemoteDebug iOS WebKit Adapter</a>，这个使用 ios-webkit-debug-proxy 做底层的一个工具。</p>\n<h2 id=\"Bug\"><a href=\"#Bug\" class=\"headerlink\" title=\"Bug\"></a>Bug</h2><p>笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。</p>\n","site":{"data":{}},"excerpt":"被 Safari 支配的恐惧\n\n曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain, TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。\n可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript","more":"<h2 id=\"被-Safari-支配的恐惧\"><a href=\"#被-Safari-支配的恐惧\" class=\"headerlink\" title=\"被 Safari 支配的恐惧\"></a>被 Safari 支配的恐惧</h2><p><img src=\"https://cdn.iguan7u.cn/image/safari_icon_240.png\" alt=\"Safari_Icoon\"><br>曾几何时，Safari 也是一个相当优秀的浏览器：启动迅速，资源占用少，能耗影响低，同时能跟 macOS 中其他的服务无缝的配合着：Keychain,  TouchID, handOff。即便全世界都高呼 Chrome 宇宙第一浏览器，笔者一直都是 Safari 的忠实用户，不离不弃。<br>可是不知道什么时候开始，Safari 也主打性能了，渲染速度、JavaScript 运行速度，都出现在了发布会 Keynote 上。普通用户对性能提升当然欢呼雀跃，可是对于经常不插电源使用 macBook 的笔者，我也慢慢留意到 Safari 开始频繁出现在<strong>使用大量能耗</strong>的应用列表上了。<br>当然，只是使用大量能耗，也谈不上恐惧。真正恐惧的，是作为一名 iOS 开发者，Safari 基本上是你离不开的工具，在调试 iOS 的 UIWebView、WKWebView、MobileSafari，Safari <strong>曾经</strong>是你唯一可靠的工具，而如今，添加 CSS 属性异常，Source 无法展示部分较大的 js 文件，甚至于 WebInspector 直接 Crash，弄得民怨沸腾的。</p>\n<h2 id=\"ios-webkit-debug-proxy\"><a href=\"#ios-webkit-debug-proxy\" class=\"headerlink\" title=\"ios-webkit-debug-proxy\"></a>ios-webkit-debug-proxy</h2><p><a href=\"https://github.com/google/ios-webkit-debug-proxy\">ios-webkit-debug-proxy</a> 是我在无意间划水 Github 时发现的一个代理工具，它借助于 <a href=\"https://github.com/libimobiledevice/usbmuxd\">usbmuxd</a> 工具所提供的功能，将调试命令发送到 iOS 设备的 com.apple.webinspector 服务中，从而达到不使用 Safari 调试 iOS WebView 的目的。</p>\n<p>借用项目中的示意图：</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ios-webkit-debug-proxy.png\"></p>\n<h3 id=\"安装依赖：\"><a href=\"#安装依赖：\" class=\"headerlink\" title=\"安装依赖：\"></a>安装依赖：</h3><ul>\n<li><a href=\"http://brew.sh/\">homebrew</a></li>\n</ul>\n<h3 id=\"安装方法：\"><a href=\"#安装方法：\" class=\"headerlink\" title=\"安装方法：\"></a>安装方法：</h3><blockquote>\n<p>为了避免出现 <code>Could not connect to lockdownd, error code -&lt;number&gt;. Exiting.</code> 错误，建议不要直接 <code>brew install ios-webkit-debug-proxy</code> 安装。  </p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew update</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew uninstall --force libimobiledevice ios-webkit-debug-proxy usbmuxd</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew install --HEAD usbmuxd</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew install --HEAD libimobiledevice</span><br><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: brew install -s ios-webkit-debug-proxy</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: ios-webkit-debug-proxy</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ios-webkit-debug-proxy 默认使用 9221 端口，然后从 9222-9322 会递增地分配给每一台连接成功的 iOS 设备。  </p>\n</blockquote>\n<p>连接电脑后，确认已经通过 iTunes 信任设备后，Terminal 会显示出设备名以及对应的端口号，或者直接打开 <a href=\"h\">localhost:9221</a> 查看连接设备列表。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: ios-webkit-debug-proxy</span><br>Listing devices on :9221<br>Connected :9222 to “iGuan7u” iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)<br>Disconnected :9222 from “iGuan7u”  iPad (aaaaaaaaaaaaaaaaaaaaaaaaaab7e05)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Chrome-拯救世人\"><a href=\"#Chrome-拯救世人\" class=\"headerlink\" title=\"Chrome 拯救世人\"></a>Chrome 拯救世人</h2><p>当然，我们的目的不是启动 ios-webkit-debug-proxy 来查看 iOS 的设备名以及 UUID 的，而是希望脱离 Safari 的魔爪，奔向自由的 Chrome DevTool。</p>\n<ol>\n<li>我们就需要启动 Chrome</li>\n<li>打开 <a href=\"chrome://inspect\">Inspector</a> 页面</li>\n<li>点击 <code>Discover network targets</code> 后的 <code>configure</code> 按钮</li>\n<li>输入上面展示的设备端口地址：<code>localhost:9222</code> ，点击 <code>done</code> 按钮</li>\n<li>在页面的 Remote Target 中即可看到你连入的设备了，开始你的调试吧～</li>\n</ol>\n<p>不过 Inspect 页面可能没有直接展示 WebView 的截屏，这里可以使用另外一个开源工具 <a href=\"https://github.com/RemoteDebug/remotedebug-ios-webkit-adapter\">RemoteDebug iOS WebKit Adapter</a>，这个使用 ios-webkit-debug-proxy 做底层的一个工具。</p>\n<h2 id=\"Bug\"><a href=\"#Bug\" class=\"headerlink\" title=\"Bug\"></a>Bug</h2><p>笔者自测，在 iOS13 中，inspect 页面似乎没有正确展示 Element 等信息，Console Tab 也没有打出任何日志信息，估计是工具的问题，期待后期 Google 方（没错，这个工具是 Google 的～）的解决吧。</p>\n"},{"title":"Debug electron main process on VSCode","date":"2019-01-15T12:03:48.000Z","_content":"\n普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。[Electron](https://electronjs.org/) 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。\n\n### 官方指导\n\n在 Electron 官网中，可以找到文档 [使用 VSCode 进行主进程调试 | Electron](https://electronjs.org/docs/tutorial/debugging-main-process-vscode) 指引如何进行调试开发。\n\n### 发现问题\n\nElectron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。\n而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。\n\n### 解决方案\n\nelectron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 [Electron-Vue](https://github.com/SimulatedGREG/electron-vue) 的模版为例。\n\n##### 1. 修改 webpack dev 配置：\n\n在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。\n在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。\n```\n{\n...\n  devServer: {\n    writeToDisk: true,   // 开启磁盘存储功能\n    inline: false        // 关闭内联模式，修复可能 webpack 运行失败问题\n  },\n  devtool: '#source-map' // 保存 sourceMap 文件，断点调试需要\n}\n```\n\n##### 2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\n\n因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。\n除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。\n\n假设构建输出目录为 app/dist，新建一个 terminal，执行下面的命令：\n```\n# 启动主进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.main.config.js --port 9081 --content-base app/dist\n```\n\n同时，在另一个 terminal 中，执行下面的命令：\n```\n# 启动渲染进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.renderer.config.js --port 9080 --content-base app/dist\n```\n\n##### 3. 配置 VSCode debug：\n\n1. 启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；\n2. 在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)\n```\n{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n\t\t\t\"name\": \"Launch\",\n\t\t\t\"type\": \"node\",\n\t\t\t\"request\": \"launch\",\n\t\t\t\"program\": \"${workspaceRoot}/dist/electron/main.js\",\n\t\t\t\"stopOnEntry\": false,\n\t\t\t\"args\": [],\n\t\t\t\"cwd\": \"${workspaceRoot}\",\n                        // this points to the electron task runner\n\t\t\t\"runtimeExecutable\": \"${workspaceRoot}/node_modules/.bin/electron\",\n\t\t\t\"runtimeArgs\": [\n\t\t\t\t\"--nolazy\"\n\t\t\t],\n\t\t\t\"console\": \"integratedTerminal\",\n\t\t\t\"sourceMaps\": true,\n\t\t\t\"outFiles\": []\n    }\n\t]\n}\n```\n3. 选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；\n4. 在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；\n\n#### 热更新\n\n- 主进程跟渲染进程的编辑都能够热更新\n- 编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码\n- 编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码\n\nHave Fun.\n","source":"_posts/Debug-electron-main-process-on-VSCode.md","raw":"---\ntitle: Debug electron main process on VSCode\ndate: 2019-01-15 20:03:48\ntags: Electron\n---\n\n普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。[Electron](https://electronjs.org/) 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。\n\n### 官方指导\n\n在 Electron 官网中，可以找到文档 [使用 VSCode 进行主进程调试 | Electron](https://electronjs.org/docs/tutorial/debugging-main-process-vscode) 指引如何进行调试开发。\n\n### 发现问题\n\nElectron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。\n而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。\n\n### 解决方案\n\nelectron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 [Electron-Vue](https://github.com/SimulatedGREG/electron-vue) 的模版为例。\n\n##### 1. 修改 webpack dev 配置：\n\n在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。\n在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。\n```\n{\n...\n  devServer: {\n    writeToDisk: true,   // 开启磁盘存储功能\n    inline: false        // 关闭内联模式，修复可能 webpack 运行失败问题\n  },\n  devtool: '#source-map' // 保存 sourceMap 文件，断点调试需要\n}\n```\n\n##### 2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\n\n因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。\n除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。\n\n假设构建输出目录为 app/dist，新建一个 terminal，执行下面的命令：\n```\n# 启动主进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.main.config.js --port 9081 --content-base app/dist\n```\n\n同时，在另一个 terminal 中，执行下面的命令：\n```\n# 启动渲染进程构建任务\n$: webpack-dev-server --colors --config ./.electron-vue/webpack.renderer.config.js --port 9080 --content-base app/dist\n```\n\n##### 3. 配置 VSCode debug：\n\n1. 启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；\n2. 在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)\n```\n{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n\t\t\t\"name\": \"Launch\",\n\t\t\t\"type\": \"node\",\n\t\t\t\"request\": \"launch\",\n\t\t\t\"program\": \"${workspaceRoot}/dist/electron/main.js\",\n\t\t\t\"stopOnEntry\": false,\n\t\t\t\"args\": [],\n\t\t\t\"cwd\": \"${workspaceRoot}\",\n                        // this points to the electron task runner\n\t\t\t\"runtimeExecutable\": \"${workspaceRoot}/node_modules/.bin/electron\",\n\t\t\t\"runtimeArgs\": [\n\t\t\t\t\"--nolazy\"\n\t\t\t],\n\t\t\t\"console\": \"integratedTerminal\",\n\t\t\t\"sourceMaps\": true,\n\t\t\t\"outFiles\": []\n    }\n\t]\n}\n```\n3. 选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；\n4. 在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；\n\n#### 热更新\n\n- 主进程跟渲染进程的编辑都能够热更新\n- 编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码\n- 编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码\n\nHave Fun.\n","slug":"Debug-electron-main-process-on-VSCode","published":1,"updated":"2022-02-23T13:14:20.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5ha0002rv057oshgu3t","content":"<p>普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。<a href=\"https://electronjs.org/\">Electron</a> 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。</p>\n<h3 id=\"官方指导\"><a href=\"#官方指导\" class=\"headerlink\" title=\"官方指导\"></a>官方指导</h3><p>在 Electron 官网中，可以找到文档 <a href=\"https://electronjs.org/docs/tutorial/debugging-main-process-vscode\">使用 VSCode 进行主进程调试 | Electron</a> 指引如何进行调试开发。</p>\n<h3 id=\"发现问题\"><a href=\"#发现问题\" class=\"headerlink\" title=\"发现问题\"></a>发现问题</h3><p>Electron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。<br>而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>electron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 <a href=\"https://github.com/SimulatedGREG/electron-vue\">Electron-Vue</a> 的模版为例。</p>\n<h5 id=\"1-修改-webpack-dev-配置：\"><a href=\"#1-修改-webpack-dev-配置：\" class=\"headerlink\" title=\"1. 修改 webpack dev 配置：\"></a>1. 修改 webpack dev 配置：</h5><p>在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。<br>在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">&#123;<br>...<br>  devServer: &#123;<br>    writeToDisk: true,   // 开启磁盘存储功能<br>    inline: false        // 关闭内联模式，修复可能 webpack 运行失败问题<br>  &#125;,<br>  devtool: &#x27;#source-map&#x27; // 保存 sourceMap 文件，断点调试需要<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\"><a href=\"#2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\" class=\"headerlink\" title=\"2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\"></a>2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：</h5><p>因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。<br>除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。</p>\n<p>假设构建输出目录为 app&#x2F;dist，新建一个 terminal，执行下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\"># 启动主进程构建任务<br>$: webpack-dev-server --colors --config ./.electron-vue/webpack.main.config.js --port 9081 --content-base app/dist<br></code></pre></td></tr></table></figure>\n\n<p>同时，在另一个 terminal 中，执行下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\"># 启动渲染进程构建任务<br>$: webpack-dev-server --colors --config ./.electron-vue/webpack.renderer.config.js --port 9080 --content-base app/dist<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-配置-VSCode-debug：\"><a href=\"#3-配置-VSCode-debug：\" class=\"headerlink\" title=\"3. 配置 VSCode debug：\"></a>3. 配置 VSCode debug：</h5><ol>\n<li>启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；</li>\n<li>在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">&#123;<br>  // Use IntelliSense to learn about possible Node.js debug attributes.<br>  // Hover to view descriptions of existing attributes.<br>  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387<br>  &quot;version&quot;: &quot;0.2.0&quot;,<br>  &quot;configurations&quot;: [<br>    &#123;<br>\t\t\t&quot;name&quot;: &quot;Launch&quot;,<br>\t\t\t&quot;type&quot;: &quot;node&quot;,<br>\t\t\t&quot;request&quot;: &quot;launch&quot;,<br>\t\t\t&quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/dist/electron/main.js&quot;,<br>\t\t\t&quot;stopOnEntry&quot;: false,<br>\t\t\t&quot;args&quot;: [],<br>\t\t\t&quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,<br>                        // this points to the electron task runner<br>\t\t\t&quot;runtimeExecutable&quot;: &quot;$&#123;workspaceRoot&#125;/node_modules/.bin/electron&quot;,<br>\t\t\t&quot;runtimeArgs&quot;: [<br>\t\t\t\t&quot;--nolazy&quot;<br>\t\t\t],<br>\t\t\t&quot;console&quot;: &quot;integratedTerminal&quot;,<br>\t\t\t&quot;sourceMaps&quot;: true,<br>\t\t\t&quot;outFiles&quot;: []<br>    &#125;<br>\t]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；</li>\n<li>在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；</li>\n</ol>\n<h4 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h4><ul>\n<li>主进程跟渲染进程的编辑都能够热更新</li>\n<li>编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码</li>\n<li>编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码</li>\n</ul>\n<p>Have Fun.</p>\n","site":{"data":{}},"excerpt":"普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。Electron 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。\n","more":"<p>普通的后台开发，在调试阶段都以添加日志为首要的开发手段，根据不同的日志信息进行程序运行状态的推断。<a href=\"https://electronjs.org/\">Electron</a> 以整合 node.js 以及 chromium 提供跨平台应用开发的方案，在进行 electron 开发时，笔者很长一段时间都用 node.js 的后台开发方式进行桌面应用开发，以至于开发体验非常的差。本着“磨刀不误砍柴工”的原理，开始了寻找高效开发 electron 应用的方式。</p>\n<h3 id=\"官方指导\"><a href=\"#官方指导\" class=\"headerlink\" title=\"官方指导\"></a>官方指导</h3><p>在 Electron 官网中，可以找到文档 <a href=\"https://electronjs.org/docs/tutorial/debugging-main-process-vscode\">使用 VSCode 进行主进程调试 | Electron</a> 指引如何进行调试开发。</p>\n<h3 id=\"发现问题\"><a href=\"#发现问题\" class=\"headerlink\" title=\"发现问题\"></a>发现问题</h3><p>Electron 主进程使用的是 node.js，由于 node.js 中的 V8 引擎对 ES6 的支持并不完善，导致根据官网文档方式进行调试开发 ES6 语法的 js 文件，会报出异常，所以官方指导方法只适用于非 ES6 语法开发的应用。<br>而使用 ES6 开发应用最好的方式就是接入 webpack+babel 的配置。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>electron+webpack+babel 的开发方式，github 上已经存在不少的模板，本文以 <a href=\"https://github.com/SimulatedGREG/electron-vue\">Electron-Vue</a> 的模版为例。</p>\n<h5 id=\"1-修改-webpack-dev-配置：\"><a href=\"#1-修改-webpack-dev-配置：\" class=\"headerlink\" title=\"1. 修改 webpack dev 配置：\"></a>1. 修改 webpack dev 配置：</h5><p>在 webpack 默认的配置中，启动 webpack-dev-server 后，程序默认会将构建好的资源装载在内存中，以提高执行访问速度。这里需要对默认配置进行修改，将构建成功后的资源写入到磁盘中，以便 webpack 能指定程序启动入口。<br>在 debug 配置选项中，增加下述配置，即可开启存储到磁盘的功能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">&#123;<br>...<br>  devServer: &#123;<br>    writeToDisk: true,   // 开启磁盘存储功能<br>    inline: false        // 关闭内联模式，修复可能 webpack 运行失败问题<br>  &#125;,<br>  devtool: &#x27;#source-map&#x27; // 保存 sourceMap 文件，断点调试需要<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\"><a href=\"#2-启动-webpack-dev-server，分别对主进程以及渲染进程的-js-资源进行构建打包：\" class=\"headerlink\" title=\"2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：\"></a>2. 启动 webpack-dev-server，分别对主进程以及渲染进程的 js 资源进行构建打包：</h5><p>因为在 electron-vue 的模板中，主进程跟渲染进程的 webpack 配置是独立存储的，所以在启动 webpack-dev-server 的时候，需要同时启动两个进程的构建任务，方可正常调试。<br>除此以外，需要注意的是，在模板中渲染进程占用的是 9080 端口，那么主进程的 webpack-dev-server 注意不要使用同一个端口，下面例子主进程使用的端口为 9081。</p>\n<p>假设构建输出目录为 app&#x2F;dist，新建一个 terminal，执行下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\"># 启动主进程构建任务<br>$: webpack-dev-server --colors --config ./.electron-vue/webpack.main.config.js --port 9081 --content-base app/dist<br></code></pre></td></tr></table></figure>\n\n<p>同时，在另一个 terminal 中，执行下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\"># 启动渲染进程构建任务<br>$: webpack-dev-server --colors --config ./.electron-vue/webpack.renderer.config.js --port 9080 --content-base app/dist<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-配置-VSCode-debug：\"><a href=\"#3-配置-VSCode-debug：\" class=\"headerlink\" title=\"3. 配置 VSCode debug：\"></a>3. 配置 VSCode debug：</h5><ol>\n<li>启动 VSCode，打开对应项目，点击左侧调试按钮 (Command + Shift + D) 进入调试面板，选择 Add Configuration… VSCode 会创建 .vscode 目录，并新建一个 launch.json 的文件，该文件是 VSCode 调试面板的配置信息；</li>\n<li>在 launch.json 文件中，输入以下内容。(其中 program 字段为 webpack-dev-server 构建后的文件)<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">&#123;<br>  // Use IntelliSense to learn about possible Node.js debug attributes.<br>  // Hover to view descriptions of existing attributes.<br>  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387<br>  &quot;version&quot;: &quot;0.2.0&quot;,<br>  &quot;configurations&quot;: [<br>    &#123;<br>\t\t\t&quot;name&quot;: &quot;Launch&quot;,<br>\t\t\t&quot;type&quot;: &quot;node&quot;,<br>\t\t\t&quot;request&quot;: &quot;launch&quot;,<br>\t\t\t&quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/dist/electron/main.js&quot;,<br>\t\t\t&quot;stopOnEntry&quot;: false,<br>\t\t\t&quot;args&quot;: [],<br>\t\t\t&quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,<br>                        // this points to the electron task runner<br>\t\t\t&quot;runtimeExecutable&quot;: &quot;$&#123;workspaceRoot&#125;/node_modules/.bin/electron&quot;,<br>\t\t\t&quot;runtimeArgs&quot;: [<br>\t\t\t\t&quot;--nolazy&quot;<br>\t\t\t],<br>\t\t\t&quot;console&quot;: &quot;integratedTerminal&quot;,<br>\t\t\t&quot;sourceMaps&quot;: true,<br>\t\t\t&quot;outFiles&quot;: []<br>    &#125;<br>\t]<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>选择调试面板中左上角的绿色箭头，即可开始调试。如果运行正常，VSCode 底部状态栏会由蓝色转变为橙色；</li>\n<li>在 VSCode 代码页面，点击代码行号左侧空白位置即可添加断点，添加成功后，断点为实心红点。如添加后为灰色空心圆点，则属于添加断点失败；</li>\n</ol>\n<h4 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h4><ul>\n<li>主进程跟渲染进程的编辑都能够热更新</li>\n<li>编辑主进程资源后，点击 VSCode 调试面板绿色刷新按钮，才能执行最新的代码</li>\n<li>编辑渲染进程资源后，在主窗口 Command+R 刷新页面，即可执行最新的代码</li>\n</ul>\n<p>Have Fun.</p>\n"},{"title":"Electron asar 格式详解","date":"2019-03-19T12:08:11.000Z","_content":"\n## What is asar?\n[asar](https://github.com/electron/asar) —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 [Electron Packager](https://github.com/electron-userland/electron-packager) 或者 [Electron Builder](https://github.com/electron-userland/electron-builder) 等构建工具时，都会默认开启 .asar 归档模式。\n\nasar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：\n\n```json\n{\n   \"files\": {\t\t\t\t// 文件结构起始位置\n      \"tmp\": {\t\t\t// 其中包含了一个 tmp 文件夹\n         \"files\": {}\n      },\n      \"usr\" : {\t\t\t// 其中包含了一个 files 文件夹\n         \"files\": {\n           \"bin\": {\t\t// files 文件夹中存在 bin 文件夹\n             \"files\": {\n               \"ls\": {\t// bin 文件夹有一个 ls 文件\n                 \"offset\": \"0\",\t// 文件起始位置 为 0\n                 \"size\": 100,\t\t// 文件大小是 100\n                 \"executable\": true\t// 该文件可以被执行\n               }\n             }\n           }\n         }\n      }\n   }\n}\n```\n\n通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。\n\n## Why use it?\n在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。\n\n除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。\n\n最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 [UglifyJS](http://lisperator.net/uglifyjs/) 等代码混淆工具。\n\n## How do use it?\n首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。\n\n全局安装 asar，或者通过 npx 命令执行：\n```\n# 全局安装 asar\n$: npm install -g asar\n```\n\n使用 asar 打包资源文件：\n```\n$: asar pack your-app-resource-folder app.asar\n```\n\n将打包资源放到指定路径：\n\tmacOS 中默认放入  `electron/Electron.app/Contents/Resources/app.asar`\n\tWindows 和 Linux 默认放入  `electron/resources/app.asar`\n\n## Other Questions\nQ: **Electron 是怎么读取 asar 文件的？**\nA：Electron 中使用了其自定义的 `fs` `require` 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。\n\nQ：**如何获取 asar 文件的属性？**\nA：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 `original-fs` 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。\n\nQ：**如何解包 asar 文件？**\nA：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：\n\n```shell\n$: asar extract app.asar dest_path\n```\n\n更多的 asar 工具命令，可以通过 `asar --help` 命令查看。\n\nEnjoy it.\n","source":"_posts/Electron-asar-格式详解.md","raw":"---\ntitle: Electron asar 格式详解\ndate: 2019-03-19 20:08:11\ntags:\n---\n\n## What is asar?\n[asar](https://github.com/electron/asar) —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 [Electron Packager](https://github.com/electron-userland/electron-packager) 或者 [Electron Builder](https://github.com/electron-userland/electron-builder) 等构建工具时，都会默认开启 .asar 归档模式。\n\nasar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：\n\n```json\n{\n   \"files\": {\t\t\t\t// 文件结构起始位置\n      \"tmp\": {\t\t\t// 其中包含了一个 tmp 文件夹\n         \"files\": {}\n      },\n      \"usr\" : {\t\t\t// 其中包含了一个 files 文件夹\n         \"files\": {\n           \"bin\": {\t\t// files 文件夹中存在 bin 文件夹\n             \"files\": {\n               \"ls\": {\t// bin 文件夹有一个 ls 文件\n                 \"offset\": \"0\",\t// 文件起始位置 为 0\n                 \"size\": 100,\t\t// 文件大小是 100\n                 \"executable\": true\t// 该文件可以被执行\n               }\n             }\n           }\n         }\n      }\n   }\n}\n```\n\n通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。\n\n## Why use it?\n在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。\n\n除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。\n\n最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 [UglifyJS](http://lisperator.net/uglifyjs/) 等代码混淆工具。\n\n## How do use it?\n首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。\n\n全局安装 asar，或者通过 npx 命令执行：\n```\n# 全局安装 asar\n$: npm install -g asar\n```\n\n使用 asar 打包资源文件：\n```\n$: asar pack your-app-resource-folder app.asar\n```\n\n将打包资源放到指定路径：\n\tmacOS 中默认放入  `electron/Electron.app/Contents/Resources/app.asar`\n\tWindows 和 Linux 默认放入  `electron/resources/app.asar`\n\n## Other Questions\nQ: **Electron 是怎么读取 asar 文件的？**\nA：Electron 中使用了其自定义的 `fs` `require` 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。\n\nQ：**如何获取 asar 文件的属性？**\nA：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 `original-fs` 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。\n\nQ：**如何解包 asar 文件？**\nA：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：\n\n```shell\n$: asar extract app.asar dest_path\n```\n\n更多的 asar 工具命令，可以通过 `asar --help` 命令查看。\n\nEnjoy it.\n","slug":"Electron-asar-格式详解","published":1,"updated":"2022-02-23T13:14:20.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5ha0003rv059rlz6lmc","content":"<h2 id=\"What-is-asar\"><a href=\"#What-is-asar\" class=\"headerlink\" title=\"What is asar?\"></a>What is asar?</h2><p><a href=\"https://github.com/electron/asar\">asar</a> —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 <a href=\"https://github.com/electron-userland/electron-packager\">Electron Packager</a> 或者 <a href=\"https://github.com/electron-userland/electron-builder\">Electron Builder</a> 等构建工具时，都会默认开启 .asar 归档模式。</p>\n<p>asar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>   <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t\t\t<span class=\"hljs-comment\">// 文件结构起始位置</span><br>      <span class=\"hljs-attr\">&quot;tmp&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t\t<span class=\"hljs-comment\">// 其中包含了一个 tmp 文件夹</span><br>         <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><span class=\"hljs-punctuation\">&#125;</span><br>      <span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br>      <span class=\"hljs-attr\">&quot;usr&quot;</span> <span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t\t<span class=\"hljs-comment\">// 其中包含了一个 files 文件夹</span><br>         <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>           <span class=\"hljs-attr\">&quot;bin&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t<span class=\"hljs-comment\">// files 文件夹中存在 bin 文件夹</span><br>             <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>               <span class=\"hljs-attr\">&quot;ls&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t<span class=\"hljs-comment\">// bin 文件夹有一个 ls 文件</span><br>                 <span class=\"hljs-attr\">&quot;offset&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;0&quot;</span><span class=\"hljs-punctuation\">,</span>\t<span class=\"hljs-comment\">// 文件起始位置 为 0</span><br>                 <span class=\"hljs-attr\">&quot;size&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">100</span><span class=\"hljs-punctuation\">,</span>\t\t<span class=\"hljs-comment\">// 文件大小是 100</span><br>                 <span class=\"hljs-attr\">&quot;executable&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span>\t<span class=\"hljs-comment\">// 该文件可以被执行</span><br>               <span class=\"hljs-punctuation\">&#125;</span><br>             <span class=\"hljs-punctuation\">&#125;</span><br>           <span class=\"hljs-punctuation\">&#125;</span><br>         <span class=\"hljs-punctuation\">&#125;</span><br>      <span class=\"hljs-punctuation\">&#125;</span><br>   <span class=\"hljs-punctuation\">&#125;</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。</p>\n<h2 id=\"Why-use-it\"><a href=\"#Why-use-it\" class=\"headerlink\" title=\"Why use it?\"></a>Why use it?</h2><p>在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。</p>\n<p>除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。</p>\n<p>最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 <a href=\"http://lisperator.net/uglifyjs/\">UglifyJS</a> 等代码混淆工具。</p>\n<h2 id=\"How-do-use-it\"><a href=\"#How-do-use-it\" class=\"headerlink\" title=\"How do use it?\"></a>How do use it?</h2><p>首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。</p>\n<p>全局安装 asar，或者通过 npx 命令执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\"># 全局安装 asar<br>$: npm install -g asar<br></code></pre></td></tr></table></figure>\n\n<p>使用 asar 打包资源文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">$: asar pack your-app-resource-folder app.asar<br></code></pre></td></tr></table></figure>\n\n<p>将打包资源放到指定路径：<br>    macOS 中默认放入  <code>electron/Electron.app/Contents/Resources/app.asar</code><br>    Windows 和 Linux 默认放入  <code>electron/resources/app.asar</code></p>\n<h2 id=\"Other-Questions\"><a href=\"#Other-Questions\" class=\"headerlink\" title=\"Other Questions\"></a>Other Questions</h2><p>Q: <strong>Electron 是怎么读取 asar 文件的？</strong><br>A：Electron 中使用了其自定义的 <code>fs</code> <code>require</code> 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。</p>\n<p>Q：<strong>如何获取 asar 文件的属性？</strong><br>A：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 <code>original-fs</code> 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。</p>\n<p>Q：<strong>如何解包 asar 文件？</strong><br>A：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: asar extract app.asar dest_path</span><br></code></pre></td></tr></table></figure>\n\n<p>更多的 asar 工具命令，可以通过 <code>asar --help</code> 命令查看。</p>\n<p>Enjoy it.</p>\n","site":{"data":{}},"excerpt":"What is asar?\nasar —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:) Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 Electron ","more":"<h2 id=\"What-is-asar\"><a href=\"#What-is-asar\" class=\"headerlink\" title=\"What is asar?\"></a>What is asar?</h2><p><a href=\"https://github.com/electron/asar\">asar</a> —— 官方并没有明确给出简称的来源，笔者个人认为是 A Simple Archive，实际上，文档中也着重表达了这个格式只是属于简单的文件归档，因此笔者认为这个称呼也是挺合理的。:)  Electron 中提供了这个格式，在构建应用时将执行资源打包到一个 .asar 文件中，应用启动执行时直接访问 .asar 文件内部资源获取执行代码。在使用 <a href=\"https://github.com/electron-userland/electron-packager\">Electron Packager</a> 或者 <a href=\"https://github.com/electron-userland/electron-builder\">Electron Builder</a> 等构建工具时，都会默认开启 .asar 归档模式。</p>\n<p>asar 属于一种将多个文件打包合并的文件，类似于 Linux 中的 tar 格式文件，Windows 中的 zip, rar 格式文件，然而不同于上面类比的格式，asar 属于无压缩类型的，也没有经过加密处理的，所有包含的文件的二进制数据都直接添加到 .asar 文件中，该文件头部包含一个 JSON 格式的字符串，记录其中包含的文件结构以及所有文件的起始位置以及文件长度：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>   <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t\t\t<span class=\"hljs-comment\">// 文件结构起始位置</span><br>      <span class=\"hljs-attr\">&quot;tmp&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t\t<span class=\"hljs-comment\">// 其中包含了一个 tmp 文件夹</span><br>         <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><span class=\"hljs-punctuation\">&#125;</span><br>      <span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br>      <span class=\"hljs-attr\">&quot;usr&quot;</span> <span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t\t<span class=\"hljs-comment\">// 其中包含了一个 files 文件夹</span><br>         <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>           <span class=\"hljs-attr\">&quot;bin&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t\t<span class=\"hljs-comment\">// files 文件夹中存在 bin 文件夹</span><br>             <span class=\"hljs-attr\">&quot;files&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>               <span class=\"hljs-attr\">&quot;ls&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span>\t<span class=\"hljs-comment\">// bin 文件夹有一个 ls 文件</span><br>                 <span class=\"hljs-attr\">&quot;offset&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;0&quot;</span><span class=\"hljs-punctuation\">,</span>\t<span class=\"hljs-comment\">// 文件起始位置 为 0</span><br>                 <span class=\"hljs-attr\">&quot;size&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">100</span><span class=\"hljs-punctuation\">,</span>\t\t<span class=\"hljs-comment\">// 文件大小是 100</span><br>                 <span class=\"hljs-attr\">&quot;executable&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span>\t<span class=\"hljs-comment\">// 该文件可以被执行</span><br>               <span class=\"hljs-punctuation\">&#125;</span><br>             <span class=\"hljs-punctuation\">&#125;</span><br>           <span class=\"hljs-punctuation\">&#125;</span><br>         <span class=\"hljs-punctuation\">&#125;</span><br>      <span class=\"hljs-punctuation\">&#125;</span><br>   <span class=\"hljs-punctuation\">&#125;</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过这个 JSON 头部的字符串能够完全解析出 .asar 中包含的文件以及目录结构等信息。</p>\n<h2 id=\"Why-use-it\"><a href=\"#Why-use-it\" class=\"headerlink\" title=\"Why use it?\"></a>Why use it?</h2><p>在 Windows 系统中，文件路径默认使用 256 位的字符串存储，因此在资源文件路径过深，或者资源父级文件夹名过长的情况下，就会出现资源访问失败的问题。当然这个问题能够通过修改系统注册列表去增加文件路径的长度，可是作为一个应用程序需要用户修改系统设置才能正常使用，这个是极其不合理的。因此 Electron 提出了将所有执行资源归档到一个 .asar 文件中的解决方案，.asar 文件会保留原来资源的层级结构，逻辑代码既能够无需额外修改，也能解决 Windows 中可能出现层级过深导致的执行失败问题。</p>\n<p>除此之外，引入 .asar 格式能加快 require 访问的速度。原因是，如果使用的是独立的文件，在 require 中需要根据路径访问文件系统中对应的位置，然后在从磁盘中读取其中的内容，而 .asar 只需要根据文件路径获取到文件的偏移位置 offset 以及文件长度 size，就可以直接从其中获取文件的具体信息。一来只需要保持一个文件的读状态，无需同时读取多个文件，二来还能加快其访问速度。</p>\n<p>最后一点，文档中也提到，引入 .asar 文件，能够隐藏项目开发的源代码。然而笔者认为，这个打包归档对于隐藏项目代码没有任何作用，正如前文所说，asar 属于无压缩无加密的归档类型，有意解包者能轻松导出获取其中的内容。对于隐藏项目代码，建议还是使用 <a href=\"http://lisperator.net/uglifyjs/\">UglifyJS</a> 等代码混淆工具。</p>\n<h2 id=\"How-do-use-it\"><a href=\"#How-do-use-it\" class=\"headerlink\" title=\"How do use it?\"></a>How do use it?</h2><p>首先一点，建议通过 Electron-Builder 或者 Electron-Packager 等构建工具，开箱即用，相当方便。</p>\n<p>全局安装 asar，或者通过 npx 命令执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\"># 全局安装 asar<br>$: npm install -g asar<br></code></pre></td></tr></table></figure>\n\n<p>使用 asar 打包资源文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">$: asar pack your-app-resource-folder app.asar<br></code></pre></td></tr></table></figure>\n\n<p>将打包资源放到指定路径：<br>    macOS 中默认放入  <code>electron/Electron.app/Contents/Resources/app.asar</code><br>    Windows 和 Linux 默认放入  <code>electron/resources/app.asar</code></p>\n<h2 id=\"Other-Questions\"><a href=\"#Other-Questions\" class=\"headerlink\" title=\"Other Questions\"></a>Other Questions</h2><p>Q: <strong>Electron 是怎么读取 asar 文件的？</strong><br>A：Electron 中使用了其自定义的 <code>fs</code> <code>require</code> 等模块，在遇到 asar 文件时，会自动将其解析成一个虚拟的文件夹，然后直接获取其中的文件内容。</p>\n<p>Q：<strong>如何获取 asar 文件的属性？</strong><br>A：可能在运行过程中，会遇到需要获取 asar 文件属性需求（如计算 app.asar MD5 值，确保应用程序没有被他人篡改）时，需要忽略 asar 虚拟文件夹的功能，这个时候可以引入 <code>original-fs</code> 模块，该模块是 node.js 中原生的模块，对于 asar 没有提供额外的解析功能。</p>\n<p>Q：<strong>如何解包 asar 文件？</strong><br>A：解包 asar 可以分析 Electron 应用中的打包资源，可以查处应用包含了哪些不需要引入的资源，减少应用包的大小。解包操作同样是通过全局安装的 asar 工具即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"language-bash\">: asar extract app.asar dest_path</span><br></code></pre></td></tr></table></figure>\n\n<p>更多的 asar 工具命令，可以通过 <code>asar --help</code> 命令查看。</p>\n<p>Enjoy it.</p>\n"},{"title":"Electron 进程间通讯详解","date":"2019-06-30T04:46:09.000Z","_content":"## Electron 应用架构\nElectron 不同于其他应用的架构，它存在两种进程类型，分别为**主进程**、**渲染进程**，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。\n\n![ElectronProcesses.png](https://cdn.iguan7u.cn/image/ElectronProcesses.png)\n\n### 主进程\nElectron 运行 `package.json` 中的 `main` 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。\n通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。\n主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。\n\n### 渲染进程\nElectron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 `BrowserWindow` 。当主进程每创建一个独立 `BrowserWindow` 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。\n\n## Electron 进程间通讯方式\n在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用**进程间通讯**方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：\n\n- **LocalStorage, window.postMessage**\n在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。\n\n- **IPC (Inner-Process Communication)**\nElectron 中提供了 `ipcRender` 、`ipcMain` 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 [IPC](https://www.chromium.org/developers/design-documents/inter-process-communication) ，能够提供更高的效率以及安全性。\n\n主进程代码：\n```javascript\nconst ipc = require('electron').ipcMain\nipc.on('getMsg', (event, msg) => {\n  console.log(msg)     // You sended a message to main thread.\n})\n```\n\n渲染进程代码：\n```javascript\nconst ipc = require('electron').ipcRenderer\nipc.send('getMsg', 'You sended a message to main thread.')\n```\n\n可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。\n\n- **Remote**\nRemote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 [RMI](https://en.wikipedia.org/wiki/Java_remote_method_invocation)，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。\n\n渲染进程调用主进程模块：\n```javascript\nconst { BrowserWindow } = require('electron').remote\nlet win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('https://github.com')\n```\n\n天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。\nRemote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。\n\n## 进程间通讯问题\n![WeDriveStruct.png](https://cdn.iguan7u.cn/image/WeDriveStruct.png)\n\n在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：\n\n### 1. 应用程序为何会出现卡顿？\n\n随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。\n我们在应用中增加了 `console.time` 以及 `console.timeEnd` 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：\n\n> 在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 `JSON.stringify` 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。  \n> 附上 [测试 demo 代码](https://github.com/iGuan7u/ElectronRemoteBlockDemo)  \n\n![ElectronBlock](https://cdn.iguan7u.cn/image/ElectronTest.gif)\n\n通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 `JSON.stringify` 方法打印完成后，页面的数字才正常的继续更新。\n由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。\n\n### 原因\n\n可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 [官方文档中](https://electronjs.org/docs/api/remote) 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：\n\n> remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送**同步**进程消息。  \n\n那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote [源码](https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js) 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 `remote.getGlobal` 方法为例：\n\nremote.js\n```javascript\n/* Get a global object in browser. */\nexports.getGlobal = (name) => {\n  const command = 'ELECTRON_BROWSER_GLOBAL'\n  const meta = ipcRendererInternal.sendSync(command, contextId, name)\n  return metaToValue(meta)\n}\n```\n\nrpc-server.js\n```javascript\nhandleRemoteCommand('ELECTRON_BROWSER_GLOBAL', function (event, contextId, globalName) {\n  const customEvent = eventBinding.createWithSender(event.sender)\n  event.sender.emit('remote-get-global', customEvent, globalName)\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getGlobal('${globalName}')`)\n    } else {\n      customEvent.returnValue = global[globalName]\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue)\n})\n```\n\nremote 使用一个内部的 ipc 通道 `ipcRendererInternal` 进行通讯，在调用 getGlobal 时，发送一个 `ELECTRON_BROWSER_GLOBAL` 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。\n在源码中我们发现，remote 模块是通过调用 `ipcRendererInternal` 中的 `sendSync` 方法，同步获取主进程中的对象。而其中的 `sendSync` 方法，我们可以从官方文档中查询到：\n\n> **注意:** 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  \n\n![RemoteCommunicate.png](https://cdn.iguan7u.cn/image/RemoteCommunicate.png)\n\n到这里，我们可以确定 `sendSync` 方法正是导致渲染进程卡顿的罪魁祸首。\n\n其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1/3 秒的时间。\n\n### 2. 应用程序为何会卡顿这么长时间？\n\n由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1/3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？\n\n我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。\n\n我们再细看官方文档中的 remote 模块介绍，其中提到：\n\n> Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  \n\n在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。\n\n### 原因\n\n我们细看一下 remote 中 `metaToValue `方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的**镜像对象**，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。\n\n```javascript\n// Convert meta data from browser into real value.\nfunction metaToValue (meta) {\n\t// diffent types of value should use different methods\n  const types = {\n    value: () => meta.value,\n    array: () => meta.members.map((member) => metaToValue(member)),\n    buffer: () => bufferUtils.metaToBuffer(meta.value),\n    promise: () => resolvePromise({ then: metaToValue(meta.then) }),\n    error: () => metaToPlainObject(meta),\n    date: () => new Date(meta.value),\n    exception: () => { throw errorUtils.deserialize(meta.value) }\n  }\n\n  if (meta.type in types) {\n    return types[meta.type]()\n  } else {\n    let ret\n    // get remote object from the cache\n    ...\n\n    // A shadow class to represent the remote function object.\n    if (meta.type === 'function') {\n      const remoteFunction = function (...args) {\n        let command\n        ...\n        const obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))\n        return metaToValue(obj)\n      }\n      ret = remoteFunction\n    } else {\n      ret = {}\n    }\n\n    setObjectMembers(ret, ret, meta.id, meta.members)\n    setObjectPrototype(ret, ret, meta.id, meta.proto)\n    Object.defineProperty(ret.constructor, 'name', { value: meta.name })\n\n    // Track delegate obj's lifetime & tell browser to clean up when object is GCed.\n    ...\n\n    // set remote object in cache\n    remoteObjectCache.set(meta.id, ret)\n    return ret\n  }\n}\n\n```\n\n![RemoteObject.png](https://cdn.iguan7u.cn/image/RemoteObject.png)\n\n我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 `ipcRendererInternal.sendSync` 同步通知主进程中，根据其中的隐藏字段 `atomId` 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 `event.returnValue` 返回数据。其内部实现与 remote 执行远程方法基本一致。\n\n所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 `sendSync` 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。\n\n### 3. 那我是否不使用 Remote 就好？\n\n上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。\n在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 `blockTheMainProcess` 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：\n```javascript\nfunction blockTheMainProcess() {\n  console.log('now start block the main process')\n  while(1) {\n    // block main process\n  }\n}\n```\n\n（由于录屏无法正常记录鼠标状态，请读者自行测试）\n\n我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。\n\n### 原因\n\n在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。\n\n![ElectronSendSync.png](https://cdn.iguan7u.cn/image/electron-sendSync.png)\n\n通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC `sendSync` 的方法，而这些方法每一个都可能导致渲染进程无法响应。\n\n## 解决方案\nElectron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。\n\n- **在频繁访问的方法建议使用 ipcRenderer/ipcMain 进行通讯**\n由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。\n\n- **不要在主进程中进行 CPU 密集型操作**\n主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。\n\n- **Remote 调用的主进程方法尽量设计为 aync 方法**\n上述提到，因为 remote 底层使用的是 `sendSync` 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。\n\n- **需要调用 remote 的主进程方法，不要返回大量数据**\n上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种**镜像**的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。\n在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 `then` 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。\n因此大量数据的获取我们推荐使用 ipcRenderer/ipcMain 进行获取。\n\n## 进一步的解决方案 —— “架空”主进程\n在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？\n在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。\n\n### worker_threads\n\n其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：\n\n> 在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  \n\n### cluster\n\ncluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。\n\n### child_process\n\n我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。\n\n\n## 总结\nElectron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。\n\n#blog\n","source":"_posts/Electron-进程间通讯详解.md","raw":"---\ntitle: Electron 进程间通讯详解\ndate: 2019-06-30 12:46:09\ntags:\n---\n## Electron 应用架构\nElectron 不同于其他应用的架构，它存在两种进程类型，分别为**主进程**、**渲染进程**，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。\n\n![ElectronProcesses.png](https://cdn.iguan7u.cn/image/ElectronProcesses.png)\n\n### 主进程\nElectron 运行 `package.json` 中的 `main` 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。\n通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。\n主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。\n\n### 渲染进程\nElectron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 `BrowserWindow` 。当主进程每创建一个独立 `BrowserWindow` 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。\n\n## Electron 进程间通讯方式\n在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用**进程间通讯**方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：\n\n- **LocalStorage, window.postMessage**\n在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。\n\n- **IPC (Inner-Process Communication)**\nElectron 中提供了 `ipcRender` 、`ipcMain` 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 [IPC](https://www.chromium.org/developers/design-documents/inter-process-communication) ，能够提供更高的效率以及安全性。\n\n主进程代码：\n```javascript\nconst ipc = require('electron').ipcMain\nipc.on('getMsg', (event, msg) => {\n  console.log(msg)     // You sended a message to main thread.\n})\n```\n\n渲染进程代码：\n```javascript\nconst ipc = require('electron').ipcRenderer\nipc.send('getMsg', 'You sended a message to main thread.')\n```\n\n可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。\n\n- **Remote**\nRemote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 [RMI](https://en.wikipedia.org/wiki/Java_remote_method_invocation)，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。\n\n渲染进程调用主进程模块：\n```javascript\nconst { BrowserWindow } = require('electron').remote\nlet win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('https://github.com')\n```\n\n天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。\nRemote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。\n\n## 进程间通讯问题\n![WeDriveStruct.png](https://cdn.iguan7u.cn/image/WeDriveStruct.png)\n\n在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：\n\n### 1. 应用程序为何会出现卡顿？\n\n随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。\n我们在应用中增加了 `console.time` 以及 `console.timeEnd` 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：\n\n> 在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 `JSON.stringify` 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。  \n> 附上 [测试 demo 代码](https://github.com/iGuan7u/ElectronRemoteBlockDemo)  \n\n![ElectronBlock](https://cdn.iguan7u.cn/image/ElectronTest.gif)\n\n通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 `JSON.stringify` 方法打印完成后，页面的数字才正常的继续更新。\n由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。\n\n### 原因\n\n可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 [官方文档中](https://electronjs.org/docs/api/remote) 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：\n\n> remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送**同步**进程消息。  \n\n那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote [源码](https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js) 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 `remote.getGlobal` 方法为例：\n\nremote.js\n```javascript\n/* Get a global object in browser. */\nexports.getGlobal = (name) => {\n  const command = 'ELECTRON_BROWSER_GLOBAL'\n  const meta = ipcRendererInternal.sendSync(command, contextId, name)\n  return metaToValue(meta)\n}\n```\n\nrpc-server.js\n```javascript\nhandleRemoteCommand('ELECTRON_BROWSER_GLOBAL', function (event, contextId, globalName) {\n  const customEvent = eventBinding.createWithSender(event.sender)\n  event.sender.emit('remote-get-global', customEvent, globalName)\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getGlobal('${globalName}')`)\n    } else {\n      customEvent.returnValue = global[globalName]\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue)\n})\n```\n\nremote 使用一个内部的 ipc 通道 `ipcRendererInternal` 进行通讯，在调用 getGlobal 时，发送一个 `ELECTRON_BROWSER_GLOBAL` 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。\n在源码中我们发现，remote 模块是通过调用 `ipcRendererInternal` 中的 `sendSync` 方法，同步获取主进程中的对象。而其中的 `sendSync` 方法，我们可以从官方文档中查询到：\n\n> **注意:** 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  \n\n![RemoteCommunicate.png](https://cdn.iguan7u.cn/image/RemoteCommunicate.png)\n\n到这里，我们可以确定 `sendSync` 方法正是导致渲染进程卡顿的罪魁祸首。\n\n其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1/3 秒的时间。\n\n### 2. 应用程序为何会卡顿这么长时间？\n\n由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1/3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？\n\n我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。\n\n我们再细看官方文档中的 remote 模块介绍，其中提到：\n\n> Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  \n\n在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。\n\n### 原因\n\n我们细看一下 remote 中 `metaToValue `方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的**镜像对象**，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。\n\n```javascript\n// Convert meta data from browser into real value.\nfunction metaToValue (meta) {\n\t// diffent types of value should use different methods\n  const types = {\n    value: () => meta.value,\n    array: () => meta.members.map((member) => metaToValue(member)),\n    buffer: () => bufferUtils.metaToBuffer(meta.value),\n    promise: () => resolvePromise({ then: metaToValue(meta.then) }),\n    error: () => metaToPlainObject(meta),\n    date: () => new Date(meta.value),\n    exception: () => { throw errorUtils.deserialize(meta.value) }\n  }\n\n  if (meta.type in types) {\n    return types[meta.type]()\n  } else {\n    let ret\n    // get remote object from the cache\n    ...\n\n    // A shadow class to represent the remote function object.\n    if (meta.type === 'function') {\n      const remoteFunction = function (...args) {\n        let command\n        ...\n        const obj = ipcRendererInternal.sendSync(command, contextId, meta.id, wrapArgs(args))\n        return metaToValue(obj)\n      }\n      ret = remoteFunction\n    } else {\n      ret = {}\n    }\n\n    setObjectMembers(ret, ret, meta.id, meta.members)\n    setObjectPrototype(ret, ret, meta.id, meta.proto)\n    Object.defineProperty(ret.constructor, 'name', { value: meta.name })\n\n    // Track delegate obj's lifetime & tell browser to clean up when object is GCed.\n    ...\n\n    // set remote object in cache\n    remoteObjectCache.set(meta.id, ret)\n    return ret\n  }\n}\n\n```\n\n![RemoteObject.png](https://cdn.iguan7u.cn/image/RemoteObject.png)\n\n我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 `ipcRendererInternal.sendSync` 同步通知主进程中，根据其中的隐藏字段 `atomId` 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 `event.returnValue` 返回数据。其内部实现与 remote 执行远程方法基本一致。\n\n所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 `sendSync` 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。\n\n### 3. 那我是否不使用 Remote 就好？\n\n上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。\n在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 `blockTheMainProcess` 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：\n```javascript\nfunction blockTheMainProcess() {\n  console.log('now start block the main process')\n  while(1) {\n    // block main process\n  }\n}\n```\n\n（由于录屏无法正常记录鼠标状态，请读者自行测试）\n\n我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。\n\n### 原因\n\n在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。\n\n![ElectronSendSync.png](https://cdn.iguan7u.cn/image/electron-sendSync.png)\n\n通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC `sendSync` 的方法，而这些方法每一个都可能导致渲染进程无法响应。\n\n## 解决方案\nElectron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。\n\n- **在频繁访问的方法建议使用 ipcRenderer/ipcMain 进行通讯**\n由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。\n\n- **不要在主进程中进行 CPU 密集型操作**\n主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。\n\n- **Remote 调用的主进程方法尽量设计为 aync 方法**\n上述提到，因为 remote 底层使用的是 `sendSync` 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。\n\n- **需要调用 remote 的主进程方法，不要返回大量数据**\n上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种**镜像**的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。\n在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 `then` 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。\n因此大量数据的获取我们推荐使用 ipcRenderer/ipcMain 进行获取。\n\n## 进一步的解决方案 —— “架空”主进程\n在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？\n在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。\n\n### worker_threads\n\n其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：\n\n> 在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  \n\n### cluster\n\ncluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。\n\n### child_process\n\n我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。\n\n\n## 总结\nElectron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。\n\n#blog\n","slug":"Electron-进程间通讯详解","published":1,"updated":"2022-02-23T13:14:20.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hb0005rv0520tyhqqc","content":"<h2 id=\"Electron-应用架构\"><a href=\"#Electron-应用架构\" class=\"headerlink\" title=\"Electron 应用架构\"></a>Electron 应用架构</h2><p>Electron 不同于其他应用的架构，它存在两种进程类型，分别为<strong>主进程</strong>、<strong>渲染进程</strong>，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronProcesses.png\" alt=\"ElectronProcesses.png\"></p>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程\"></a>主进程</h3><p>Electron 运行 <code>package.json</code> 中的 <code>main</code> 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。<br>通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。<br>主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。</p>\n<h3 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h3><p>Electron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 <code>BrowserWindow</code> 。当主进程每创建一个独立 <code>BrowserWindow</code> 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。</p>\n<h2 id=\"Electron-进程间通讯方式\"><a href=\"#Electron-进程间通讯方式\" class=\"headerlink\" title=\"Electron 进程间通讯方式\"></a>Electron 进程间通讯方式</h2><p>在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用<strong>进程间通讯</strong>方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：</p>\n<ul>\n<li><p><strong>LocalStorage, window.postMessage</strong><br>在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。</p>\n</li>\n<li><p><strong>IPC (Inner-Process Communication)</strong><br>Electron 中提供了 <code>ipcRender</code> 、<code>ipcMain</code> 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 <a href=\"https://www.chromium.org/developers/design-documents/inter-process-communication\">IPC</a> ，能够提供更高的效率以及安全性。</p>\n</li>\n</ul>\n<p>主进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ipc = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>).<span class=\"hljs-property\">ipcMain</span><br>ipc.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;getMsg&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event, msg</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(msg)     <span class=\"hljs-comment\">// You sended a message to main thread.</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>渲染进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ipc = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>).<span class=\"hljs-property\">ipcRenderer</span><br>ipc.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;getMsg&#x27;</span>, <span class=\"hljs-string\">&#x27;You sended a message to main thread.&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。</p>\n<ul>\n<li><strong>Remote</strong><br>Remote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 <a href=\"https://en.wikipedia.org/wiki/Java_remote_method_invocation\">RMI</a>，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。</li>\n</ul>\n<p>渲染进程调用主进程模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">BrowserWindow</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>).<span class=\"hljs-property\">remote</span><br><span class=\"hljs-keyword\">let</span> win = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BrowserWindow</span>(&#123; <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">800</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">600</span> &#125;)<br>win.<span class=\"hljs-title function_\">loadURL</span>(<span class=\"hljs-string\">&#x27;https://github.com&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。<br>Remote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。</p>\n<h2 id=\"进程间通讯问题\"><a href=\"#进程间通讯问题\" class=\"headerlink\" title=\"进程间通讯问题\"></a>进程间通讯问题</h2><p><img src=\"https://cdn.iguan7u.cn/image/WeDriveStruct.png\" alt=\"WeDriveStruct.png\"></p>\n<p>在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：</p>\n<h3 id=\"1-应用程序为何会出现卡顿？\"><a href=\"#1-应用程序为何会出现卡顿？\" class=\"headerlink\" title=\"1. 应用程序为何会出现卡顿？\"></a>1. 应用程序为何会出现卡顿？</h3><p>随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。<br>我们在应用中增加了 <code>console.time</code> 以及 <code>console.timeEnd</code> 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：</p>\n<blockquote>\n<p>在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 <code>JSON.stringify</code> 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。<br>附上 <a href=\"https://github.com/iGuan7u/ElectronRemoteBlockDemo\">测试 demo 代码</a>  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronTest.gif\" alt=\"ElectronBlock\"></p>\n<p>通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 <code>JSON.stringify</code> 方法打印完成后，页面的数字才正常的继续更新。<br>由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 <a href=\"https://electronjs.org/docs/api/remote\">官方文档中</a> 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：</p>\n<blockquote>\n<p>remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送<strong>同步</strong>进程消息。  </p>\n</blockquote>\n<p>那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote <a href=\"https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js\">源码</a> 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 <code>remote.getGlobal</code> 方法为例：</p>\n<p>remote.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* Get a global object in browser. */</span><br><span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">getGlobal</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> command = <span class=\"hljs-string\">&#x27;ELECTRON_BROWSER_GLOBAL&#x27;</span><br>  <span class=\"hljs-keyword\">const</span> meta = ipcRendererInternal.<span class=\"hljs-title function_\">sendSync</span>(command, contextId, name)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">metaToValue</span>(meta)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>rpc-server.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">handleRemoteCommand</span>(<span class=\"hljs-string\">&#x27;ELECTRON_BROWSER_GLOBAL&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event, contextId, globalName</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> customEvent = eventBinding.<span class=\"hljs-title function_\">createWithSender</span>(event.<span class=\"hljs-property\">sender</span>)<br>  event.<span class=\"hljs-property\">sender</span>.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;remote-get-global&#x27;</span>, customEvent, globalName)<br><br>  <span class=\"hljs-keyword\">if</span> (customEvent.<span class=\"hljs-property\">returnValue</span> === <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (customEvent.<span class=\"hljs-property\">defaultPrevented</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Blocked remote.getGlobal(&#x27;<span class=\"hljs-subst\">$&#123;globalName&#125;</span>&#x27;)`</span>)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      customEvent.<span class=\"hljs-property\">returnValue</span> = <span class=\"hljs-variable language_\">global</span>[globalName]<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">valueToMeta</span>(event.<span class=\"hljs-property\">sender</span>, contextId, customEvent.<span class=\"hljs-property\">returnValue</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>remote 使用一个内部的 ipc 通道 <code>ipcRendererInternal</code> 进行通讯，在调用 getGlobal 时，发送一个 <code>ELECTRON_BROWSER_GLOBAL</code> 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。<br>在源码中我们发现，remote 模块是通过调用 <code>ipcRendererInternal</code> 中的 <code>sendSync</code> 方法，同步获取主进程中的对象。而其中的 <code>sendSync</code> 方法，我们可以从官方文档中查询到：</p>\n<blockquote>\n<p><strong>注意:</strong> 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteCommunicate.png\" alt=\"RemoteCommunicate.png\"></p>\n<p>到这里，我们可以确定 <code>sendSync</code> 方法正是导致渲染进程卡顿的罪魁祸首。</p>\n<p>其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1&#x2F;3 秒的时间。</p>\n<h3 id=\"2-应用程序为何会卡顿这么长时间？\"><a href=\"#2-应用程序为何会卡顿这么长时间？\" class=\"headerlink\" title=\"2. 应用程序为何会卡顿这么长时间？\"></a>2. 应用程序为何会卡顿这么长时间？</h3><p>由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1&#x2F;3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？</p>\n<p>我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。</p>\n<p>我们再细看官方文档中的 remote 模块介绍，其中提到：</p>\n<blockquote>\n<p>Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  </p>\n</blockquote>\n<p>在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。</p>\n<h3 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>我们细看一下 remote 中 <code>metaToValue </code>方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的<strong>镜像对象</strong>，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Convert meta data from browser into real value.</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">metaToValue</span> (meta) &#123;<br>\t<span class=\"hljs-comment\">// diffent types of value should use different methods</span><br>  <span class=\"hljs-keyword\">const</span> types = &#123;<br>    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-function\">() =&gt;</span> meta.<span class=\"hljs-property\">value</span>,<br>    <span class=\"hljs-attr\">array</span>: <span class=\"hljs-function\">() =&gt;</span> meta.<span class=\"hljs-property\">members</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">member</span>) =&gt;</span> <span class=\"hljs-title function_\">metaToValue</span>(member)),<br>    <span class=\"hljs-attr\">buffer</span>: <span class=\"hljs-function\">() =&gt;</span> bufferUtils.<span class=\"hljs-title function_\">metaToBuffer</span>(meta.<span class=\"hljs-property\">value</span>),<br>    <span class=\"hljs-attr\">promise</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolvePromise</span>(&#123; <span class=\"hljs-attr\">then</span>: <span class=\"hljs-title function_\">metaToValue</span>(meta.<span class=\"hljs-property\">then</span>) &#125;),<br>    <span class=\"hljs-attr\">error</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">metaToPlainObject</span>(meta),<br>    <span class=\"hljs-attr\">date</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(meta.<span class=\"hljs-property\">value</span>),<br>    <span class=\"hljs-attr\">exception</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-keyword\">throw</span> errorUtils.<span class=\"hljs-title function_\">deserialize</span>(meta.<span class=\"hljs-property\">value</span>) &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">if</span> (meta.<span class=\"hljs-property\">type</span> <span class=\"hljs-keyword\">in</span> types) &#123;<br>    <span class=\"hljs-keyword\">return</span> types[meta.<span class=\"hljs-property\">type</span>]()<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> ret<br>    <span class=\"hljs-comment\">// get remote object from the cache</span><br>    ...<br><br>    <span class=\"hljs-comment\">// A shadow class to represent the remote function object.</span><br>    <span class=\"hljs-keyword\">if</span> (meta.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">const</span> remoteFunction = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> command<br>        ...<br>        <span class=\"hljs-keyword\">const</span> obj = ipcRendererInternal.<span class=\"hljs-title function_\">sendSync</span>(command, contextId, meta.<span class=\"hljs-property\">id</span>, <span class=\"hljs-title function_\">wrapArgs</span>(args))<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">metaToValue</span>(obj)<br>      &#125;<br>      ret = remoteFunction<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      ret = &#123;&#125;<br>    &#125;<br><br>    <span class=\"hljs-title function_\">setObjectMembers</span>(ret, ret, meta.<span class=\"hljs-property\">id</span>, meta.<span class=\"hljs-property\">members</span>)<br>    <span class=\"hljs-title function_\">setObjectPrototype</span>(ret, ret, meta.<span class=\"hljs-property\">id</span>, meta.<span class=\"hljs-property\">proto</span>)<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(ret.<span class=\"hljs-property\">constructor</span>, <span class=\"hljs-string\">&#x27;name&#x27;</span>, &#123; <span class=\"hljs-attr\">value</span>: meta.<span class=\"hljs-property\">name</span> &#125;)<br><br>    <span class=\"hljs-comment\">// Track delegate obj&#x27;s lifetime &amp; tell browser to clean up when object is GCed.</span><br>    ...<br><br>    <span class=\"hljs-comment\">// set remote object in cache</span><br>    remoteObjectCache.<span class=\"hljs-title function_\">set</span>(meta.<span class=\"hljs-property\">id</span>, ret)<br>    <span class=\"hljs-keyword\">return</span> ret<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteObject.png\" alt=\"RemoteObject.png\"></p>\n<p>我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 <code>ipcRendererInternal.sendSync</code> 同步通知主进程中，根据其中的隐藏字段 <code>atomId</code> 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 <code>event.returnValue</code> 返回数据。其内部实现与 remote 执行远程方法基本一致。</p>\n<p>所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 <code>sendSync</code> 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。</p>\n<h3 id=\"3-那我是否不使用-Remote-就好？\"><a href=\"#3-那我是否不使用-Remote-就好？\" class=\"headerlink\" title=\"3. 那我是否不使用 Remote 就好？\"></a>3. 那我是否不使用 Remote 就好？</h3><p>上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。<br>在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 <code>blockTheMainProcess</code> 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">blockTheMainProcess</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now start block the main process&#x27;</span>)<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-comment\">// block main process</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>（由于录屏无法正常记录鼠标状态，请读者自行测试）</p>\n<p>我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。</p>\n<h3 id=\"原因-2\"><a href=\"#原因-2\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/electron-sendSync.png\" alt=\"ElectronSendSync.png\"></p>\n<p>通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC <code>sendSync</code> 的方法，而这些方法每一个都可能导致渲染进程无法响应。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Electron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。</p>\n<ul>\n<li><p><strong>在频繁访问的方法建议使用 ipcRenderer&#x2F;ipcMain 进行通讯</strong><br>由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。</p>\n</li>\n<li><p><strong>不要在主进程中进行 CPU 密集型操作</strong><br>主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。</p>\n</li>\n<li><p><strong>Remote 调用的主进程方法尽量设计为 aync 方法</strong><br>上述提到，因为 remote 底层使用的是 <code>sendSync</code> 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。</p>\n</li>\n<li><p><strong>需要调用 remote 的主进程方法，不要返回大量数据</strong><br>上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种<strong>镜像</strong>的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。<br>在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 <code>then</code> 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。<br>因此大量数据的获取我们推荐使用 ipcRenderer&#x2F;ipcMain 进行获取。</p>\n</li>\n</ul>\n<h2 id=\"进一步的解决方案-——-“架空”主进程\"><a href=\"#进一步的解决方案-——-“架空”主进程\" class=\"headerlink\" title=\"进一步的解决方案 —— “架空”主进程\"></a>进一步的解决方案 —— “架空”主进程</h2><p>在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？<br>在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。</p>\n<h3 id=\"worker-threads\"><a href=\"#worker-threads\" class=\"headerlink\" title=\"worker_threads\"></a>worker_threads</h3><p>其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：</p>\n<blockquote>\n<p>在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  </p>\n</blockquote>\n<h3 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h3><p>cluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。</p>\n<h3 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h3><p>我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Electron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。</p>\n<p>#blog</p>\n","site":{"data":{}},"excerpt":"Electron 应用架构\nElectron 不同于其他应用的架构，它存在两种进程类型，分别为主进程、渲染进程，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。\n\n\n\n主进程\nElectron 运行 package.json 中的 main 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控","more":"<h2 id=\"Electron-应用架构\"><a href=\"#Electron-应用架构\" class=\"headerlink\" title=\"Electron 应用架构\"></a>Electron 应用架构</h2><p>Electron 不同于其他应用的架构，它存在两种进程类型，分别为<strong>主进程</strong>、<strong>渲染进程</strong>，这两种进程类型在应用的生命周期中承担了截然不同的角色，深入了解它们各自的角色尤为重要。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronProcesses.png\" alt=\"ElectronProcesses.png\"></p>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程\"></a>主进程</h3><p>Electron 运行 <code>package.json</code> 中的 <code>main</code> 脚本中的进程被称为主进程，该进程在应用整个生命周期只会存在唯一一个，负责界面窗口的创建、控制、销毁等管理行为，同时也能控制整个应用的生命周期。<br>通过阅读文档以及源码我们能够发现，主进程本质上是一个 Node.js 进程，该进程充分利用了 Node.js 的跨平台特性，在其 API 的底层，抹掉了不同操作系统中的差异，为 Electron 中跨平台开发中的文件管理提供了基础。<br>主进程同时提供一套跨平台的接口，能控制各个操作系统中的原生资源，如：对话框、菜单、文件拖拽等，使得 Electron 的用户体验极大的接近了原生应用。</p>\n<h3 id=\"渲染进程\"><a href=\"#渲染进程\" class=\"headerlink\" title=\"渲染进程\"></a>渲染进程</h3><p>Electron 使用 Chromium 来展示 UI 界面，在应用程序中被称为 <code>BrowserWindow</code> 。当主进程每创建一个独立 <code>BrowserWindow</code> 实例，Electron 都会初始化一个独立的渲染进程，隔离了不同窗口之间的环境，使得每个窗口都只需要关心自己内部的 web 页面。</p>\n<h2 id=\"Electron-进程间通讯方式\"><a href=\"#Electron-进程间通讯方式\" class=\"headerlink\" title=\"Electron 进程间通讯方式\"></a>Electron 进程间通讯方式</h2><p>在计算机系统设计中，不同的进程间内存资源都是相互隔离的，因此进程间的数据交换，会使用<strong>进程间通讯</strong>方式达成。而不同于一般的原生应用开发，Electron 的渲染进程与主进程分别属于独立的进程中，而且进程间会存在频繁的数据交换，这时选择一个合理的进程间通讯方式显得尤为重要。下面是 Electron 中官方提供的进程间通讯方式：</p>\n<ul>\n<li><p><strong>LocalStorage, window.postMessage</strong><br>在前端开发中，鉴于浏览器对本地数据有严格的访问限制，所以一般通过该两种方式进行窗口间的数据通讯，该方式同样适用于 Electron 开发中。然而因为 API 设计目的仅仅是为了前端窗口间简单的数据传输，大量以及频繁的数据通讯会导致应用结构松散，同时传输效率也值得怀疑。</p>\n</li>\n<li><p><strong>IPC (Inner-Process Communication)</strong><br>Electron 中提供了 <code>ipcRender</code> 、<code>ipcMain</code> 作为主进程以及渲染进程间通讯的桥梁，该方式属于 Electron 特有传输方式，不适用于其他前端开发场景。Electron 沿用 Chromium 中的 IPC 方式，不同于 socket、http 等通讯方式，Chromium 使用的是命名管道 <a href=\"https://www.chromium.org/developers/design-documents/inter-process-communication\">IPC</a> ，能够提供更高的效率以及安全性。</p>\n</li>\n</ul>\n<p>主进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ipc = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>).<span class=\"hljs-property\">ipcMain</span><br>ipc.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;getMsg&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">event, msg</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(msg)     <span class=\"hljs-comment\">// You sended a message to main thread.</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>渲染进程代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ipc = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>).<span class=\"hljs-property\">ipcRenderer</span><br>ipc.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">&#x27;getMsg&#x27;</span>, <span class=\"hljs-string\">&#x27;You sended a message to main thread.&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>可是 IPC 的使用方式类似于通知监听，在多个模块中使用容易造成项目代码的松散，加大后期维护成本。</p>\n<ul>\n<li><strong>Remote</strong><br>Remote 模块为渲染进程和主进程通信提供了一种简单方式，该方式类似于 Java 中的 <a href=\"https://en.wikipedia.org/wiki/Java_remote_method_invocation\">RMI</a>，在渲染进程中能显式调用主进程中的模块代码，封装了底层中进程间通讯的细节，让开发者能轻松上手使用。</li>\n</ul>\n<p>渲染进程调用主进程模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">BrowserWindow</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;electron&#x27;</span>).<span class=\"hljs-property\">remote</span><br><span class=\"hljs-keyword\">let</span> win = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BrowserWindow</span>(&#123; <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">800</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">600</span> &#125;)<br>win.<span class=\"hljs-title function_\">loadURL</span>(<span class=\"hljs-string\">&#x27;https://github.com&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>天下没有免费的午餐。上手易用的方式往往伴随着其可能带来的风险。在官方文档中提到，通过 Remote 模块从主进程返回到渲染进程的对象，在主进程和渲染进程中会同时存在两份实例，其生命周期是一致的。渲染进程中该对象被一直持有，主进程中对应的对象就一直不会被销毁。因此使用不当，很可能造成严重的内存泄漏。<br>Remote 底层仍然时候 IPC 作为进程间通讯的方式，尽管在调用过程中对使用者是无感的，可是在使用过程中有必要明白其基本原理。同时 Electron 通过 hook 了渲染进程中被返回对象的 setter, getter 方法，将两个进程中对应的对象实例进行了属性绑定，在渲染进程对该对象的属性进行修改，会同时修改主进程的对应对象的属性。在这种便捷的机制下，也容易引起其他问题。我们在下文中在详细描述。</p>\n<h2 id=\"进程间通讯问题\"><a href=\"#进程间通讯问题\" class=\"headerlink\" title=\"进程间通讯问题\"></a>进程间通讯问题</h2><p><img src=\"https://cdn.iguan7u.cn/image/WeDriveStruct.png\" alt=\"WeDriveStruct.png\"></p>\n<p>在企业微信云盘项目初期，我们普遍使用 Remote 作为进程间通讯的方式，该模块正如其设计初衷一样，几乎抹掉了 Electron 应用存在两个独立进程的特点，在开发过程中几乎与单进程应用别无二致。得益于该模块，项目的开发进度一马平川。可是随着项目架构以及调试数据的进一步发展，严重的问题开始逐渐浮现：</p>\n<h3 id=\"1-应用程序为何会出现卡顿？\"><a href=\"#1-应用程序为何会出现卡顿？\" class=\"headerlink\" title=\"1. 应用程序为何会出现卡顿？\"></a>1. 应用程序为何会出现卡顿？</h3><p>随着主进程逻辑增多，数据库读取次数增加，页面开始逐渐出现了卡顿的现象，在 macOS 中甚至偶尔会出现沙滩排球的鼠标图案。这个情况逐渐引起了我们的重视，怀疑项目中的架构是否存在不合理之处。<br>我们在应用中增加了 <code>console.time</code> 以及 <code>console.timeEnd</code> 统计逻辑执行时间，发现相关数据解析、以及数据库保存读取操作并没有存在耗时很长的情况，我们很快就将目光放在了 remote 模块中。众所周知，进程间通讯往往存在不可忽视的性能损耗，而在 Electron 提供的如此便利的 rpc 方式下，是否也存在性能损耗呢？我们做了一个简单的 demo：</p>\n<blockquote>\n<p>在实验中，我们从渲染进程中通过点击按钮，触发一个调用主线程的逻辑，返回 500 个各自拥有 50 个属性的 JSON 对象，然后在渲染进程中调用 <code>JSON.stringify</code> 方法，访问从主线程中返回的 JSON 对象，记录程序运行的时间。同时在渲染进程中增加一个定时器，每隔特定的时间更新页面中的数字，检查渲染进程的运行状况。<br>附上 <a href=\"https://github.com/iGuan7u/ElectronRemoteBlockDemo\">测试 demo 代码</a>  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/ElectronTest.gif\" alt=\"ElectronBlock\"></p>\n<p>通过这个 demo 我们可以发现，在点击按钮后，渲染进程的数字出现卡顿的情况，等到 <code>JSON.stringify</code> 方法打印完成后，页面的数字才正常的继续更新。<br>由此可见，使用 remote 模块调用主进程的逻辑是，是会存在导致渲染进程卡顿的情况的发生。</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>可是究竟是 remote 模块中的哪些逻辑导致了渲染进程的卡顿呢？在 <a href=\"https://electronjs.org/docs/api/remote\">官方文档中</a> 中，并没有详细的提到 remote 模块的详细实现，同时也没有提到使用 remote 模块会导致渲染进程卡顿的问题。然后文档中略微提到了一点：</p>\n<blockquote>\n<p>remote 模块返回的每个对象 (包括函数) 表示主进程中的一个对象 (我们称它为远程对象或远程函数)。 当调用远程对象的方法时, 调用远程函数, 或者使用远程构造函数 (函数) 创建新对象时, 实际上是在发送<strong>同步</strong>进程消息。  </p>\n</blockquote>\n<p>那么，渲染进程的卡顿，是否与该同步消息有关呢？阅读 Electron 的 remote <a href=\"https://github.com/electron/electron/blob/78411db4b5c796570ee0e5eec1ef00f586e0a01d/lib/renderer/api/remote.js\">源码</a> 我们发现，remote 模块的内部，实际是也通过调用 ipc 进行进程间通讯，以 <code>remote.getGlobal</code> 方法为例：</p>\n<p>remote.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* Get a global object in browser. */</span><br><span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">getGlobal</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> command = <span class=\"hljs-string\">&#x27;ELECTRON_BROWSER_GLOBAL&#x27;</span><br>  <span class=\"hljs-keyword\">const</span> meta = ipcRendererInternal.<span class=\"hljs-title function_\">sendSync</span>(command, contextId, name)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">metaToValue</span>(meta)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>rpc-server.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">handleRemoteCommand</span>(<span class=\"hljs-string\">&#x27;ELECTRON_BROWSER_GLOBAL&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event, contextId, globalName</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> customEvent = eventBinding.<span class=\"hljs-title function_\">createWithSender</span>(event.<span class=\"hljs-property\">sender</span>)<br>  event.<span class=\"hljs-property\">sender</span>.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;remote-get-global&#x27;</span>, customEvent, globalName)<br><br>  <span class=\"hljs-keyword\">if</span> (customEvent.<span class=\"hljs-property\">returnValue</span> === <span class=\"hljs-literal\">undefined</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (customEvent.<span class=\"hljs-property\">defaultPrevented</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Blocked remote.getGlobal(&#x27;<span class=\"hljs-subst\">$&#123;globalName&#125;</span>&#x27;)`</span>)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      customEvent.<span class=\"hljs-property\">returnValue</span> = <span class=\"hljs-variable language_\">global</span>[globalName]<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">valueToMeta</span>(event.<span class=\"hljs-property\">sender</span>, contextId, customEvent.<span class=\"hljs-property\">returnValue</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>remote 使用一个内部的 ipc 通道 <code>ipcRendererInternal</code> 进行通讯，在调用 getGlobal 时，发送一个 <code>ELECTRON_BROWSER_GLOBAL</code> 的指令，主线程在接收到对应指令时，再返回 global 中的对应对象。<br>在源码中我们发现，remote 模块是通过调用 <code>ipcRendererInternal</code> 中的 <code>sendSync</code> 方法，同步获取主进程中的对象。而其中的 <code>sendSync</code> 方法，我们可以从官方文档中查询到：</p>\n<blockquote>\n<p><strong>注意:</strong> 发送同步消息将会阻塞整个渲染进程，你应该避免使用这种方式 - 除非你知道你在做什么。  </p>\n</blockquote>\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteCommunicate.png\" alt=\"RemoteCommunicate.png\"></p>\n<p>到这里，我们可以确定 <code>sendSync</code> 方法正是导致渲染进程卡顿的罪魁祸首。</p>\n<p>其实细心一点我们可以发现，在 demo 中，主进程返回数据以及渲染进程中接受回调，程序都打印了其时间戳。由此可见，在主进程返回数据时，渲染进程在 330ms 后才收到了具体的返回数据。因此可以得知，一次 remote 模块的跨进程调用，渲染进程会阻塞接近 1&#x2F;3 秒的时间。</p>\n<h3 id=\"2-应用程序为何会卡顿这么长时间？\"><a href=\"#2-应用程序为何会卡顿这么长时间？\" class=\"headerlink\" title=\"2. 应用程序为何会卡顿这么长时间？\"></a>2. 应用程序为何会卡顿这么长时间？</h3><p>由上述原因我们可以得知，在一次 remote 模块的跨进程通讯，渲染进程会卡顿 1&#x2F;3 秒，这在操作逻辑不频繁的情况下，仍是在可接受范围。可是在我们的测试 demo 中，应用程序的测试 demo 中，我们可以看到窗口阻塞了可以明显感知的时间长度，这里是否还存在其他的问题仍待进一步探究？</p>\n<p>我们回归一下测试 demo 的现象：在经过 330ms 后，渲染进程打出了返回数据后的时间戳，因此可以确定，在经过 330ms 后，渲染进程已经完成了主进程方法的调用，并且得到了该方法的返回数据。而在此之后，渲染进程依然处于阻塞的状态，控制台一直在遍历打印返回值的信息，直到信息打印完成后，也就是经过 4508ms 后，渲染进程解除了阻塞的状态，恢复更新计时器的数字。</p>\n<p>我们再细看官方文档中的 remote 模块介绍，其中提到：</p>\n<blockquote>\n<p>Electron 确保只要渲染进程中的远程对象存在（换句话说，没有被垃圾收集），主进程中的相应对象将不会被释放。 当远程对象被垃圾回收后，主进程中的相应对象将被解除引用。  </p>\n</blockquote>\n<p>在主进程返回对象后，为什么依然需要保留对象呢？因此，我们有合理的理由怀疑：在遍历 remote 模块的返回数据时候，仍然存在跨进程通讯的情况。</p>\n<h3 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>我们细看一下 remote 中 <code>metaToValue </code>方法代码，发现渲染进程在接收到 remote 模块返回的对象时并不是解析成真实的对象，而是更接近于主进程中对象的<strong>镜像对象</strong>，所有真正的 value 都是通过发送 rpc 消息到主进程中，主进程再将当前真正的值返回到渲染进程中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Convert meta data from browser into real value.</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">metaToValue</span> (meta) &#123;<br>\t<span class=\"hljs-comment\">// diffent types of value should use different methods</span><br>  <span class=\"hljs-keyword\">const</span> types = &#123;<br>    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-function\">() =&gt;</span> meta.<span class=\"hljs-property\">value</span>,<br>    <span class=\"hljs-attr\">array</span>: <span class=\"hljs-function\">() =&gt;</span> meta.<span class=\"hljs-property\">members</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">member</span>) =&gt;</span> <span class=\"hljs-title function_\">metaToValue</span>(member)),<br>    <span class=\"hljs-attr\">buffer</span>: <span class=\"hljs-function\">() =&gt;</span> bufferUtils.<span class=\"hljs-title function_\">metaToBuffer</span>(meta.<span class=\"hljs-property\">value</span>),<br>    <span class=\"hljs-attr\">promise</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolvePromise</span>(&#123; <span class=\"hljs-attr\">then</span>: <span class=\"hljs-title function_\">metaToValue</span>(meta.<span class=\"hljs-property\">then</span>) &#125;),<br>    <span class=\"hljs-attr\">error</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">metaToPlainObject</span>(meta),<br>    <span class=\"hljs-attr\">date</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(meta.<span class=\"hljs-property\">value</span>),<br>    <span class=\"hljs-attr\">exception</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-keyword\">throw</span> errorUtils.<span class=\"hljs-title function_\">deserialize</span>(meta.<span class=\"hljs-property\">value</span>) &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">if</span> (meta.<span class=\"hljs-property\">type</span> <span class=\"hljs-keyword\">in</span> types) &#123;<br>    <span class=\"hljs-keyword\">return</span> types[meta.<span class=\"hljs-property\">type</span>]()<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-keyword\">let</span> ret<br>    <span class=\"hljs-comment\">// get remote object from the cache</span><br>    ...<br><br>    <span class=\"hljs-comment\">// A shadow class to represent the remote function object.</span><br>    <span class=\"hljs-keyword\">if</span> (meta.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">const</span> remoteFunction = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>        <span class=\"hljs-keyword\">let</span> command<br>        ...<br>        <span class=\"hljs-keyword\">const</span> obj = ipcRendererInternal.<span class=\"hljs-title function_\">sendSync</span>(command, contextId, meta.<span class=\"hljs-property\">id</span>, <span class=\"hljs-title function_\">wrapArgs</span>(args))<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">metaToValue</span>(obj)<br>      &#125;<br>      ret = remoteFunction<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      ret = &#123;&#125;<br>    &#125;<br><br>    <span class=\"hljs-title function_\">setObjectMembers</span>(ret, ret, meta.<span class=\"hljs-property\">id</span>, meta.<span class=\"hljs-property\">members</span>)<br>    <span class=\"hljs-title function_\">setObjectPrototype</span>(ret, ret, meta.<span class=\"hljs-property\">id</span>, meta.<span class=\"hljs-property\">proto</span>)<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(ret.<span class=\"hljs-property\">constructor</span>, <span class=\"hljs-string\">&#x27;name&#x27;</span>, &#123; <span class=\"hljs-attr\">value</span>: meta.<span class=\"hljs-property\">name</span> &#125;)<br><br>    <span class=\"hljs-comment\">// Track delegate obj&#x27;s lifetime &amp; tell browser to clean up when object is GCed.</span><br>    ...<br><br>    <span class=\"hljs-comment\">// set remote object in cache</span><br>    remoteObjectCache.<span class=\"hljs-title function_\">set</span>(meta.<span class=\"hljs-property\">id</span>, ret)<br>    <span class=\"hljs-keyword\">return</span> ret<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.iguan7u.cn/image/RemoteObject.png\" alt=\"RemoteObject.png\"></p>\n<p>我们可以通过图理解一下，左侧是指在渲染进程中取得的 remoteObject、remoteFunction，右侧是指在主进程中对应的真实 obejct 或者 function。当渲染进程中访问其 remoteObject 中的方法或者属性时，内部都会通过 <code>ipcRendererInternal.sendSync</code> 同步通知主进程中，根据其中的隐藏字段 <code>atomId</code> 在主进程中找到对应的真实对象，获取属性值或者执行其对应方法，然后在通过 <code>event.returnValue</code> 返回数据。其内部实现与 remote 执行远程方法基本一致。</p>\n<p>所以，我们确定了渲染进程长时间卡顿，是因为我们在渲染进程中遍历 remote 对象中的属性，内部执行大量 <code>sendSync</code> 方法导致渲染进程一致处于等待状态，从而阻塞了渲染进程其他任务的执行。</p>\n<h3 id=\"3-那我是否不使用-Remote-就好？\"><a href=\"#3-那我是否不使用-Remote-就好？\" class=\"headerlink\" title=\"3. 那我是否不使用 Remote 就好？\"></a>3. 那我是否不使用 Remote 就好？</h3><p>上面所遇到的问题，都是因为业务代码中直接使用 Remote 模块导致性能收到了严重影响，那我们是否只需要改用 IPC 方式调用主进程中的逻辑就好了呢？Chromium IPC 在设计上是使用完全异步的方式，理论上不会出现上述所提及的问题，下面我们来实践一下。<br>在 demo 中，我们增加一个按钮，使用 IPC 调用主进程中 <code>blockTheMainProcess</code> 的方法，模拟主进程在进行 CPU 密集型操作，具体代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">blockTheMainProcess</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;now start block the main process&#x27;</span>)<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-comment\">// block main process</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>（由于录屏无法正常记录鼠标状态，请读者自行测试）</p>\n<p>我们发现，在点击 IPCAction 按钮后，渲染进程的计时器并没有像问题 2 中停止，可是鼠标却变成了 macOS 中应用程序无响应的 Beach Ball，因此即便在不使用 Remote 模块下，主进程的卡顿仍可能导致渲染进程无法响应用户的点击。</p>\n<h3 id=\"原因-2\"><a href=\"#原因-2\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>在操作系统设计中，不同的进程理论上是互不影响的，它们各自获取到的资源都是独立的，那么按照正常理解中，Electron 的主进程阻塞是不应该影响到渲染进程的运行的。可是渲染进程跟主进程并非真正独立的进程，它们同属于一个 Electron 应用，那么我们有合理的怀疑，在 Electron 内部，必定存在内部的进程间通讯，而且这些通讯正是导致渲染进程无法响应的罪魁祸首。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/electron-sendSync.png\" alt=\"ElectronSendSync.png\"></p>\n<p>通过搜索 Electron 源码可以发现，Electron 内部也存在的很多的模块使用了 IPC <code>sendSync</code> 的方法，而这些方法每一个都可能导致渲染进程无法响应。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>Electron 的渲染进程以及主进程在内部都使用了 chromium 中的 V8 Javascript 引擎，其执行 JS 效率已经在 node.js 中被充分地证明，因此作为原生应用， JS 执行效率应该不会成为其性能瓶颈。因此我们可以认为，访问 remoteObject 导致渲染进程卡顿执行 Electron 架构设计所限，并非不可绕过的问题。</p>\n<ul>\n<li><p><strong>在频繁访问的方法建议使用 ipcRenderer&#x2F;ipcMain 进行通讯</strong><br>由于 Electron 中 ipcRenderer 以及 ipcMain 使用的是 chroumium 中的文件句柄的方式进行跨进程数据传递，该方式在设计上采用的是完全异步的方式，同时性能对比普通的 socket 有明显的优势，因此项目中在主进程以及渲染进程中的大量使用也不会对性能有明显影响。</p>\n</li>\n<li><p><strong>不要在主进程中进行 CPU 密集型操作</strong><br>主进程是负责控制应用窗口以及整个应用程序的生命周期，并非处理业务逻辑的。在项目初期我们曾错误认为主进程是作为程序后台去使用的，因此我们将业务代码统一放到主进程中运行，一旦业务逻辑出现需要 CPU 长时间处理的，甚至会导致程序处于无响应状态。因此我们将业务逻辑都转移到了主进程 fork 出来的子进程进行处理，避免了可能出现卡顿的情况。</p>\n</li>\n<li><p><strong>Remote 调用的主进程方法尽量设计为 aync 方法</strong><br>上述提到，因为 remote 底层使用的是 <code>sendSync</code> 方法，该方法会让渲染进程一直处于阻塞状态直到主进程方法执行完成并返回数据，因此如果主进程中的方法是 IO 操作或者是 CPU 密集型的，则会导致渲染进程一直处于阻塞状态无法处理用户点击事件。而声明为 async 方法，则会让主进程方法立即返回一个 Promise 对象，无需等待方法执行完成，极大地减少了渲染进程的等待时间。</p>\n</li>\n<li><p><strong>需要调用 remote 的主进程方法，不要返回大量数据</strong><br>上述第二条问题我们描述，在使用 remote 获取主进程的数据，在渲染进程该对象会处于一种<strong>镜像</strong>的状态，所有的属性获取、变更同样需要跨进程的访问。这里并不仅限于调用主进程同步的方法，同时包括主进程 async 的方法。<br>在前一个注意点我们提到，remote 调用 async 方法虽然能立即返回 Promise 对象，无需渲染进程等待主进程方法执行完成，可是其执行完的数据仍然会通过 Promise 对象中的 <code>then</code> 方法传递执行后的数据。在该数据中，属性值仍然是使用 remote 的机制。<br>因此大量数据的获取我们推荐使用 ipcRenderer&#x2F;ipcMain 进行获取。</p>\n</li>\n</ul>\n<h2 id=\"进一步的解决方案-——-“架空”主进程\"><a href=\"#进一步的解决方案-——-“架空”主进程\" class=\"headerlink\" title=\"进一步的解决方案 —— “架空”主进程\"></a>进一步的解决方案 —— “架空”主进程</h2><p>在我们上面讨论的解决方案中，其实并不能彻底的解决进程阻塞导致的卡顿问题，随着应用规模的增长，主进程最终会承担更多的业务逻辑，而不可避免的会导致在某个场景下出现 CPU 密集型的操作。这个时候，探讨将 CPU 密集性任务分散开，是不太现实的。我们开始设想，能否 “架空” 主进程，让它闲下来呢？<br>在一般的客户端开发中，如果进程任务过于繁重，都会通过多开线程的方式减少进程阻塞的场景，而 node.js 也意识到单线程所带来的局限性，在后面的版本引入了 cluster 的功能模块，为 node.js 带来的负载均衡的子进程特性。而其后甚至在最近的 10.5.0 版本引入 worker_threads 的实验性模块，为 node.js 带来的真正的多线程。</p>\n<h3 id=\"worker-threads\"><a href=\"#worker-threads\" class=\"headerlink\" title=\"worker_threads\"></a>worker_threads</h3><p>其实作为客户端开发，worker_threads 应该是这个问题的完美解，多线程的支持让 Electron 能更加接近原生应用。可是 worker_threads 模块目前仍然在实验性阶段，官方并不推荐在生产环境中使用，甚至后期不排除将其移除。而 Electron 官方文档中提及到的多线程，也是较为模糊的态度：</p>\n<blockquote>\n<p>在 Web Workers 里可以直接加载任何原生 Node.js 模块，但不推荐这样做。 大多数现存的原生模块是在假设单线程环境的情况下编写的，如果把它们用在Web Workers 里会导致崩溃和内存损坏。  </p>\n</blockquote>\n<h3 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h3><p>cluster 为 node.js 提供了子进程的功能。使用 cluster，可以让多个子进程使用同一个端口，并且为其提供了负载均衡的特性，使得 node.js 能充分利用多核 CPU 的特性。可是在我们的目标中，我们并不是像替主进程减负，而是想彻底地让主进程闲下来。</p>\n<h3 id=\"child-process\"><a href=\"#child-process\" class=\"headerlink\" title=\"child_process\"></a>child_process</h3><p>我们最终使用了 child_process 模块。child_process 模块为 node.js 提供了原始的子进程方式。通过测试我们发现，在子进程中，即使长时间运行 CPU 密集型的操作，渲染进程以及主进程都不会受到应用。经过一系列的重构，我们将绝大部分业务逻辑转移到子进程中，真正彻底地解决了 CPU 密集型运算导致的渲染进程卡顿的问题。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Electron 的应用架构不同于普通的原生应用，其多进程的设计在某些方面可能还优于一般的架构设计，可是在许多的技术细节中， Electron 的官方文档并没有详细说明其中的原理以及副作用。正如 remote 通讯方式虽然给 Electron 提供了极其便利的 rpc 通讯方式，可是使用者仍然需要深入了解 remote 的运行原理以及机制，需要清楚意识到，该通讯方式在某些情况下可能会对程序体验造成毁灭性的打击。因此我们需要慎重选择使用跨进程通讯。</p>\n<p>#blog</p>\n"},{"title":"WKWebView 设置 Cookie 的正确方式","date":"2021-10-10T07:54:00.000Z","_content":"\n## 1. 前言：\n\n> WKWebView 万般好，Cookie 操作对比 UIWebView，仿佛就是处于原始时代一般。\n\n笔者在开发过程中遇到了一个问题，在 Server 端返回的 302 响应中，响应头部的 `Set-Cookie` 字段全部没有生效。~~深究下去后，掀开了 WKWebView 英俊的外表下，及其丑恶的嘴脸。~~\n\n## 2. 问题\n\n笔者的场景中，在使用 WKWebView 打开的页面，Server 端需要校验 Client 的身份。因此需要在打开网页前，注入当前用户的身份信息。由于 Cookie 支持 Request 的其中一个头部字段，因此可以很简单的操作为：\n\n```objectivec\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\n[request addValue:cookieValue forHTTPHeaderField:@\"Cookie\"];\n[webView loadRequest:request];\n```\n\n然后，他就生效了，Server 能正确获取到 Cookie 数据，问题得以解决。\n\n直到，其后的需求变更，其中一种场景下，Request 会触发一个 HTTP 状态码为 302 的**跨域**跳转，同时，Response 中会通过 `Set-Cookie` 字段注入目的地址所需的身份信息。\n\n然后，跳转失败，302 后的 Request 并没有带上该有的 Cookie 数据。\n\n## 3. 原因\n\n究其根本，笔者认为该是 WKWebView 所处的是**独立进程**的原因。\n众所周知，不同于 UIWebView，WKWebView 所在的进程是独立于 App 的进程的，因此 WKWebView 无法像 UIWebView 一样轻松获取应用的 NSHTTPCookieStorage 的单例对象，转而需要进程间通讯传递所需的参数。\n\n在 [这才是 WKWebView Cookie 管理的正确方式](https://www.jianshu.com/p/163c03ed0b5e) 文章中说到：\n\n> 结合两者，你也会发现一个核心的概念-**如果设置了 allHTTPHeaderFields，则不用使用 the cookie manager by default**。\n\n通过 NSMutableURLRequest 修改 Header 字段，默认不再需要 WKWebView 自动管理 Cookie 信息，因此在笔者的场景中，302 后的 Cookie 由于没有自行管理，因此便被丢弃。\n\n## 4. 解决方法\n\n在 [这才是 WKWebView Cookie 管理的正确方式](https://www.jianshu.com/p/163c03ed0b5e) 文章中提到，在设置 Cookie 的时候，应该避免通过 NSMutableURLRequest 设置 Cookie 信息。然后该作者提供了一种通过 Javascript 方式注入 Cookie：\n\n```objectivec\nWKUserContentController *userContentController = [WKUserContentController new];\n\nWKWebViewConfiguration *webViewConfig = [[WKWebViewConfiguration alloc] init];\n    webViewConfig.userContentController = userContentController;\n\nwebViewConfig.processPool = [AppHostCookie sharedPoolManager];\n    \nNSMutableArray<NSString *> *oldCookies = [AppHostCookie cookieJavaScriptArray];\n    [oldCookies enumerateObjectsUsingBlock:^(NSString *_Nonnull obj, NSUInteger idx, BOOL *_Nonnull stop) {\n    NSString *setCookie = [NSString stringWithFormat:@\"document.cookie='%@';\", obj];\n    WKUserScript *cookieScript = [[WKUserScript alloc] initWithSource:setCookie injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:YES];\n    [userContentController addUserScript:cookieScript];\n}];\n\nWKWebView *webview = [[WKWebView alloc] initWithFrame:CGRectMake(0, -1, SCREEN_WIDTH,ONE_PIXEL) configuration:webViewConfig];\n\nwebview.navigationDelegate = self;\nwebview.UIDelegate = self;\n\nreturn webview;\n```\n\n这种方式其实是**不准确**的，由于 JS 注入 Cookie 的时机是 \t`WKUserScriptInjectionTimeAtDocumentStart` ，这意味着需要等 WKWebView 发起了首次请求，获取到 HTML 数据的时候，Cookie 并没有注入。这种方式只适用于获取 HTML 的 Request 不校验 Cookie，只是其中的 Ajax 才需要 Cookie 信息的场景。\n\n笔者认为，正确的应该是通过 iOS 11.0 版本引入的 **WKHTTPCookieStore** 成员去注入 Cookie 信息到 WKWebView 中\n\n```objectivec\n// 建议自行初始化 DataSource，使用 WKWebView 默认的有几率不生效\nWKWebsiteDataStore *dataStore = [WKWebsiteDataStore nonPersistentDataStore];\nWKWebViewConfiguration *wkWebConfig = [[WKWebViewConfiguration alloc] init];\nwkWebConfig.websiteDataStore = dataStore;\n\nWKWebView *webview = [[WKWebView alloc] initWithFrame:CGRectZero configuration:wkWebConfig];\n// 获取 Cookie Store 对象\nWKHTTPCookieStore *cookieStore = webView.configuration.websiteDataStore.httpCookieStore;\n\n// 由于设置 Cookie 应该是跨进程通讯，这里需要等待设置完成后，再发起请求\ndispatch_group_t cookieGroup = dispatch_group_create();\nfor (NSHTTPCookie *cookie in [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:request.URL]) {\n    dispatch_group_enter(cookieGroup);\n    [cookieStore setCookie:cookie completionHandler:^{\n        dispatch_group_leave(cookieGroup);\n    }];\n}\n\ndispatch_group_notify(cookieGroup, dispatch_get_main_queue(), ^{\n    [webView loadRequest:request];\n});\n```\n\n另外对于从 WKWebView 同步 Cookie 到 NSHTTPCookieStorage 的场景，可以通过增加 WKHTTPCookieStore 的 `Observer` ，实现代理 `<WKHTTPCookieStoreObserver> (cookiesDidChangeInCookieStore:)`  事件，即可将变更的 Cookie 同步回 NSHTTPCookieStorage 中。","source":"_posts/WKWebView-设置-Cookie-的正确方式.md","raw":"---\ntitle: WKWebView 设置 Cookie 的正确方式\ndate: 2021-10-10 15:54:00\ntags:\n---\n\n## 1. 前言：\n\n> WKWebView 万般好，Cookie 操作对比 UIWebView，仿佛就是处于原始时代一般。\n\n笔者在开发过程中遇到了一个问题，在 Server 端返回的 302 响应中，响应头部的 `Set-Cookie` 字段全部没有生效。~~深究下去后，掀开了 WKWebView 英俊的外表下，及其丑恶的嘴脸。~~\n\n## 2. 问题\n\n笔者的场景中，在使用 WKWebView 打开的页面，Server 端需要校验 Client 的身份。因此需要在打开网页前，注入当前用户的身份信息。由于 Cookie 支持 Request 的其中一个头部字段，因此可以很简单的操作为：\n\n```objectivec\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\n[request addValue:cookieValue forHTTPHeaderField:@\"Cookie\"];\n[webView loadRequest:request];\n```\n\n然后，他就生效了，Server 能正确获取到 Cookie 数据，问题得以解决。\n\n直到，其后的需求变更，其中一种场景下，Request 会触发一个 HTTP 状态码为 302 的**跨域**跳转，同时，Response 中会通过 `Set-Cookie` 字段注入目的地址所需的身份信息。\n\n然后，跳转失败，302 后的 Request 并没有带上该有的 Cookie 数据。\n\n## 3. 原因\n\n究其根本，笔者认为该是 WKWebView 所处的是**独立进程**的原因。\n众所周知，不同于 UIWebView，WKWebView 所在的进程是独立于 App 的进程的，因此 WKWebView 无法像 UIWebView 一样轻松获取应用的 NSHTTPCookieStorage 的单例对象，转而需要进程间通讯传递所需的参数。\n\n在 [这才是 WKWebView Cookie 管理的正确方式](https://www.jianshu.com/p/163c03ed0b5e) 文章中说到：\n\n> 结合两者，你也会发现一个核心的概念-**如果设置了 allHTTPHeaderFields，则不用使用 the cookie manager by default**。\n\n通过 NSMutableURLRequest 修改 Header 字段，默认不再需要 WKWebView 自动管理 Cookie 信息，因此在笔者的场景中，302 后的 Cookie 由于没有自行管理，因此便被丢弃。\n\n## 4. 解决方法\n\n在 [这才是 WKWebView Cookie 管理的正确方式](https://www.jianshu.com/p/163c03ed0b5e) 文章中提到，在设置 Cookie 的时候，应该避免通过 NSMutableURLRequest 设置 Cookie 信息。然后该作者提供了一种通过 Javascript 方式注入 Cookie：\n\n```objectivec\nWKUserContentController *userContentController = [WKUserContentController new];\n\nWKWebViewConfiguration *webViewConfig = [[WKWebViewConfiguration alloc] init];\n    webViewConfig.userContentController = userContentController;\n\nwebViewConfig.processPool = [AppHostCookie sharedPoolManager];\n    \nNSMutableArray<NSString *> *oldCookies = [AppHostCookie cookieJavaScriptArray];\n    [oldCookies enumerateObjectsUsingBlock:^(NSString *_Nonnull obj, NSUInteger idx, BOOL *_Nonnull stop) {\n    NSString *setCookie = [NSString stringWithFormat:@\"document.cookie='%@';\", obj];\n    WKUserScript *cookieScript = [[WKUserScript alloc] initWithSource:setCookie injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:YES];\n    [userContentController addUserScript:cookieScript];\n}];\n\nWKWebView *webview = [[WKWebView alloc] initWithFrame:CGRectMake(0, -1, SCREEN_WIDTH,ONE_PIXEL) configuration:webViewConfig];\n\nwebview.navigationDelegate = self;\nwebview.UIDelegate = self;\n\nreturn webview;\n```\n\n这种方式其实是**不准确**的，由于 JS 注入 Cookie 的时机是 \t`WKUserScriptInjectionTimeAtDocumentStart` ，这意味着需要等 WKWebView 发起了首次请求，获取到 HTML 数据的时候，Cookie 并没有注入。这种方式只适用于获取 HTML 的 Request 不校验 Cookie，只是其中的 Ajax 才需要 Cookie 信息的场景。\n\n笔者认为，正确的应该是通过 iOS 11.0 版本引入的 **WKHTTPCookieStore** 成员去注入 Cookie 信息到 WKWebView 中\n\n```objectivec\n// 建议自行初始化 DataSource，使用 WKWebView 默认的有几率不生效\nWKWebsiteDataStore *dataStore = [WKWebsiteDataStore nonPersistentDataStore];\nWKWebViewConfiguration *wkWebConfig = [[WKWebViewConfiguration alloc] init];\nwkWebConfig.websiteDataStore = dataStore;\n\nWKWebView *webview = [[WKWebView alloc] initWithFrame:CGRectZero configuration:wkWebConfig];\n// 获取 Cookie Store 对象\nWKHTTPCookieStore *cookieStore = webView.configuration.websiteDataStore.httpCookieStore;\n\n// 由于设置 Cookie 应该是跨进程通讯，这里需要等待设置完成后，再发起请求\ndispatch_group_t cookieGroup = dispatch_group_create();\nfor (NSHTTPCookie *cookie in [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookiesForURL:request.URL]) {\n    dispatch_group_enter(cookieGroup);\n    [cookieStore setCookie:cookie completionHandler:^{\n        dispatch_group_leave(cookieGroup);\n    }];\n}\n\ndispatch_group_notify(cookieGroup, dispatch_get_main_queue(), ^{\n    [webView loadRequest:request];\n});\n```\n\n另外对于从 WKWebView 同步 Cookie 到 NSHTTPCookieStorage 的场景，可以通过增加 WKHTTPCookieStore 的 `Observer` ，实现代理 `<WKHTTPCookieStoreObserver> (cookiesDidChangeInCookieStore:)`  事件，即可将变更的 Cookie 同步回 NSHTTPCookieStorage 中。","slug":"WKWebView-设置-Cookie-的正确方式","published":1,"updated":"2022-02-23T13:14:20.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hb0006rv0557o72c36","content":"<h2 id=\"1-前言：\"><a href=\"#1-前言：\" class=\"headerlink\" title=\"1. 前言：\"></a>1. 前言：</h2><blockquote>\n<p>WKWebView 万般好，Cookie 操作对比 UIWebView，仿佛就是处于原始时代一般。</p>\n</blockquote>\n<p>笔者在开发过程中遇到了一个问题，在 Server 端返回的 302 响应中，响应头部的 <code>Set-Cookie</code> 字段全部没有生效。<del>深究下去后，掀开了 WKWebView 英俊的外表下，及其丑恶的嘴脸。</del></p>\n<h2 id=\"2-问题\"><a href=\"#2-问题\" class=\"headerlink\" title=\"2. 问题\"></a>2. 问题</h2><p>笔者的场景中，在使用 WKWebView 打开的页面，Server 端需要校验 Client 的身份。因此需要在打开网页前，注入当前用户的身份信息。由于 Cookie 支持 Request 的其中一个头部字段，因此可以很简单的操作为：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-built_in\">NSMutableURLRequest</span> *request = [<span class=\"hljs-built_in\">NSMutableURLRequest</span> requestWithURL:url];<br>[request addValue:cookieValue forHTTPHeaderField:<span class=\"hljs-string\">@&quot;Cookie&quot;</span>];<br>[webView loadRequest:request];<br></code></pre></td></tr></table></figure>\n\n<p>然后，他就生效了，Server 能正确获取到 Cookie 数据，问题得以解决。</p>\n<p>直到，其后的需求变更，其中一种场景下，Request 会触发一个 HTTP 状态码为 302 的<strong>跨域</strong>跳转，同时，Response 中会通过 <code>Set-Cookie</code> 字段注入目的地址所需的身份信息。</p>\n<p>然后，跳转失败，302 后的 Request 并没有带上该有的 Cookie 数据。</p>\n<h2 id=\"3-原因\"><a href=\"#3-原因\" class=\"headerlink\" title=\"3. 原因\"></a>3. 原因</h2><p>究其根本，笔者认为该是 WKWebView 所处的是<strong>独立进程</strong>的原因。<br>众所周知，不同于 UIWebView，WKWebView 所在的进程是独立于 App 的进程的，因此 WKWebView 无法像 UIWebView 一样轻松获取应用的 NSHTTPCookieStorage 的单例对象，转而需要进程间通讯传递所需的参数。</p>\n<p>在 <a href=\"https://www.jianshu.com/p/163c03ed0b5e\">这才是 WKWebView Cookie 管理的正确方式</a> 文章中说到：</p>\n<blockquote>\n<p>结合两者，你也会发现一个核心的概念-<strong>如果设置了 allHTTPHeaderFields，则不用使用 the cookie manager by default</strong>。</p>\n</blockquote>\n<p>通过 NSMutableURLRequest 修改 Header 字段，默认不再需要 WKWebView 自动管理 Cookie 信息，因此在笔者的场景中，302 后的 Cookie 由于没有自行管理，因此便被丢弃。</p>\n<h2 id=\"4-解决方法\"><a href=\"#4-解决方法\" class=\"headerlink\" title=\"4. 解决方法\"></a>4. 解决方法</h2><p>在 <a href=\"https://www.jianshu.com/p/163c03ed0b5e\">这才是 WKWebView Cookie 管理的正确方式</a> 文章中提到，在设置 Cookie 的时候，应该避免通过 NSMutableURLRequest 设置 Cookie 信息。然后该作者提供了一种通过 Javascript 方式注入 Cookie：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-built_in\">WKUserContentController</span> *userContentController = [<span class=\"hljs-built_in\">WKUserContentController</span> new];<br><br><span class=\"hljs-built_in\">WKWebViewConfiguration</span> *webViewConfig = [[<span class=\"hljs-built_in\">WKWebViewConfiguration</span> alloc] init];<br>    webViewConfig.userContentController = userContentController;<br><br>webViewConfig.processPool = [AppHostCookie sharedPoolManager];<br>    <br><span class=\"hljs-built_in\">NSMutableArray</span>&lt;<span class=\"hljs-built_in\">NSString</span> *&gt; *oldCookies = [AppHostCookie cookieJavaScriptArray];<br>    [oldCookies enumerateObjectsUsingBlock:^(<span class=\"hljs-built_in\">NSString</span> *_Nonnull obj, <span class=\"hljs-built_in\">NSUInteger</span> idx, <span class=\"hljs-built_in\">BOOL</span> *_Nonnull stop) &#123;<br>    <span class=\"hljs-built_in\">NSString</span> *setCookie = [<span class=\"hljs-built_in\">NSString</span> stringWithFormat:<span class=\"hljs-string\">@&quot;document.cookie=&#x27;%@&#x27;;&quot;</span>, obj];<br>    <span class=\"hljs-built_in\">WKUserScript</span> *cookieScript = [[<span class=\"hljs-built_in\">WKUserScript</span> alloc] initWithSource:setCookie injectionTime:<span class=\"hljs-built_in\">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class=\"hljs-literal\">YES</span>];<br>    [userContentController addUserScript:cookieScript];<br>&#125;];<br><br><span class=\"hljs-built_in\">WKWebView</span> *webview = [[<span class=\"hljs-built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"hljs-built_in\">CGRectMake</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, SCREEN_WIDTH,ONE_PIXEL) configuration:webViewConfig];<br><br>webview.navigationDelegate = <span class=\"hljs-keyword\">self</span>;<br>webview.UIDelegate = <span class=\"hljs-keyword\">self</span>;<br><br><span class=\"hljs-keyword\">return</span> webview;<br></code></pre></td></tr></table></figure>\n\n<p>这种方式其实是<strong>不准确</strong>的，由于 JS 注入 Cookie 的时机是     <code>WKUserScriptInjectionTimeAtDocumentStart</code> ，这意味着需要等 WKWebView 发起了首次请求，获取到 HTML 数据的时候，Cookie 并没有注入。这种方式只适用于获取 HTML 的 Request 不校验 Cookie，只是其中的 Ajax 才需要 Cookie 信息的场景。</p>\n<p>笔者认为，正确的应该是通过 iOS 11.0 版本引入的 <strong>WKHTTPCookieStore</strong> 成员去注入 Cookie 信息到 WKWebView 中</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-comment\">// 建议自行初始化 DataSource，使用 WKWebView 默认的有几率不生效</span><br><span class=\"hljs-built_in\">WKWebsiteDataStore</span> *dataStore = [<span class=\"hljs-built_in\">WKWebsiteDataStore</span> nonPersistentDataStore];<br><span class=\"hljs-built_in\">WKWebViewConfiguration</span> *wkWebConfig = [[<span class=\"hljs-built_in\">WKWebViewConfiguration</span> alloc] init];<br>wkWebConfig.websiteDataStore = dataStore;<br><br><span class=\"hljs-built_in\">WKWebView</span> *webview = [[<span class=\"hljs-built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"hljs-built_in\">CGRectZero</span> configuration:wkWebConfig];<br><span class=\"hljs-comment\">// 获取 Cookie Store 对象</span><br><span class=\"hljs-built_in\">WKHTTPCookieStore</span> *cookieStore = webView.configuration.websiteDataStore.httpCookieStore;<br><br><span class=\"hljs-comment\">// 由于设置 Cookie 应该是跨进程通讯，这里需要等待设置完成后，再发起请求</span><br>dispatch_group_t cookieGroup = dispatch_group_create();<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">NSHTTPCookie</span> *cookie <span class=\"hljs-keyword\">in</span> [[<span class=\"hljs-built_in\">NSHTTPCookieStorage</span> sharedHTTPCookieStorage] cookiesForURL:request.URL]) &#123;<br>    dispatch_group_enter(cookieGroup);<br>    [cookieStore setCookie:cookie completionHandler:^&#123;<br>        dispatch_group_leave(cookieGroup);<br>    &#125;];<br>&#125;<br><br>dispatch_group_notify(cookieGroup, dispatch_get_main_queue(), ^&#123;<br>    [webView loadRequest:request];<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>另外对于从 WKWebView 同步 Cookie 到 NSHTTPCookieStorage 的场景，可以通过增加 WKHTTPCookieStore 的 <code>Observer</code> ，实现代理 <code>&lt;WKHTTPCookieStoreObserver&gt; (cookiesDidChangeInCookieStore:)</code>  事件，即可将变更的 Cookie 同步回 NSHTTPCookieStorage 中。</p>\n","site":{"data":{}},"excerpt":"1. 前言：\nWKWebView 万般好，Cookie 操作对比 UIWebView，仿佛就是处于原始时代一般。\n\n笔者在开发过程中遇到了一个问题，在 Server 端返回的 302 响应中，响应头部的 Set-Cookie 字段全部没有生效。深究下去后，掀开了 WKWebView 英俊的外表下，及其丑恶的嘴脸。\n\n2. 问题\n笔者的场景中，在使用 WKWebView 打开的页面，Server 端","more":"<h2 id=\"1-前言：\"><a href=\"#1-前言：\" class=\"headerlink\" title=\"1. 前言：\"></a>1. 前言：</h2><blockquote>\n<p>WKWebView 万般好，Cookie 操作对比 UIWebView，仿佛就是处于原始时代一般。</p>\n</blockquote>\n<p>笔者在开发过程中遇到了一个问题，在 Server 端返回的 302 响应中，响应头部的 <code>Set-Cookie</code> 字段全部没有生效。<del>深究下去后，掀开了 WKWebView 英俊的外表下，及其丑恶的嘴脸。</del></p>\n<h2 id=\"2-问题\"><a href=\"#2-问题\" class=\"headerlink\" title=\"2. 问题\"></a>2. 问题</h2><p>笔者的场景中，在使用 WKWebView 打开的页面，Server 端需要校验 Client 的身份。因此需要在打开网页前，注入当前用户的身份信息。由于 Cookie 支持 Request 的其中一个头部字段，因此可以很简单的操作为：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-built_in\">NSMutableURLRequest</span> *request = [<span class=\"hljs-built_in\">NSMutableURLRequest</span> requestWithURL:url];<br>[request addValue:cookieValue forHTTPHeaderField:<span class=\"hljs-string\">@&quot;Cookie&quot;</span>];<br>[webView loadRequest:request];<br></code></pre></td></tr></table></figure>\n\n<p>然后，他就生效了，Server 能正确获取到 Cookie 数据，问题得以解决。</p>\n<p>直到，其后的需求变更，其中一种场景下，Request 会触发一个 HTTP 状态码为 302 的<strong>跨域</strong>跳转，同时，Response 中会通过 <code>Set-Cookie</code> 字段注入目的地址所需的身份信息。</p>\n<p>然后，跳转失败，302 后的 Request 并没有带上该有的 Cookie 数据。</p>\n<h2 id=\"3-原因\"><a href=\"#3-原因\" class=\"headerlink\" title=\"3. 原因\"></a>3. 原因</h2><p>究其根本，笔者认为该是 WKWebView 所处的是<strong>独立进程</strong>的原因。<br>众所周知，不同于 UIWebView，WKWebView 所在的进程是独立于 App 的进程的，因此 WKWebView 无法像 UIWebView 一样轻松获取应用的 NSHTTPCookieStorage 的单例对象，转而需要进程间通讯传递所需的参数。</p>\n<p>在 <a href=\"https://www.jianshu.com/p/163c03ed0b5e\">这才是 WKWebView Cookie 管理的正确方式</a> 文章中说到：</p>\n<blockquote>\n<p>结合两者，你也会发现一个核心的概念-<strong>如果设置了 allHTTPHeaderFields，则不用使用 the cookie manager by default</strong>。</p>\n</blockquote>\n<p>通过 NSMutableURLRequest 修改 Header 字段，默认不再需要 WKWebView 自动管理 Cookie 信息，因此在笔者的场景中，302 后的 Cookie 由于没有自行管理，因此便被丢弃。</p>\n<h2 id=\"4-解决方法\"><a href=\"#4-解决方法\" class=\"headerlink\" title=\"4. 解决方法\"></a>4. 解决方法</h2><p>在 <a href=\"https://www.jianshu.com/p/163c03ed0b5e\">这才是 WKWebView Cookie 管理的正确方式</a> 文章中提到，在设置 Cookie 的时候，应该避免通过 NSMutableURLRequest 设置 Cookie 信息。然后该作者提供了一种通过 Javascript 方式注入 Cookie：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-built_in\">WKUserContentController</span> *userContentController = [<span class=\"hljs-built_in\">WKUserContentController</span> new];<br><br><span class=\"hljs-built_in\">WKWebViewConfiguration</span> *webViewConfig = [[<span class=\"hljs-built_in\">WKWebViewConfiguration</span> alloc] init];<br>    webViewConfig.userContentController = userContentController;<br><br>webViewConfig.processPool = [AppHostCookie sharedPoolManager];<br>    <br><span class=\"hljs-built_in\">NSMutableArray</span>&lt;<span class=\"hljs-built_in\">NSString</span> *&gt; *oldCookies = [AppHostCookie cookieJavaScriptArray];<br>    [oldCookies enumerateObjectsUsingBlock:^(<span class=\"hljs-built_in\">NSString</span> *_Nonnull obj, <span class=\"hljs-built_in\">NSUInteger</span> idx, <span class=\"hljs-built_in\">BOOL</span> *_Nonnull stop) &#123;<br>    <span class=\"hljs-built_in\">NSString</span> *setCookie = [<span class=\"hljs-built_in\">NSString</span> stringWithFormat:<span class=\"hljs-string\">@&quot;document.cookie=&#x27;%@&#x27;;&quot;</span>, obj];<br>    <span class=\"hljs-built_in\">WKUserScript</span> *cookieScript = [[<span class=\"hljs-built_in\">WKUserScript</span> alloc] initWithSource:setCookie injectionTime:<span class=\"hljs-built_in\">WKUserScriptInjectionTimeAtDocumentStart</span> forMainFrameOnly:<span class=\"hljs-literal\">YES</span>];<br>    [userContentController addUserScript:cookieScript];<br>&#125;];<br><br><span class=\"hljs-built_in\">WKWebView</span> *webview = [[<span class=\"hljs-built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"hljs-built_in\">CGRectMake</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>, SCREEN_WIDTH,ONE_PIXEL) configuration:webViewConfig];<br><br>webview.navigationDelegate = <span class=\"hljs-keyword\">self</span>;<br>webview.UIDelegate = <span class=\"hljs-keyword\">self</span>;<br><br><span class=\"hljs-keyword\">return</span> webview;<br></code></pre></td></tr></table></figure>\n\n<p>这种方式其实是<strong>不准确</strong>的，由于 JS 注入 Cookie 的时机是     <code>WKUserScriptInjectionTimeAtDocumentStart</code> ，这意味着需要等 WKWebView 发起了首次请求，获取到 HTML 数据的时候，Cookie 并没有注入。这种方式只适用于获取 HTML 的 Request 不校验 Cookie，只是其中的 Ajax 才需要 Cookie 信息的场景。</p>\n<p>笔者认为，正确的应该是通过 iOS 11.0 版本引入的 <strong>WKHTTPCookieStore</strong> 成员去注入 Cookie 信息到 WKWebView 中</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><code class=\"hljs objectivec\"><span class=\"hljs-comment\">// 建议自行初始化 DataSource，使用 WKWebView 默认的有几率不生效</span><br><span class=\"hljs-built_in\">WKWebsiteDataStore</span> *dataStore = [<span class=\"hljs-built_in\">WKWebsiteDataStore</span> nonPersistentDataStore];<br><span class=\"hljs-built_in\">WKWebViewConfiguration</span> *wkWebConfig = [[<span class=\"hljs-built_in\">WKWebViewConfiguration</span> alloc] init];<br>wkWebConfig.websiteDataStore = dataStore;<br><br><span class=\"hljs-built_in\">WKWebView</span> *webview = [[<span class=\"hljs-built_in\">WKWebView</span> alloc] initWithFrame:<span class=\"hljs-built_in\">CGRectZero</span> configuration:wkWebConfig];<br><span class=\"hljs-comment\">// 获取 Cookie Store 对象</span><br><span class=\"hljs-built_in\">WKHTTPCookieStore</span> *cookieStore = webView.configuration.websiteDataStore.httpCookieStore;<br><br><span class=\"hljs-comment\">// 由于设置 Cookie 应该是跨进程通讯，这里需要等待设置完成后，再发起请求</span><br>dispatch_group_t cookieGroup = dispatch_group_create();<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">NSHTTPCookie</span> *cookie <span class=\"hljs-keyword\">in</span> [[<span class=\"hljs-built_in\">NSHTTPCookieStorage</span> sharedHTTPCookieStorage] cookiesForURL:request.URL]) &#123;<br>    dispatch_group_enter(cookieGroup);<br>    [cookieStore setCookie:cookie completionHandler:^&#123;<br>        dispatch_group_leave(cookieGroup);<br>    &#125;];<br>&#125;<br><br>dispatch_group_notify(cookieGroup, dispatch_get_main_queue(), ^&#123;<br>    [webView loadRequest:request];<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>另外对于从 WKWebView 同步 Cookie 到 NSHTTPCookieStorage 的场景，可以通过增加 WKHTTPCookieStore 的 <code>Observer</code> ，实现代理 <code>&lt;WKHTTPCookieStoreObserver&gt; (cookiesDidChangeInCookieStore:)</code>  事件，即可将变更的 Cookie 同步回 NSHTTPCookieStorage 中。</p>\n"},{"title":"Hello World","date":"1969-12-31T16:00:01.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 1970-01-01 00:00:01\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2022-02-23T13:14:20.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hc0007rv05dz6a658c","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\nQuic","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"关于 Xcode 的资源占用","date":"2021-03-30T09:39:12.000Z","_content":"\n> macOS: Big Sur 11.2.1 \n> Xcode: 12.4 (12D4e)\n\n## TL；DR\n为了安全起见，除了 `~/Libray/Developer/Xcode/iOS DeviceSupport` 文件夹不建议删除外，`~/Libray/Developer/` 内的其他内容，都可以删除。\n\n## 前言：\n由于笔者一直在使用着 256G 的 macBook Pro，因此一直对文件存储表示相当的关注。最近发现，即便工作机没有存放任何私人内容，在 iOS debug 过程中依然会经常出现磁盘容量不足的提示，甚至会影响 Module Cache 文件的写入，因此导致构建失败。而出现这种情况后，笔者习惯进入 `Developer` 文件夹，进行一通操作，释放大量磁盘空间，然后再次进入漫长的等待构建过程。\n虽然操作了很多次，可是一致没搞清楚 Xcode 对于缓存文件的管理，因此趁着这个机会，深入了解一下这个烦困依旧的问题。\n\n## Developer 文件夹初探\n在笔者所用的开发环境中，Xcode 生成的临时文件绝大部分都集中在 `~/Library/Developer` 。当然，如果你直接删除这个文件夹，不过可能会有一些难以预料的问题会出现。\nDeveloper 文件夹中包含了 CoreSimulator, Xcode, 以及 XCTestDevices 文件夹，不同的文件夹中存放的数据，都是各有作用的。以笔者开发环境为例，Developer 文件夹中的目录结构如下：\n\n```\n.\n├── CoreSimulator\n│   ├── Caches\n│   │   └── dyld\n│   ├── Devices\n│   │   ├── 34EF2726-B835-4ADA-B589-A7E71620D7B6\n│   │   └── device_set.plist\n│   └── Temp\n│       └── BackgroundDelete\n├── XCTestDevices\n└── Xcode\n    ├── DerivedData\n    │   ├── ModuleCache.noindex\n    │   └── xxxxxx-hgprucnfscdzudfulchfczkhsmjy\n    ├── DocumentationCache\n    │   └── v178\n    ├── GPUToolsAgent.sock\n    ├── UserData\n    │   ├── IB\\ Support\n    │   ├── IDEEditorInteractivityHistory\n    │   ├── IDEPreferencesController.xcuserstate\n    │   └── KeyBindings\n    ├── iOS\\ Device\\ Logs\n    │   ├── iOS\\ Device\\ Logs\\ 12.4.db\n    │   ├── iOS\\ Device\\ Logs\\ 12.4.db-shm\n    │   └── iOS\\ Device\\ Logs\\ 12.4.db-wal\n    └── iOS\\ DeviceSupport\n        └── 14.4\\ (18D52)\\ arm64e\n```\n\n## Developer 文件夹细看\n### CoreSimulator\n在 macOS 环境的模拟器环境，其中 `Caches/dyld` 文件夹会生成开发调试相关的工具文件，详细可以参考这篇文档 [dyld 详解](https://www.dllhook.com/post/238.html)。\n而 `Devices` 文件夹则是针对每一个模拟器的 iOS 系统生成一个用户层的沙盒环境，在 iPhoneX 跟 iPhoneXs 的两个模拟器中，其用户环境是不一致的，Xcode 会在这个目录分别为两个模拟器生成不同的文件夹。这个文件夹包含了开发者在对应模拟器环境中的 Debug 应用，以及应用在 iOS 系统中的沙盒环境，如果在很长时间没有清理的话，很有可能会产生非常可观的应用垃圾。如果我们手动清理这个目录，那么 Simulator.app 在下次启动的时候会重新将其生成，但这个时候之前应用会以全新安装的形式进行启动。\n\n### XCTestDevices\nXcode 自动化测试以及单元测试相关的目录，如果经常进行对应操作的话，这个目录也会产生相当可观的应用垃圾，建议经常清理。\n\n### Xcode\n这个目录下保存了开发过程中可能产生的缓存文件。其中 `DerivedData` 目录保存了项目构建过程中的中间文件。\n\n#### DerivedData\n\n![ModuleCache.onindex](https://cdn.iguan7u.cn/image/ModuleCache.png)\n`DerivedData/ModuleCache.noindex` 是保存应用模块的预编译文件 Precompile module files (`.pcm`)，用于解决 Xcode 项目中可能出现数以万计的 `#import` 语句的构建问题，模块化拆分后，Xcode 能增量构建变更模块，极大的提升了开发效率。如果你删除了这个文件夹，下次 Xcode 将可能会出现全量构建的问题。\n\n![ProjectFolder](https://cdn.iguan7u.cn/image/Xcode-ProjectModule.png)\n`DerivedData/[项目名][乱码后缀]` 文件夹，记录的是对应项目产生的中间文件。Xcode 会根据不同的项目分别产生对应的文件夹。如果项目比较庞大，这里生成的中间文件会非常多。笔者正在参与的项目，会固定产生 20GB+ 的中间文件。\n\n**index**文件夹\n存放的是 Xcode 对于项目索引的信息，用于方法跳转，文件定位等地方，删除后 Xcode 将会重新生成。据说 Xcode9 以前的版本 index 是以可肉眼查看的格式存放的，后面改为用 [LMDB](https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database) 格式存放了，估计是为了解决内存占用问题。\n\n**logs**文件夹\nXcode 相关日志存放位置，内部将应用开发过程中每个过程都单独存放在不同的文件夹中，查看可以了解 Xcode 的不同阶段执行的动作。更多信息可以查看这里  [Test logs in Xcode](https://michele.io/test-logs-in-Xcode/) .\n\n**SourcePackages**文件夹\n暂时未知具体作用，可能跟 [Swift Package Manager](https://swift.org/package-manager/) 有关。\n\n**TextIndex**文件夹\n具体作用未知，名字可能跟字符索引相关？\n\n**Build/Products**文件夹\n存放 debug 或者 release 模式下构建的应用包以及对应的资源库。这里笔者好奇为什么不能在 Devices 文件夹中软链接过来这里的资源包，节省磁盘空间占用，也避免内容拷贝（笔者实测这种方式能正常打开应用）。。。当然，具体原因我们也不可而知了。\n\n**Build/Intermediates.noindex**文件夹\n这里存放项目代码构建的中间文件，非常庞大，需要定时清理。清理后可能会导致应用全量构建。\n\n#### DocumentationCache\n这个文件夹记录 Xcode 获取对应文档的缓存。\n\n#### iOS Device Logs\n这个文件夹记录每个模拟器设备产生的日志，看文件内容应该是 CoreData 方式保存的数据。\n\n#### iOS DeviceSupport\n这个文件夹**尤为重要**，其中保存了 Xcode 系统版本支持信息。如果是从低版本 Xcode 一直升级上来的，这里可能会保存了很多低版本的系统支持，我们可以根据自身实际的需求，删减其中的内容。如果错误删除了，或者后期需要，可以在 Xcode Preference 中的 Components 面板中重新下载。\n\n#### UserData\n故名思义，用户数据文件夹。具体存放的内容与 Devices 文件夹中存放的有所重复，具体逻辑也不得而知了。","source":"_posts/关于-Xcode-的资源占用.md","raw":"---\ntitle: 关于 Xcode 的资源占用\ndate: 2021-03-30 17:39:12\ntags:\n---\n\n> macOS: Big Sur 11.2.1 \n> Xcode: 12.4 (12D4e)\n\n## TL；DR\n为了安全起见，除了 `~/Libray/Developer/Xcode/iOS DeviceSupport` 文件夹不建议删除外，`~/Libray/Developer/` 内的其他内容，都可以删除。\n\n## 前言：\n由于笔者一直在使用着 256G 的 macBook Pro，因此一直对文件存储表示相当的关注。最近发现，即便工作机没有存放任何私人内容，在 iOS debug 过程中依然会经常出现磁盘容量不足的提示，甚至会影响 Module Cache 文件的写入，因此导致构建失败。而出现这种情况后，笔者习惯进入 `Developer` 文件夹，进行一通操作，释放大量磁盘空间，然后再次进入漫长的等待构建过程。\n虽然操作了很多次，可是一致没搞清楚 Xcode 对于缓存文件的管理，因此趁着这个机会，深入了解一下这个烦困依旧的问题。\n\n## Developer 文件夹初探\n在笔者所用的开发环境中，Xcode 生成的临时文件绝大部分都集中在 `~/Library/Developer` 。当然，如果你直接删除这个文件夹，不过可能会有一些难以预料的问题会出现。\nDeveloper 文件夹中包含了 CoreSimulator, Xcode, 以及 XCTestDevices 文件夹，不同的文件夹中存放的数据，都是各有作用的。以笔者开发环境为例，Developer 文件夹中的目录结构如下：\n\n```\n.\n├── CoreSimulator\n│   ├── Caches\n│   │   └── dyld\n│   ├── Devices\n│   │   ├── 34EF2726-B835-4ADA-B589-A7E71620D7B6\n│   │   └── device_set.plist\n│   └── Temp\n│       └── BackgroundDelete\n├── XCTestDevices\n└── Xcode\n    ├── DerivedData\n    │   ├── ModuleCache.noindex\n    │   └── xxxxxx-hgprucnfscdzudfulchfczkhsmjy\n    ├── DocumentationCache\n    │   └── v178\n    ├── GPUToolsAgent.sock\n    ├── UserData\n    │   ├── IB\\ Support\n    │   ├── IDEEditorInteractivityHistory\n    │   ├── IDEPreferencesController.xcuserstate\n    │   └── KeyBindings\n    ├── iOS\\ Device\\ Logs\n    │   ├── iOS\\ Device\\ Logs\\ 12.4.db\n    │   ├── iOS\\ Device\\ Logs\\ 12.4.db-shm\n    │   └── iOS\\ Device\\ Logs\\ 12.4.db-wal\n    └── iOS\\ DeviceSupport\n        └── 14.4\\ (18D52)\\ arm64e\n```\n\n## Developer 文件夹细看\n### CoreSimulator\n在 macOS 环境的模拟器环境，其中 `Caches/dyld` 文件夹会生成开发调试相关的工具文件，详细可以参考这篇文档 [dyld 详解](https://www.dllhook.com/post/238.html)。\n而 `Devices` 文件夹则是针对每一个模拟器的 iOS 系统生成一个用户层的沙盒环境，在 iPhoneX 跟 iPhoneXs 的两个模拟器中，其用户环境是不一致的，Xcode 会在这个目录分别为两个模拟器生成不同的文件夹。这个文件夹包含了开发者在对应模拟器环境中的 Debug 应用，以及应用在 iOS 系统中的沙盒环境，如果在很长时间没有清理的话，很有可能会产生非常可观的应用垃圾。如果我们手动清理这个目录，那么 Simulator.app 在下次启动的时候会重新将其生成，但这个时候之前应用会以全新安装的形式进行启动。\n\n### XCTestDevices\nXcode 自动化测试以及单元测试相关的目录，如果经常进行对应操作的话，这个目录也会产生相当可观的应用垃圾，建议经常清理。\n\n### Xcode\n这个目录下保存了开发过程中可能产生的缓存文件。其中 `DerivedData` 目录保存了项目构建过程中的中间文件。\n\n#### DerivedData\n\n![ModuleCache.onindex](https://cdn.iguan7u.cn/image/ModuleCache.png)\n`DerivedData/ModuleCache.noindex` 是保存应用模块的预编译文件 Precompile module files (`.pcm`)，用于解决 Xcode 项目中可能出现数以万计的 `#import` 语句的构建问题，模块化拆分后，Xcode 能增量构建变更模块，极大的提升了开发效率。如果你删除了这个文件夹，下次 Xcode 将可能会出现全量构建的问题。\n\n![ProjectFolder](https://cdn.iguan7u.cn/image/Xcode-ProjectModule.png)\n`DerivedData/[项目名][乱码后缀]` 文件夹，记录的是对应项目产生的中间文件。Xcode 会根据不同的项目分别产生对应的文件夹。如果项目比较庞大，这里生成的中间文件会非常多。笔者正在参与的项目，会固定产生 20GB+ 的中间文件。\n\n**index**文件夹\n存放的是 Xcode 对于项目索引的信息，用于方法跳转，文件定位等地方，删除后 Xcode 将会重新生成。据说 Xcode9 以前的版本 index 是以可肉眼查看的格式存放的，后面改为用 [LMDB](https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database) 格式存放了，估计是为了解决内存占用问题。\n\n**logs**文件夹\nXcode 相关日志存放位置，内部将应用开发过程中每个过程都单独存放在不同的文件夹中，查看可以了解 Xcode 的不同阶段执行的动作。更多信息可以查看这里  [Test logs in Xcode](https://michele.io/test-logs-in-Xcode/) .\n\n**SourcePackages**文件夹\n暂时未知具体作用，可能跟 [Swift Package Manager](https://swift.org/package-manager/) 有关。\n\n**TextIndex**文件夹\n具体作用未知，名字可能跟字符索引相关？\n\n**Build/Products**文件夹\n存放 debug 或者 release 模式下构建的应用包以及对应的资源库。这里笔者好奇为什么不能在 Devices 文件夹中软链接过来这里的资源包，节省磁盘空间占用，也避免内容拷贝（笔者实测这种方式能正常打开应用）。。。当然，具体原因我们也不可而知了。\n\n**Build/Intermediates.noindex**文件夹\n这里存放项目代码构建的中间文件，非常庞大，需要定时清理。清理后可能会导致应用全量构建。\n\n#### DocumentationCache\n这个文件夹记录 Xcode 获取对应文档的缓存。\n\n#### iOS Device Logs\n这个文件夹记录每个模拟器设备产生的日志，看文件内容应该是 CoreData 方式保存的数据。\n\n#### iOS DeviceSupport\n这个文件夹**尤为重要**，其中保存了 Xcode 系统版本支持信息。如果是从低版本 Xcode 一直升级上来的，这里可能会保存了很多低版本的系统支持，我们可以根据自身实际的需求，删减其中的内容。如果错误删除了，或者后期需要，可以在 Xcode Preference 中的 Components 面板中重新下载。\n\n#### UserData\n故名思义，用户数据文件夹。具体存放的内容与 Devices 文件夹中存放的有所重复，具体逻辑也不得而知了。","slug":"关于-Xcode-的资源占用","published":1,"updated":"2022-02-23T13:14:20.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hc0009rv05dvdvbk47","content":"<blockquote>\n<p>macOS: Big Sur 11.2.1<br>Xcode: 12.4 (12D4e)</p>\n</blockquote>\n<h2 id=\"TL；DR\"><a href=\"#TL；DR\" class=\"headerlink\" title=\"TL；DR\"></a>TL；DR</h2><p>为了安全起见，除了 <code>~/Libray/Developer/Xcode/iOS DeviceSupport</code> 文件夹不建议删除外，<code>~/Libray/Developer/</code> 内的其他内容，都可以删除。</p>\n<h2 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h2><p>由于笔者一直在使用着 256G 的 macBook Pro，因此一直对文件存储表示相当的关注。最近发现，即便工作机没有存放任何私人内容，在 iOS debug 过程中依然会经常出现磁盘容量不足的提示，甚至会影响 Module Cache 文件的写入，因此导致构建失败。而出现这种情况后，笔者习惯进入 <code>Developer</code> 文件夹，进行一通操作，释放大量磁盘空间，然后再次进入漫长的等待构建过程。<br>虽然操作了很多次，可是一致没搞清楚 Xcode 对于缓存文件的管理，因此趁着这个机会，深入了解一下这个烦困依旧的问题。</p>\n<h2 id=\"Developer-文件夹初探\"><a href=\"#Developer-文件夹初探\" class=\"headerlink\" title=\"Developer 文件夹初探\"></a>Developer 文件夹初探</h2><p>在笔者所用的开发环境中，Xcode 生成的临时文件绝大部分都集中在 <code>~/Library/Developer</code> 。当然，如果你直接删除这个文件夹，不过可能会有一些难以预料的问题会出现。<br>Developer 文件夹中包含了 CoreSimulator, Xcode, 以及 XCTestDevices 文件夹，不同的文件夹中存放的数据，都是各有作用的。以笔者开发环境为例，Developer 文件夹中的目录结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">.<br>├── CoreSimulator<br>│   ├── Caches<br>│   │   └── dyld<br>│   ├── Devices<br>│   │   ├── 34EF2726-B835-4ADA-B589-A7E71620D7B6<br>│   │   └── device_set.plist<br>│   └── Temp<br>│       └── BackgroundDelete<br>├── XCTestDevices<br>└── Xcode<br>    ├── DerivedData<br>    │   ├── ModuleCache.noindex<br>    │   └── xxxxxx-hgprucnfscdzudfulchfczkhsmjy<br>    ├── DocumentationCache<br>    │   └── v178<br>    ├── GPUToolsAgent.sock<br>    ├── UserData<br>    │   ├── IB\\ Support<br>    │   ├── IDEEditorInteractivityHistory<br>    │   ├── IDEPreferencesController.xcuserstate<br>    │   └── KeyBindings<br>    ├── iOS\\ Device\\ Logs<br>    │   ├── iOS\\ Device\\ Logs\\ 12.4.db<br>    │   ├── iOS\\ Device\\ Logs\\ 12.4.db-shm<br>    │   └── iOS\\ Device\\ Logs\\ 12.4.db-wal<br>    └── iOS\\ DeviceSupport<br>        └── 14.4\\ (18D52)\\ arm64e<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Developer-文件夹细看\"><a href=\"#Developer-文件夹细看\" class=\"headerlink\" title=\"Developer 文件夹细看\"></a>Developer 文件夹细看</h2><h3 id=\"CoreSimulator\"><a href=\"#CoreSimulator\" class=\"headerlink\" title=\"CoreSimulator\"></a>CoreSimulator</h3><p>在 macOS 环境的模拟器环境，其中 <code>Caches/dyld</code> 文件夹会生成开发调试相关的工具文件，详细可以参考这篇文档 <a href=\"https://www.dllhook.com/post/238.html\">dyld 详解</a>。<br>而 <code>Devices</code> 文件夹则是针对每一个模拟器的 iOS 系统生成一个用户层的沙盒环境，在 iPhoneX 跟 iPhoneXs 的两个模拟器中，其用户环境是不一致的，Xcode 会在这个目录分别为两个模拟器生成不同的文件夹。这个文件夹包含了开发者在对应模拟器环境中的 Debug 应用，以及应用在 iOS 系统中的沙盒环境，如果在很长时间没有清理的话，很有可能会产生非常可观的应用垃圾。如果我们手动清理这个目录，那么 Simulator.app 在下次启动的时候会重新将其生成，但这个时候之前应用会以全新安装的形式进行启动。</p>\n<h3 id=\"XCTestDevices\"><a href=\"#XCTestDevices\" class=\"headerlink\" title=\"XCTestDevices\"></a>XCTestDevices</h3><p>Xcode 自动化测试以及单元测试相关的目录，如果经常进行对应操作的话，这个目录也会产生相当可观的应用垃圾，建议经常清理。</p>\n<h3 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h3><p>这个目录下保存了开发过程中可能产生的缓存文件。其中 <code>DerivedData</code> 目录保存了项目构建过程中的中间文件。</p>\n<h4 id=\"DerivedData\"><a href=\"#DerivedData\" class=\"headerlink\" title=\"DerivedData\"></a>DerivedData</h4><p><img src=\"https://cdn.iguan7u.cn/image/ModuleCache.png\" alt=\"ModuleCache.onindex\"><br><code>DerivedData/ModuleCache.noindex</code> 是保存应用模块的预编译文件 Precompile module files (<code>.pcm</code>)，用于解决 Xcode 项目中可能出现数以万计的 <code>#import</code> 语句的构建问题，模块化拆分后，Xcode 能增量构建变更模块，极大的提升了开发效率。如果你删除了这个文件夹，下次 Xcode 将可能会出现全量构建的问题。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/Xcode-ProjectModule.png\" alt=\"ProjectFolder\"><br><code>DerivedData/[项目名][乱码后缀]</code> 文件夹，记录的是对应项目产生的中间文件。Xcode 会根据不同的项目分别产生对应的文件夹。如果项目比较庞大，这里生成的中间文件会非常多。笔者正在参与的项目，会固定产生 20GB+ 的中间文件。</p>\n<p><strong>index</strong>文件夹<br>存放的是 Xcode 对于项目索引的信息，用于方法跳转，文件定位等地方，删除后 Xcode 将会重新生成。据说 Xcode9 以前的版本 index 是以可肉眼查看的格式存放的，后面改为用 <a href=\"https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database\">LMDB</a> 格式存放了，估计是为了解决内存占用问题。</p>\n<p><strong>logs</strong>文件夹<br>Xcode 相关日志存放位置，内部将应用开发过程中每个过程都单独存放在不同的文件夹中，查看可以了解 Xcode 的不同阶段执行的动作。更多信息可以查看这里  <a href=\"https://michele.io/test-logs-in-Xcode/\">Test logs in Xcode</a> .</p>\n<p><strong>SourcePackages</strong>文件夹<br>暂时未知具体作用，可能跟 <a href=\"https://swift.org/package-manager/\">Swift Package Manager</a> 有关。</p>\n<p><strong>TextIndex</strong>文件夹<br>具体作用未知，名字可能跟字符索引相关？</p>\n<p><strong>Build&#x2F;Products</strong>文件夹<br>存放 debug 或者 release 模式下构建的应用包以及对应的资源库。这里笔者好奇为什么不能在 Devices 文件夹中软链接过来这里的资源包，节省磁盘空间占用，也避免内容拷贝（笔者实测这种方式能正常打开应用）。。。当然，具体原因我们也不可而知了。</p>\n<p><strong>Build&#x2F;Intermediates.noindex</strong>文件夹<br>这里存放项目代码构建的中间文件，非常庞大，需要定时清理。清理后可能会导致应用全量构建。</p>\n<h4 id=\"DocumentationCache\"><a href=\"#DocumentationCache\" class=\"headerlink\" title=\"DocumentationCache\"></a>DocumentationCache</h4><p>这个文件夹记录 Xcode 获取对应文档的缓存。</p>\n<h4 id=\"iOS-Device-Logs\"><a href=\"#iOS-Device-Logs\" class=\"headerlink\" title=\"iOS Device Logs\"></a>iOS Device Logs</h4><p>这个文件夹记录每个模拟器设备产生的日志，看文件内容应该是 CoreData 方式保存的数据。</p>\n<h4 id=\"iOS-DeviceSupport\"><a href=\"#iOS-DeviceSupport\" class=\"headerlink\" title=\"iOS DeviceSupport\"></a>iOS DeviceSupport</h4><p>这个文件夹<strong>尤为重要</strong>，其中保存了 Xcode 系统版本支持信息。如果是从低版本 Xcode 一直升级上来的，这里可能会保存了很多低版本的系统支持，我们可以根据自身实际的需求，删减其中的内容。如果错误删除了，或者后期需要，可以在 Xcode Preference 中的 Components 面板中重新下载。</p>\n<h4 id=\"UserData\"><a href=\"#UserData\" class=\"headerlink\" title=\"UserData\"></a>UserData</h4><p>故名思义，用户数据文件夹。具体存放的内容与 Devices 文件夹中存放的有所重复，具体逻辑也不得而知了。</p>\n","site":{"data":{}},"excerpt":"macOS: Big Sur 11.2.1\nXcode: 12.4 (12D4e)\n\nTL；DR\n为了安全起见，除了 ~/Libray/Developer/Xcode/iOS DeviceSupport 文件夹不建议删除外，~/Libray/Developer/ 内的其他内容，都可以删除。\n\n前言：\n由于笔者一直在使用着 256G 的 macBook Pro，因此一直对文件存储表示相当的关注。最近","more":"<blockquote>\n<p>macOS: Big Sur 11.2.1<br>Xcode: 12.4 (12D4e)</p>\n</blockquote>\n<h2 id=\"TL；DR\"><a href=\"#TL；DR\" class=\"headerlink\" title=\"TL；DR\"></a>TL；DR</h2><p>为了安全起见，除了 <code>~/Libray/Developer/Xcode/iOS DeviceSupport</code> 文件夹不建议删除外，<code>~/Libray/Developer/</code> 内的其他内容，都可以删除。</p>\n<h2 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h2><p>由于笔者一直在使用着 256G 的 macBook Pro，因此一直对文件存储表示相当的关注。最近发现，即便工作机没有存放任何私人内容，在 iOS debug 过程中依然会经常出现磁盘容量不足的提示，甚至会影响 Module Cache 文件的写入，因此导致构建失败。而出现这种情况后，笔者习惯进入 <code>Developer</code> 文件夹，进行一通操作，释放大量磁盘空间，然后再次进入漫长的等待构建过程。<br>虽然操作了很多次，可是一致没搞清楚 Xcode 对于缓存文件的管理，因此趁着这个机会，深入了解一下这个烦困依旧的问题。</p>\n<h2 id=\"Developer-文件夹初探\"><a href=\"#Developer-文件夹初探\" class=\"headerlink\" title=\"Developer 文件夹初探\"></a>Developer 文件夹初探</h2><p>在笔者所用的开发环境中，Xcode 生成的临时文件绝大部分都集中在 <code>~/Library/Developer</code> 。当然，如果你直接删除这个文件夹，不过可能会有一些难以预料的问题会出现。<br>Developer 文件夹中包含了 CoreSimulator, Xcode, 以及 XCTestDevices 文件夹，不同的文件夹中存放的数据，都是各有作用的。以笔者开发环境为例，Developer 文件夹中的目录结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">.<br>├── CoreSimulator<br>│   ├── Caches<br>│   │   └── dyld<br>│   ├── Devices<br>│   │   ├── 34EF2726-B835-4ADA-B589-A7E71620D7B6<br>│   │   └── device_set.plist<br>│   └── Temp<br>│       └── BackgroundDelete<br>├── XCTestDevices<br>└── Xcode<br>    ├── DerivedData<br>    │   ├── ModuleCache.noindex<br>    │   └── xxxxxx-hgprucnfscdzudfulchfczkhsmjy<br>    ├── DocumentationCache<br>    │   └── v178<br>    ├── GPUToolsAgent.sock<br>    ├── UserData<br>    │   ├── IB\\ Support<br>    │   ├── IDEEditorInteractivityHistory<br>    │   ├── IDEPreferencesController.xcuserstate<br>    │   └── KeyBindings<br>    ├── iOS\\ Device\\ Logs<br>    │   ├── iOS\\ Device\\ Logs\\ 12.4.db<br>    │   ├── iOS\\ Device\\ Logs\\ 12.4.db-shm<br>    │   └── iOS\\ Device\\ Logs\\ 12.4.db-wal<br>    └── iOS\\ DeviceSupport<br>        └── 14.4\\ (18D52)\\ arm64e<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Developer-文件夹细看\"><a href=\"#Developer-文件夹细看\" class=\"headerlink\" title=\"Developer 文件夹细看\"></a>Developer 文件夹细看</h2><h3 id=\"CoreSimulator\"><a href=\"#CoreSimulator\" class=\"headerlink\" title=\"CoreSimulator\"></a>CoreSimulator</h3><p>在 macOS 环境的模拟器环境，其中 <code>Caches/dyld</code> 文件夹会生成开发调试相关的工具文件，详细可以参考这篇文档 <a href=\"https://www.dllhook.com/post/238.html\">dyld 详解</a>。<br>而 <code>Devices</code> 文件夹则是针对每一个模拟器的 iOS 系统生成一个用户层的沙盒环境，在 iPhoneX 跟 iPhoneXs 的两个模拟器中，其用户环境是不一致的，Xcode 会在这个目录分别为两个模拟器生成不同的文件夹。这个文件夹包含了开发者在对应模拟器环境中的 Debug 应用，以及应用在 iOS 系统中的沙盒环境，如果在很长时间没有清理的话，很有可能会产生非常可观的应用垃圾。如果我们手动清理这个目录，那么 Simulator.app 在下次启动的时候会重新将其生成，但这个时候之前应用会以全新安装的形式进行启动。</p>\n<h3 id=\"XCTestDevices\"><a href=\"#XCTestDevices\" class=\"headerlink\" title=\"XCTestDevices\"></a>XCTestDevices</h3><p>Xcode 自动化测试以及单元测试相关的目录，如果经常进行对应操作的话，这个目录也会产生相当可观的应用垃圾，建议经常清理。</p>\n<h3 id=\"Xcode\"><a href=\"#Xcode\" class=\"headerlink\" title=\"Xcode\"></a>Xcode</h3><p>这个目录下保存了开发过程中可能产生的缓存文件。其中 <code>DerivedData</code> 目录保存了项目构建过程中的中间文件。</p>\n<h4 id=\"DerivedData\"><a href=\"#DerivedData\" class=\"headerlink\" title=\"DerivedData\"></a>DerivedData</h4><p><img src=\"https://cdn.iguan7u.cn/image/ModuleCache.png\" alt=\"ModuleCache.onindex\"><br><code>DerivedData/ModuleCache.noindex</code> 是保存应用模块的预编译文件 Precompile module files (<code>.pcm</code>)，用于解决 Xcode 项目中可能出现数以万计的 <code>#import</code> 语句的构建问题，模块化拆分后，Xcode 能增量构建变更模块，极大的提升了开发效率。如果你删除了这个文件夹，下次 Xcode 将可能会出现全量构建的问题。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/Xcode-ProjectModule.png\" alt=\"ProjectFolder\"><br><code>DerivedData/[项目名][乱码后缀]</code> 文件夹，记录的是对应项目产生的中间文件。Xcode 会根据不同的项目分别产生对应的文件夹。如果项目比较庞大，这里生成的中间文件会非常多。笔者正在参与的项目，会固定产生 20GB+ 的中间文件。</p>\n<p><strong>index</strong>文件夹<br>存放的是 Xcode 对于项目索引的信息，用于方法跳转，文件定位等地方，删除后 Xcode 将会重新生成。据说 Xcode9 以前的版本 index 是以可肉眼查看的格式存放的，后面改为用 <a href=\"https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database\">LMDB</a> 格式存放了，估计是为了解决内存占用问题。</p>\n<p><strong>logs</strong>文件夹<br>Xcode 相关日志存放位置，内部将应用开发过程中每个过程都单独存放在不同的文件夹中，查看可以了解 Xcode 的不同阶段执行的动作。更多信息可以查看这里  <a href=\"https://michele.io/test-logs-in-Xcode/\">Test logs in Xcode</a> .</p>\n<p><strong>SourcePackages</strong>文件夹<br>暂时未知具体作用，可能跟 <a href=\"https://swift.org/package-manager/\">Swift Package Manager</a> 有关。</p>\n<p><strong>TextIndex</strong>文件夹<br>具体作用未知，名字可能跟字符索引相关？</p>\n<p><strong>Build&#x2F;Products</strong>文件夹<br>存放 debug 或者 release 模式下构建的应用包以及对应的资源库。这里笔者好奇为什么不能在 Devices 文件夹中软链接过来这里的资源包，节省磁盘空间占用，也避免内容拷贝（笔者实测这种方式能正常打开应用）。。。当然，具体原因我们也不可而知了。</p>\n<p><strong>Build&#x2F;Intermediates.noindex</strong>文件夹<br>这里存放项目代码构建的中间文件，非常庞大，需要定时清理。清理后可能会导致应用全量构建。</p>\n<h4 id=\"DocumentationCache\"><a href=\"#DocumentationCache\" class=\"headerlink\" title=\"DocumentationCache\"></a>DocumentationCache</h4><p>这个文件夹记录 Xcode 获取对应文档的缓存。</p>\n<h4 id=\"iOS-Device-Logs\"><a href=\"#iOS-Device-Logs\" class=\"headerlink\" title=\"iOS Device Logs\"></a>iOS Device Logs</h4><p>这个文件夹记录每个模拟器设备产生的日志，看文件内容应该是 CoreData 方式保存的数据。</p>\n<h4 id=\"iOS-DeviceSupport\"><a href=\"#iOS-DeviceSupport\" class=\"headerlink\" title=\"iOS DeviceSupport\"></a>iOS DeviceSupport</h4><p>这个文件夹<strong>尤为重要</strong>，其中保存了 Xcode 系统版本支持信息。如果是从低版本 Xcode 一直升级上来的，这里可能会保存了很多低版本的系统支持，我们可以根据自身实际的需求，删减其中的内容。如果错误删除了，或者后期需要，可以在 Xcode Preference 中的 Components 面板中重新下载。</p>\n<h4 id=\"UserData\"><a href=\"#UserData\" class=\"headerlink\" title=\"UserData\"></a>UserData</h4><p>故名思义，用户数据文件夹。具体存放的内容与 Devices 文件夹中存放的有所重复，具体逻辑也不得而知了。</p>\n"},{"title":"大端与小端","date":"2019-01-01T11:34:16.000Z","_content":"\n## 起源\n众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。\n然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。\n\n## 发展\n> Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。  \n> ——《格利佛游记》乔纳森·斯威夫特（Gulliver's Travels by Jonathan Swift）  \n\n在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 [Danny Cohen](https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)) 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：**大端**、**小端**。\n在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为**内存地址**。而大小端的差别，就是根据内存地址存放方式的差别。\n\n### 大端\n高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。\n\n### 小端模式\n低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。\n\n下图表示 12345678 数字在内存中的表现差异：\n\n\n![bigLittleEndian.gif](https://cdn.iguan7u.cn/bigLittleEndian.gif \"bigLittleEndian.gif\")\n\n\n上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。\n\n## 原因\n> 存在即有意义。  \n\n小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：\n小端模式更符合计算运行规律。基本计算都有个铁则：**从低位算起**。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。\n相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。\n而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0/1 表示该数值为正数或者负数）。\n\n## 出现场景\n搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。\n\n","source":"_posts/大端与小端.md","raw":"---\ntitle: 大端与小端\ndate: 2019-01-01 19:34:16\ntags:\n---\n\n## 起源\n众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。\n然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。\n\n## 发展\n> Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。  \n> ——《格利佛游记》乔纳森·斯威夫特（Gulliver's Travels by Jonathan Swift）  \n\n在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 [Danny Cohen](https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)) 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：**大端**、**小端**。\n在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为**内存地址**。而大小端的差别，就是根据内存地址存放方式的差别。\n\n### 大端\n高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。\n\n### 小端模式\n低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。\n\n下图表示 12345678 数字在内存中的表现差异：\n\n\n![bigLittleEndian.gif](https://cdn.iguan7u.cn/bigLittleEndian.gif \"bigLittleEndian.gif\")\n\n\n上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。\n\n## 原因\n> 存在即有意义。  \n\n小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：\n小端模式更符合计算运行规律。基本计算都有个铁则：**从低位算起**。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。\n相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。\n而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0/1 表示该数值为正数或者负数）。\n\n## 出现场景\n搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。\n\n","slug":"大端与小端","published":1,"updated":"2022-02-23T13:14:20.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5he000arv058b7s9kxj","content":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>众所周知，计算机只存储 0&#x2F;1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0&#x2F;1 表示并保存起来，而一个 0&#x2F;1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。<br>然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。</p>\n<h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><blockquote>\n<p>Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。<br>——《格利佛游记》乔纳森·斯威夫特（Gulliver’s Travels by Jonathan Swift）  </p>\n</blockquote>\n<p>在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 <a href=\"https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)\">Danny Cohen</a> 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：<strong>大端</strong>、<strong>小端</strong>。<br>在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为<strong>内存地址</strong>。而大小端的差别，就是根据内存地址存放方式的差别。</p>\n<h3 id=\"大端\"><a href=\"#大端\" class=\"headerlink\" title=\"大端\"></a>大端</h3><p>高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。</p>\n<h3 id=\"小端模式\"><a href=\"#小端模式\" class=\"headerlink\" title=\"小端模式\"></a>小端模式</h3><p>低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。</p>\n<p>下图表示 12345678 数字在内存中的表现差异：</p>\n<p><img src=\"https://cdn.iguan7u.cn/bigLittleEndian.gif\" alt=\"bigLittleEndian.gif\" title=\"bigLittleEndian.gif\"></p>\n<p>上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><blockquote>\n<p>存在即有意义。  </p>\n</blockquote>\n<p>小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：<br>小端模式更符合计算运行规律。基本计算都有个铁则：<strong>从低位算起</strong>。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。<br>相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。<br>而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0&#x2F;1 表示该数值为正数或者负数）。</p>\n<h2 id=\"出现场景\"><a href=\"#出现场景\" class=\"headerlink\" title=\"出现场景\"></a>出现场景</h2><p>搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。</p>\n","site":{"data":{}},"excerpt":"起源\n众所周知，计算机只存储 0/1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0/1 表示并保存起来，而一个 0/1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSI","more":"<h2 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h2><p>众所周知，计算机只存储 0&#x2F;1 数据，任何自然世界中表达的信息，到达计算机层面，都会变成 0&#x2F;1 表示并保存起来，而一个 0&#x2F;1 的数据单元，我们称之为比特 (bit)。而在最初的计算机发展中，为了表示 0-9 的数据，以及最基本的运算符号，4 bit 便足以存储。随后当计算机需要存储 26 个英文字母，便发展到了需要 8 bit 作为一个存储单元，这就是计算机基础的编码标准 —— ACSII 编码标准。同时设定了 1 个 ACSII 编码存储单元为 1 个字节 (byte)。<br>然而，1 个 byte 显然不足以存储自然世界中的信息。那么，如果有序地组织 bytes 进行存储便引出了这篇文章的背景。</p>\n<h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><blockquote>\n<p>Lilliput 和 Blefuscu 这两个强国在过去的 36 个月中一直在苦战。战争的原因：大家都知道，吃鸡蛋的时候，原始的方法是打破鸡蛋较大的一端，可是那时皇帝的祖父由于小时候吃鸡蛋按这种方法把手指弄破了，因此他的父亲就下令，命令所有的子民吃鸡蛋必须先打破鸡蛋较小的一端，违令者重罚。然而老百姓对此法令极为反感，期间发生了多次叛乱，最终一个皇帝因此送命，而另一个丢了王位。<br>——《格利佛游记》乔纳森·斯威夫特（Gulliver’s Travels by Jonathan Swift）  </p>\n</blockquote>\n<p>在游记中，斗争两排以 Big Endian 和 Little Endian 自称 (-ian 尾缀表示人) 。一位网络协议开创者 <a href=\"https://en.wikipedia.org/wiki/Danny_Cohen_(engineer)\">Danny Cohen</a> 则首次将这个称呼引入计算机世界，并将其推广出去，中文翻译：<strong>大端</strong>、<strong>小端</strong>。<br>在计算机系统中，所有的信息都是有序地存储着的，其中每一个存储单元都有一个唯一的位置编码，称之为<strong>内存地址</strong>。而大小端的差别，就是根据内存地址存放方式的差别。</p>\n<h3 id=\"大端\"><a href=\"#大端\" class=\"headerlink\" title=\"大端\"></a>大端</h3><p>高位字节排放在内存低的地址端，低位字节排放在内存高的地址端。</p>\n<h3 id=\"小端模式\"><a href=\"#小端模式\" class=\"headerlink\" title=\"小端模式\"></a>小端模式</h3><p>低位字节排放在低的内存地址端，高位字节排放在高低内存地址端。</p>\n<p>下图表示 12345678 数字在内存中的表现差异：</p>\n<p><img src=\"https://cdn.iguan7u.cn/bigLittleEndian.gif\" alt=\"bigLittleEndian.gif\" title=\"bigLittleEndian.gif\"></p>\n<p>上图中展示的，方框中数字为存储的内容，方框下数字为该存储对应的地址。可以从图中了解到，大端模式是低内存地址保存实际数字高位的部分，而小端模式则是相反，低内存地址保存的是实际数字高位的部分。如果计算机知识比较薄弱的读者，可能会好奇怎么会用小端模式如此奇怪的方式去保存数据呢，大端模式看起来明显可读性更高。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><blockquote>\n<p>存在即有意义。  </p>\n</blockquote>\n<p>小端模式虽然明显有别于人类的正常理解，可是这么多年发展以来，小端模式能一直被人们所使用，必然有其必要性的：<br>小端模式更符合计算运行规律。基本计算都有个铁则：<strong>从低位算起</strong>。小端模式的优势可以从这里看出。举例说，两个数相加，需要从个位开始逐位相加，个位相加产生的进位数需要带到十位进行继续进行运算。小端模式在内存低位即可获取到个位的数值，十位数值则可以直接从下一个内存地址中获取。所以，数字运算能直接从低位地址一直遍历至最高位地址即可。其次，计算机根本不关心可读性。计算机不同于人类，只要存在固定的逻辑（不需要是否合理），计算机都能正常识别跟运行。因此，小端模式长久以来都被广泛采用。<br>相反，在大端模式下进行数值相加，在获取到数值内存地址后，还需要根据占用内存空间的长度，计算出该数值所占用内存地址最高位的空间，然后逐层往低位递归运算，运算效率就稍微低于小端模式了。<br>而大端模式下，除了上文提到的便于人们直观认知以外，计算机也容易获取该数值是正数还是负数（首位 0&#x2F;1 表示该数值为正数或者负数）。</p>\n<h2 id=\"出现场景\"><a href=\"#出现场景\" class=\"headerlink\" title=\"出现场景\"></a>出现场景</h2><p>搜索显示，小端模式一般出现于操作系统上（笔者认为可能跟上文提到的运算效率有关）；大端模式出现在通讯协议中（笔者认为可能方便人类直观调试网络通讯内容）。</p>\n"},{"title":"密钥文件的用户权限","date":"2022-01-25T09:27:19.000Z","_content":"\n## 前言\n\n笔者在 github 上配置了 ssh key 用于 git 同步操作，通过 ssh 方式操作 clone 不需要输入 github\n的账号密码，在开发设备迁移过程中有很好的体验，同时也能避免泄漏自己的 github 账号跟密码。但是每次迁移后，首次操作 git 必定能收到以下的错误信息：\n\n```other\nThe authenticity of host 'github.com (<no hostip for proxy command>)' can't be established.\nED25519 key fingerprint is SHA256:+fingerprint.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added 'github.com' (ED25519) to the list of known hosts.\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nPermissions 0644 for 'script_file_path' are too open.\nIt is required that your private key files are NOT accessible by others.\nThis private key will be ignored.\nLoad key \"script_file_path\": bad permissions\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n之前为止解决这个问题，一直都很机器式的输入 `chmod 600 script_file_path` 命令，解决权限问题，完全不明白为什么会遇到以上的报错信息、\n`600` 是什么内容。在这里，深入记录一下。\n\n## 原因\n\n从提示信息中很容易看出，`0644` 这个权限对于 ssh 私钥文件过于开放了，因此限制了私钥文件的使用。但是 `0644` 这个权限代表了什么呢？我们在\n`~/.ssh/` 目录中敲入一下命令，可以看到对应的结果\n\n```other\n.ssh $: ls -l .\n.ssh $: total 32\n-rw-r--r--@ 1 iGuan7u  staff  1499 Jan 15 17:43 private_key\n```\n\n其中 `-rw-r-—r—-@` 就是对应文件 private_key 的权限。在 linux 系统中，文件权限总共 10 个字符，在 macOS\n系统中，可能会出现 11 个字符，我们将其分为四组：\n\n![密钥文件的用户权限.png](https://cdn.iguan7u.cn/image/%E5%AF%86%E9%92%A5%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90.png)\n\n### 第一组\n\n其中第一组仅一个字符：\n\n- **- 指普通文件**\n- **d 指文件夹**\n- **l 指连接文件**\n\n### 第二、三、四组\n\n第二、三、四组的逻辑都一致，我们将其拆分为三个字符看：**r** 为读取权限、**w** 为写入权限、**x** 为执行权限，**-**\n为对应位置不支持该权限，举例：\n\n- **rw-** 为可读性可写权限，不可执行\n- **r—** 为仅可读权限\n- …\n\n而二、三、四组分别对应不同的用户范围，其中：\n\n- 第二组代表创建该文件的用户权限（创建者权限）\n- 第三组代表创建者所在的用户组的权限\n- 第四组代表其他用户组的权限\n\n### @\n\n@ 这个字符是 macOS 系统特有的，代表该文件拥有**拓展属性**，我们可以在 macOS 中使用 `xattr -l $file_path`\n查看对应文件的拓展属性。\n\n> 拓展属性属于操作系统特有的，macOS、Windows\n> 都有相关的功能，拓展属性中内容并不会直接记录到文件内容中。在开发过程中用于保存一些与特定文件强相关的持久性数据，非常好用。如文件的下载进度…\n\n## 解答问题\n\n那，600 跟 `rw-r—r—` 有什么关系呢？\n\n我们依然将权限分为三组，而每一组的三个字符分别对应二进制中的位数，`rw-` 可以看成 110，对应的十进制数字就是\n6，其他的两组同样的方式操作，即可以转换为方便理解的三位十进制数字了。（上述的 `rw-r—r—` 对应的十进制表示方式为 644）\n\n回到问题，设置为 600 权限，即代表除了当前用户外，其他的用户都无权查看、编辑、执行该文件。ssh 强制密钥不能被其他用户查看，从而保证密钥的安全性。\n","source":"_posts/密钥文件的用户权限.md","raw":"---\ntitle: 密钥文件的用户权限\ndate: 2022-01-25 17:27:19\ntags:\n---\n\n## 前言\n\n笔者在 github 上配置了 ssh key 用于 git 同步操作，通过 ssh 方式操作 clone 不需要输入 github\n的账号密码，在开发设备迁移过程中有很好的体验，同时也能避免泄漏自己的 github 账号跟密码。但是每次迁移后，首次操作 git 必定能收到以下的错误信息：\n\n```other\nThe authenticity of host 'github.com (<no hostip for proxy command>)' can't be established.\nED25519 key fingerprint is SHA256:+fingerprint.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added 'github.com' (ED25519) to the list of known hosts.\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nPermissions 0644 for 'script_file_path' are too open.\nIt is required that your private key files are NOT accessible by others.\nThis private key will be ignored.\nLoad key \"script_file_path\": bad permissions\ngit@github.com: Permission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n\n之前为止解决这个问题，一直都很机器式的输入 `chmod 600 script_file_path` 命令，解决权限问题，完全不明白为什么会遇到以上的报错信息、\n`600` 是什么内容。在这里，深入记录一下。\n\n## 原因\n\n从提示信息中很容易看出，`0644` 这个权限对于 ssh 私钥文件过于开放了，因此限制了私钥文件的使用。但是 `0644` 这个权限代表了什么呢？我们在\n`~/.ssh/` 目录中敲入一下命令，可以看到对应的结果\n\n```other\n.ssh $: ls -l .\n.ssh $: total 32\n-rw-r--r--@ 1 iGuan7u  staff  1499 Jan 15 17:43 private_key\n```\n\n其中 `-rw-r-—r—-@` 就是对应文件 private_key 的权限。在 linux 系统中，文件权限总共 10 个字符，在 macOS\n系统中，可能会出现 11 个字符，我们将其分为四组：\n\n![密钥文件的用户权限.png](https://cdn.iguan7u.cn/image/%E5%AF%86%E9%92%A5%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90.png)\n\n### 第一组\n\n其中第一组仅一个字符：\n\n- **- 指普通文件**\n- **d 指文件夹**\n- **l 指连接文件**\n\n### 第二、三、四组\n\n第二、三、四组的逻辑都一致，我们将其拆分为三个字符看：**r** 为读取权限、**w** 为写入权限、**x** 为执行权限，**-**\n为对应位置不支持该权限，举例：\n\n- **rw-** 为可读性可写权限，不可执行\n- **r—** 为仅可读权限\n- …\n\n而二、三、四组分别对应不同的用户范围，其中：\n\n- 第二组代表创建该文件的用户权限（创建者权限）\n- 第三组代表创建者所在的用户组的权限\n- 第四组代表其他用户组的权限\n\n### @\n\n@ 这个字符是 macOS 系统特有的，代表该文件拥有**拓展属性**，我们可以在 macOS 中使用 `xattr -l $file_path`\n查看对应文件的拓展属性。\n\n> 拓展属性属于操作系统特有的，macOS、Windows\n> 都有相关的功能，拓展属性中内容并不会直接记录到文件内容中。在开发过程中用于保存一些与特定文件强相关的持久性数据，非常好用。如文件的下载进度…\n\n## 解答问题\n\n那，600 跟 `rw-r—r—` 有什么关系呢？\n\n我们依然将权限分为三组，而每一组的三个字符分别对应二进制中的位数，`rw-` 可以看成 110，对应的十进制数字就是\n6，其他的两组同样的方式操作，即可以转换为方便理解的三位十进制数字了。（上述的 `rw-r—r—` 对应的十进制表示方式为 644）\n\n回到问题，设置为 600 权限，即代表除了当前用户外，其他的用户都无权查看、编辑、执行该文件。ssh 强制密钥不能被其他用户查看，从而保证密钥的安全性。\n","slug":"密钥文件的用户权限","published":1,"updated":"2022-02-26T14:32:18.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5he000brv050htze7sa","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>笔者在 github 上配置了 ssh key 用于 git 同步操作，通过 ssh 方式操作 clone 不需要输入 github<br>的账号密码，在开发设备迁移过程中有很好的体验，同时也能避免泄漏自己的 github 账号跟密码。但是每次迁移后，首次操作 git 必定能收到以下的错误信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs other\">The authenticity of host &#x27;github.com (&lt;no hostip for proxy command&gt;)&#x27; can&#x27;t be established.<br>ED25519 key fingerprint is SHA256:+fingerprint.<br>This key is not known by any other names<br>Are you sure you want to continue connecting (yes/no/[fingerprint])? yes<br>Warning: Permanently added &#x27;github.com&#x27; (ED25519) to the list of known hosts.<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>Permissions 0644 for &#x27;script_file_path&#x27; are too open.<br>It is required that your private key files are NOT accessible by others.<br>This private key will be ignored.<br>Load key &quot;script_file_path&quot;: bad permissions<br>git@github.com: Permission denied (publickey).<br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre></td></tr></table></figure>\n\n<p>之前为止解决这个问题，一直都很机器式的输入 <code>chmod 600 script_file_path</code> 命令，解决权限问题，完全不明白为什么会遇到以上的报错信息、<br><code>600</code> 是什么内容。在这里，深入记录一下。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>从提示信息中很容易看出，<code>0644</code> 这个权限对于 ssh 私钥文件过于开放了，因此限制了私钥文件的使用。但是 <code>0644</code> 这个权限代表了什么呢？我们在<br><code>~/.ssh/</code> 目录中敲入一下命令，可以看到对应的结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs other\">.ssh $: ls -l .<br>.ssh $: total 32<br>-rw-r--r--@ 1 iGuan7u  staff  1499 Jan 15 17:43 private_key<br></code></pre></td></tr></table></figure>\n\n<p>其中 <code>-rw-r-—r—-@</code> 就是对应文件 private_key 的权限。在 linux 系统中，文件权限总共 10 个字符，在 macOS<br>系统中，可能会出现 11 个字符，我们将其分为四组：</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/%E5%AF%86%E9%92%A5%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90.png\" alt=\"密钥文件的用户权限.png\"></p>\n<h3 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组\"></a>第一组</h3><p>其中第一组仅一个字符：</p>\n<ul>\n<li><strong>- 指普通文件</strong></li>\n<li><strong>d 指文件夹</strong></li>\n<li><strong>l 指连接文件</strong></li>\n</ul>\n<h3 id=\"第二、三、四组\"><a href=\"#第二、三、四组\" class=\"headerlink\" title=\"第二、三、四组\"></a>第二、三、四组</h3><p>第二、三、四组的逻辑都一致，我们将其拆分为三个字符看：<strong>r</strong> 为读取权限、<strong>w</strong> 为写入权限、<strong>x</strong> 为执行权限，**-**<br>为对应位置不支持该权限，举例：</p>\n<ul>\n<li><strong>rw-</strong> 为可读性可写权限，不可执行</li>\n<li><strong>r—</strong> 为仅可读权限</li>\n<li>…</li>\n</ul>\n<p>而二、三、四组分别对应不同的用户范围，其中：</p>\n<ul>\n<li>第二组代表创建该文件的用户权限（创建者权限）</li>\n<li>第三组代表创建者所在的用户组的权限</li>\n<li>第四组代表其他用户组的权限</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"@\"></a>@</h3><p>@ 这个字符是 macOS 系统特有的，代表该文件拥有<strong>拓展属性</strong>，我们可以在 macOS 中使用 <code>xattr -l $file_path</code><br>查看对应文件的拓展属性。</p>\n<blockquote>\n<p>拓展属性属于操作系统特有的，macOS、Windows<br>都有相关的功能，拓展属性中内容并不会直接记录到文件内容中。在开发过程中用于保存一些与特定文件强相关的持久性数据，非常好用。如文件的下载进度…</p>\n</blockquote>\n<h2 id=\"解答问题\"><a href=\"#解答问题\" class=\"headerlink\" title=\"解答问题\"></a>解答问题</h2><p>那，600 跟 <code>rw-r—r—</code> 有什么关系呢？</p>\n<p>我们依然将权限分为三组，而每一组的三个字符分别对应二进制中的位数，<code>rw-</code> 可以看成 110，对应的十进制数字就是<br>6，其他的两组同样的方式操作，即可以转换为方便理解的三位十进制数字了。（上述的 <code>rw-r—r—</code> 对应的十进制表示方式为 644）</p>\n<p>回到问题，设置为 600 权限，即代表除了当前用户外，其他的用户都无权查看、编辑、执行该文件。ssh 强制密钥不能被其他用户查看，从而保证密钥的安全性。</p>\n","site":{"data":{}},"excerpt":"前言\n笔者在 github 上配置了 ssh key 用于 git 同步操作，通过 ssh 方式操作 clone 不需要输入 github\n的账号密码，在开发设备迁移过程中有很好的体验，同时也能避免泄漏自己的 github 账号跟密码。但是每次迁移后，首次操作 git 必定能收到以下的错误信息：\n\nThe authenticity of host 'github.com (<no hostip f","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>笔者在 github 上配置了 ssh key 用于 git 同步操作，通过 ssh 方式操作 clone 不需要输入 github<br>的账号密码，在开发设备迁移过程中有很好的体验，同时也能避免泄漏自己的 github 账号跟密码。但是每次迁移后，首次操作 git 必定能收到以下的错误信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs other\">The authenticity of host &#x27;github.com (&lt;no hostip for proxy command&gt;)&#x27; can&#x27;t be established.<br>ED25519 key fingerprint is SHA256:+fingerprint.<br>This key is not known by any other names<br>Are you sure you want to continue connecting (yes/no/[fingerprint])? yes<br>Warning: Permanently added &#x27;github.com&#x27; (ED25519) to the list of known hosts.<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>Permissions 0644 for &#x27;script_file_path&#x27; are too open.<br>It is required that your private key files are NOT accessible by others.<br>This private key will be ignored.<br>Load key &quot;script_file_path&quot;: bad permissions<br>git@github.com: Permission denied (publickey).<br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre></td></tr></table></figure>\n\n<p>之前为止解决这个问题，一直都很机器式的输入 <code>chmod 600 script_file_path</code> 命令，解决权限问题，完全不明白为什么会遇到以上的报错信息、<br><code>600</code> 是什么内容。在这里，深入记录一下。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>从提示信息中很容易看出，<code>0644</code> 这个权限对于 ssh 私钥文件过于开放了，因此限制了私钥文件的使用。但是 <code>0644</code> 这个权限代表了什么呢？我们在<br><code>~/.ssh/</code> 目录中敲入一下命令，可以看到对应的结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs other\">.ssh $: ls -l .<br>.ssh $: total 32<br>-rw-r--r--@ 1 iGuan7u  staff  1499 Jan 15 17:43 private_key<br></code></pre></td></tr></table></figure>\n\n<p>其中 <code>-rw-r-—r—-@</code> 就是对应文件 private_key 的权限。在 linux 系统中，文件权限总共 10 个字符，在 macOS<br>系统中，可能会出现 11 个字符，我们将其分为四组：</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/%E5%AF%86%E9%92%A5%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90.png\" alt=\"密钥文件的用户权限.png\"></p>\n<h3 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组\"></a>第一组</h3><p>其中第一组仅一个字符：</p>\n<ul>\n<li><strong>- 指普通文件</strong></li>\n<li><strong>d 指文件夹</strong></li>\n<li><strong>l 指连接文件</strong></li>\n</ul>\n<h3 id=\"第二、三、四组\"><a href=\"#第二、三、四组\" class=\"headerlink\" title=\"第二、三、四组\"></a>第二、三、四组</h3><p>第二、三、四组的逻辑都一致，我们将其拆分为三个字符看：<strong>r</strong> 为读取权限、<strong>w</strong> 为写入权限、<strong>x</strong> 为执行权限，**-**<br>为对应位置不支持该权限，举例：</p>\n<ul>\n<li><strong>rw-</strong> 为可读性可写权限，不可执行</li>\n<li><strong>r—</strong> 为仅可读权限</li>\n<li>…</li>\n</ul>\n<p>而二、三、四组分别对应不同的用户范围，其中：</p>\n<ul>\n<li>第二组代表创建该文件的用户权限（创建者权限）</li>\n<li>第三组代表创建者所在的用户组的权限</li>\n<li>第四组代表其他用户组的权限</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"@\"></a>@</h3><p>@ 这个字符是 macOS 系统特有的，代表该文件拥有<strong>拓展属性</strong>，我们可以在 macOS 中使用 <code>xattr -l $file_path</code><br>查看对应文件的拓展属性。</p>\n<blockquote>\n<p>拓展属性属于操作系统特有的，macOS、Windows<br>都有相关的功能，拓展属性中内容并不会直接记录到文件内容中。在开发过程中用于保存一些与特定文件强相关的持久性数据，非常好用。如文件的下载进度…</p>\n</blockquote>\n<h2 id=\"解答问题\"><a href=\"#解答问题\" class=\"headerlink\" title=\"解答问题\"></a>解答问题</h2><p>那，600 跟 <code>rw-r—r—</code> 有什么关系呢？</p>\n<p>我们依然将权限分为三组，而每一组的三个字符分别对应二进制中的位数，<code>rw-</code> 可以看成 110，对应的十进制数字就是<br>6，其他的两组同样的方式操作，即可以转换为方便理解的三位十进制数字了。（上述的 <code>rw-r—r—</code> 对应的十进制表示方式为 644）</p>\n<p>回到问题，设置为 600 权限，即代表除了当前用户外，其他的用户都无权查看、编辑、执行该文件。ssh 强制密钥不能被其他用户查看，从而保证密钥的安全性。</p>\n"},{"title":"终于入手了人生第一台黑苹果","date":"2019-08-28T08:32:32.000Z","_content":"## 为什么选择黑苹果\n这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。\n\n### 是价钱的问题吗？\n配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。\n\n### 是因为喜欢“白嫖”吗？\n自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。\n\n### 生命在于折腾。\n\n**可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。**\n\n这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。\n我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。\n\n~~最后再升华一下：这是一种人生态度。~~\n\n## 配置\n- CPU：i7 9700K\n- 主板：Gigabyte Z390M Gaming\n- 内存：海盗船复仇者 16G DDR4 3200\n- 显卡：迪兰 RX580 2304sp 8G\n- 硬盘：三星 970evo 500G\n- 网卡：BCM94360CD（包括蓝牙）\n- 电源：EVGA 750P2 全模组\n- 散热：JONSBO 乔思伯 TW3-240\n- 机箱：JONSBO 乔思伯 C3-PLUS\n- 显示器：AOC U2790VQ 27” 4K\n- 键鼠：Magic Keyboard 2 & Mouse 2\n\n### 要不要 AMD Yes?\n\n![INTELvsAMD](https://cdn.iguan7u.cn/image/INTELvsAMD.png)\n\n\n其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。\n\n> 虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要**手动修改安装包，替换为支持 AMD 的内核** （有兴趣了解到，可以到 [AMD OSX](https://amd-osx.com) 论坛中查看一下）。虽然 macOS 内核项目 [XNU(XNU is Not Unix)](https://github.com/apple/darwin-xnu?) 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  \n\n最新的方法是直接通过 Clover 往内核注入 [AMD Patch](https://github.com/AMD-OSX/AMD_Vanilla)，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。\n经过一番挣扎之后，还是放弃 Yes 了… \n\n### 如何挑选主板？\n其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 [Buyer‘s Guide](https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/) 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。\n\n### 如何挑选显卡\n\n![AMDvsNVDIA](https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg)\n\n简单一句话，就是：**AMD Yes!**\n不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。\n当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。\n“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 [WebDrivers](https://www.tonymacx86.com/nvidia-drivers/) 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。[这里还有个小故事](https://www.jianshu.com/p/3753bbd8cd90)\n\n> Sierra Forever, or AMD Yes!  \n\n上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照[黑果小兵](https://blog.daliansky.net/Mojave-Hardware-Support-List.html)的硬件支持列表，选择合适的显卡。\n\n## 安装过程\n这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的[安装教程](https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/)，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。\n\n## 现状\n1. CPU 变频正常\n2. GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示\n3. 蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项\n4. Wi-Fi 正常\n5. 关机正常，断电正常\n6. 睡眠基本正常（蓝牙有几率出现小问题）\n7. iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）\n8. 音频输出正常\n9. 所有 USB 接口正常\n10. Airdrop 正常，handoff 正常\n11. 主板网口正常\n\n老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。\n对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。\n这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。\n\n## 问题\n1. 启动时几率性会遇到 Clover 的 `Couldn't allocate runtime area` 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案\n2. 几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）\n3. 几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒\n4. 启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）\n5. 主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入\n\n这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。\n\n## 最后说一句\n其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！\n\n最后上图一张：\n![成果](https://cdn.iguan7u.cn/image/IMG_0515.jpg)\n\n#折腾/MacOS","source":"_posts/终于入手了人生第一台黑苹果.md","raw":"---\ntitle: 终于入手了人生第一台黑苹果\ndate: 2019-08-28 16:32:32\ntags:\n---\n## 为什么选择黑苹果\n这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。\n\n### 是价钱的问题吗？\n配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。\n\n### 是因为喜欢“白嫖”吗？\n自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。\n\n### 生命在于折腾。\n\n**可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。**\n\n这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。\n我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。\n\n~~最后再升华一下：这是一种人生态度。~~\n\n## 配置\n- CPU：i7 9700K\n- 主板：Gigabyte Z390M Gaming\n- 内存：海盗船复仇者 16G DDR4 3200\n- 显卡：迪兰 RX580 2304sp 8G\n- 硬盘：三星 970evo 500G\n- 网卡：BCM94360CD（包括蓝牙）\n- 电源：EVGA 750P2 全模组\n- 散热：JONSBO 乔思伯 TW3-240\n- 机箱：JONSBO 乔思伯 C3-PLUS\n- 显示器：AOC U2790VQ 27” 4K\n- 键鼠：Magic Keyboard 2 & Mouse 2\n\n### 要不要 AMD Yes?\n\n![INTELvsAMD](https://cdn.iguan7u.cn/image/INTELvsAMD.png)\n\n\n其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。\n\n> 虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要**手动修改安装包，替换为支持 AMD 的内核** （有兴趣了解到，可以到 [AMD OSX](https://amd-osx.com) 论坛中查看一下）。虽然 macOS 内核项目 [XNU(XNU is Not Unix)](https://github.com/apple/darwin-xnu?) 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  \n\n最新的方法是直接通过 Clover 往内核注入 [AMD Patch](https://github.com/AMD-OSX/AMD_Vanilla)，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。\n经过一番挣扎之后，还是放弃 Yes 了… \n\n### 如何挑选主板？\n其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 [Buyer‘s Guide](https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/) 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。\n\n### 如何挑选显卡\n\n![AMDvsNVDIA](https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg)\n\n简单一句话，就是：**AMD Yes!**\n不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。\n当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。\n“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 [WebDrivers](https://www.tonymacx86.com/nvidia-drivers/) 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。[这里还有个小故事](https://www.jianshu.com/p/3753bbd8cd90)\n\n> Sierra Forever, or AMD Yes!  \n\n上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照[黑果小兵](https://blog.daliansky.net/Mojave-Hardware-Support-List.html)的硬件支持列表，选择合适的显卡。\n\n## 安装过程\n这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的[安装教程](https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/)，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。\n\n## 现状\n1. CPU 变频正常\n2. GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示\n3. 蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项\n4. Wi-Fi 正常\n5. 关机正常，断电正常\n6. 睡眠基本正常（蓝牙有几率出现小问题）\n7. iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）\n8. 音频输出正常\n9. 所有 USB 接口正常\n10. Airdrop 正常，handoff 正常\n11. 主板网口正常\n\n老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。\n对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。\n这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。\n\n## 问题\n1. 启动时几率性会遇到 Clover 的 `Couldn't allocate runtime area` 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案\n2. 几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）\n3. 几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒\n4. 启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）\n5. 主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入\n\n这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。\n\n## 最后说一句\n其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！\n\n最后上图一张：\n![成果](https://cdn.iguan7u.cn/image/IMG_0515.jpg)\n\n#折腾/MacOS","slug":"终于入手了人生第一台黑苹果","published":1,"updated":"2022-02-23T13:14:20.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hf000crv057rjlgovx","content":"<h2 id=\"为什么选择黑苹果\"><a href=\"#为什么选择黑苹果\" class=\"headerlink\" title=\"为什么选择黑苹果\"></a>为什么选择黑苹果</h2><p>这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。</p>\n<h3 id=\"是价钱的问题吗？\"><a href=\"#是价钱的问题吗？\" class=\"headerlink\" title=\"是价钱的问题吗？\"></a>是价钱的问题吗？</h3><p>配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。</p>\n<h3 id=\"是因为喜欢“白嫖”吗？\"><a href=\"#是因为喜欢“白嫖”吗？\" class=\"headerlink\" title=\"是因为喜欢“白嫖”吗？\"></a>是因为喜欢“白嫖”吗？</h3><p>自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。</p>\n<h3 id=\"生命在于折腾。\"><a href=\"#生命在于折腾。\" class=\"headerlink\" title=\"生命在于折腾。\"></a>生命在于折腾。</h3><p><strong>可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。</strong></p>\n<p>这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。<br>我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。</p>\n<p><del>最后再升华一下：这是一种人生态度。</del></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li>CPU：i7 9700K</li>\n<li>主板：Gigabyte Z390M Gaming</li>\n<li>内存：海盗船复仇者 16G DDR4 3200</li>\n<li>显卡：迪兰 RX580 2304sp 8G</li>\n<li>硬盘：三星 970evo 500G</li>\n<li>网卡：BCM94360CD（包括蓝牙）</li>\n<li>电源：EVGA 750P2 全模组</li>\n<li>散热：JONSBO 乔思伯 TW3-240</li>\n<li>机箱：JONSBO 乔思伯 C3-PLUS</li>\n<li>显示器：AOC U2790VQ 27” 4K</li>\n<li>键鼠：Magic Keyboard 2 &amp; Mouse 2</li>\n</ul>\n<h3 id=\"要不要-AMD-Yes\"><a href=\"#要不要-AMD-Yes\" class=\"headerlink\" title=\"要不要 AMD Yes?\"></a>要不要 AMD Yes?</h3><p><img src=\"https://cdn.iguan7u.cn/image/INTELvsAMD.png\" alt=\"INTELvsAMD\"></p>\n<p>其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。</p>\n<blockquote>\n<p>虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要<strong>手动修改安装包，替换为支持 AMD 的内核</strong> （有兴趣了解到，可以到 <a href=\"https://amd-osx.com/\">AMD OSX</a> 论坛中查看一下）。虽然 macOS 内核项目 <a href=\"https://github.com/apple/darwin-xnu\">XNU(XNU is Not Unix)</a> 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  </p>\n</blockquote>\n<p>最新的方法是直接通过 Clover 往内核注入 <a href=\"https://github.com/AMD-OSX/AMD_Vanilla\">AMD Patch</a>，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。<br>经过一番挣扎之后，还是放弃 Yes 了… </p>\n<h3 id=\"如何挑选主板？\"><a href=\"#如何挑选主板？\" class=\"headerlink\" title=\"如何挑选主板？\"></a>如何挑选主板？</h3><p>其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 <a href=\"https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/\">Buyer‘s Guide</a> 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。</p>\n<h3 id=\"如何挑选显卡\"><a href=\"#如何挑选显卡\" class=\"headerlink\" title=\"如何挑选显卡\"></a>如何挑选显卡</h3><p><img src=\"https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg\" alt=\"AMDvsNVDIA\"></p>\n<p>简单一句话，就是：<strong>AMD Yes!</strong><br>不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。<br>当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。<br>“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 <a href=\"https://www.tonymacx86.com/nvidia-drivers/\">WebDrivers</a> 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。<a href=\"https://www.jianshu.com/p/3753bbd8cd90\">这里还有个小故事</a></p>\n<blockquote>\n<p>Sierra Forever, or AMD Yes!  </p>\n</blockquote>\n<p>上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照<a href=\"https://blog.daliansky.net/Mojave-Hardware-Support-List.html\">黑果小兵</a>的硬件支持列表，选择合适的显卡。</p>\n<h2 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h2><p>这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的<a href=\"https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/\">安装教程</a>，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><ol>\n<li>CPU 变频正常</li>\n<li>GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示</li>\n<li>蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项</li>\n<li>Wi-Fi 正常</li>\n<li>关机正常，断电正常</li>\n<li>睡眠基本正常（蓝牙有几率出现小问题）</li>\n<li>iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）</li>\n<li>音频输出正常</li>\n<li>所有 USB 接口正常</li>\n<li>Airdrop 正常，handoff 正常</li>\n<li>主板网口正常</li>\n</ol>\n<p>老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。<br>对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。<br>这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>启动时几率性会遇到 Clover 的 <code>Couldn&#39;t allocate runtime area</code> 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案</li>\n<li>几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）</li>\n<li>几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒</li>\n<li>启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）</li>\n<li>主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入</li>\n</ol>\n<p>这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。</p>\n<h2 id=\"最后说一句\"><a href=\"#最后说一句\" class=\"headerlink\" title=\"最后说一句\"></a>最后说一句</h2><p>其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！</p>\n<p>最后上图一张：<br><img src=\"https://cdn.iguan7u.cn/image/IMG_0515.jpg\" alt=\"成果\"></p>\n<p>#折腾&#x2F;MacOS</p>\n","site":{"data":{}},"excerpt":"为什么选择黑苹果\n这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。\n\n是价钱的问题吗？\n配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减","more":"<h2 id=\"为什么选择黑苹果\"><a href=\"#为什么选择黑苹果\" class=\"headerlink\" title=\"为什么选择黑苹果\"></a>为什么选择黑苹果</h2><p>这个真的是老生常谈的话题了，为什么会选择黑苹果，不直接买 iMac？这个确实值得思考。</p>\n<h3 id=\"是价钱的问题吗？\"><a href=\"#是价钱的问题吗？\" class=\"headerlink\" title=\"是价钱的问题吗？\"></a>是价钱的问题吗？</h3><p>配套下来，整套电脑的价格也差不多能摸到 Mac mini 的入门了，因此也不完全是因为价钱问题。当然确实也占了很大的一部分，毕竟谁都希望钱花出去，能获得该有的，甚至超出该有的回报的。这整套配置下来，如果选择白苹果的话，可能需要接近 20K 的价钱，可是手动攥的话，价钱可以减半。</p>\n<h3 id=\"是因为喜欢“白嫖”吗？\"><a href=\"#是因为喜欢“白嫖”吗？\" class=\"headerlink\" title=\"是因为喜欢“白嫖”吗？\"></a>是因为喜欢“白嫖”吗？</h3><p>自己手上也有 macbook pro 2015 mid，macbook pro 2018 late，算上 iPad, iPhone, Apple TV 4K, Apple Watch，自己也算是一个勉强及格的果粉，因此也不属于说某些“正版党”嘴上所喷的“白嫖王”。自己有购买正版软件，有购买正版游戏，也有订阅付费服务。自己的生活确实并不富裕，房贷加日常开销差不多已经能压垮自己了，可是对于部分优秀的产品自己确实会想尽自己的能力支持一下其开发者，毕竟自己也是一名软件开发工程师。</p>\n<h3 id=\"生命在于折腾。\"><a href=\"#生命在于折腾。\" class=\"headerlink\" title=\"生命在于折腾。\"></a>生命在于折腾。</h3><p><strong>可是我依然选择黑苹果。再给我选择一次，我依然选择黑苹果。</strong></p>\n<p>这也许已经不是选择的问题了，自己重度使用 macOS 已经超过五年时间了，在此之前，也有半年时间的黑苹果使用经验（在联想的 Y470p 中安装过黑苹果），自己对于白苹果跟黑苹果的体验差异应该是有所概念，自己也很清楚，白苹果提供的开箱即用并不是自己所追求的。如果是用于公司开发的电脑，确实我应该选择白苹果，毕竟平台的稳定性直接影响开发效率，无论是谁都不希望在工作期间会遇到各种兼容性的问题。可是，假若是自己的电脑，对待它应该就像对待自己的生活，你有选择一帆风顺、平平淡淡的权利，同时你也有波澜壮阔、披荆斩棘的向往。<br>我向往后者，迎难而上确实让自己的生活变得充满挫折，可是与此同时，你让你的生活充满了“谈资”。在商店选择配置然后直接付款等送货的过程，远比不上组装、装系统、死机、BOOM 的经历所带给人的吸引，哈哈哈哈。</p>\n<p><del>最后再升华一下：这是一种人生态度。</del></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><ul>\n<li>CPU：i7 9700K</li>\n<li>主板：Gigabyte Z390M Gaming</li>\n<li>内存：海盗船复仇者 16G DDR4 3200</li>\n<li>显卡：迪兰 RX580 2304sp 8G</li>\n<li>硬盘：三星 970evo 500G</li>\n<li>网卡：BCM94360CD（包括蓝牙）</li>\n<li>电源：EVGA 750P2 全模组</li>\n<li>散热：JONSBO 乔思伯 TW3-240</li>\n<li>机箱：JONSBO 乔思伯 C3-PLUS</li>\n<li>显示器：AOC U2790VQ 27” 4K</li>\n<li>键鼠：Magic Keyboard 2 &amp; Mouse 2</li>\n</ul>\n<h3 id=\"要不要-AMD-Yes\"><a href=\"#要不要-AMD-Yes\" class=\"headerlink\" title=\"要不要 AMD Yes?\"></a>要不要 AMD Yes?</h3><p><img src=\"https://cdn.iguan7u.cn/image/INTELvsAMD.png\" alt=\"INTELvsAMD\"></p>\n<p>其实在攥这份配置的时候，真的很纠结。适逢刚好 AMD 出了 Ryzen 3700X，所有媒体测评都在疯狂呐喊 “AMD Yes!” 的时刻，这个时候真的让自己陷入了一个选择的困境，毕竟测评的结果就在这里，如果不是考虑黑苹果需求，真的是毫不犹豫就加入了 “AMD Yes!” 的队列，可是黑苹果配置第一个需要明白的就是 CPU 必须要选择 Intel 的。</p>\n<blockquote>\n<p>虽然近年来一直有 AMD Hackintosh 的文章发表， 其实这里的 macOS 安装包都是需要<strong>手动修改安装包，替换为支持 AMD 的内核</strong> （有兴趣了解到，可以到 <a href=\"https://amd-osx.com/\">AMD OSX</a> 论坛中查看一下）。虽然 macOS 内核项目 <a href=\"https://github.com/apple/darwin-xnu\">XNU(XNU is Not Unix)</a> 是开源的，国外的强人有机会将它编译为支持 AMD，可是缺少苹果官方的支持，至少后期的版本升级中，可能会出现不可预料的问题，而那些问题可能并不是稍微 Google 一下就能解决了。  </p>\n</blockquote>\n<p>最新的方法是直接通过 Clover 往内核注入 <a href=\"https://github.com/AMD-OSX/AMD_Vanilla\">AMD Patch</a>，无需再手动替换 macOS 安装包的内核，然而遇到问题估计我还是会一脸懵逼，连寻找解决方法的能力都没有。<br>经过一番挣扎之后，还是放弃 Yes 了… </p>\n<h3 id=\"如何挑选主板？\"><a href=\"#如何挑选主板？\" class=\"headerlink\" title=\"如何挑选主板？\"></a>如何挑选主板？</h3><p>其实选对主板，你的黑苹果已经成功了 80%，所以在购买主板上，必须要慎重选择。简单来说，你可以选择在远景论坛或者 tonymacx86 上已经有人成功驱动的主板，尽量站在巨人的肩膀上。所以在组装电脑前，最好确认后期是否有安装黑苹果的需求。而选择的列表，可以直接参考 tonymacx86 上的 <a href=\"https://www.tonymacx86.com/buyersguide/building-a-customac-hackintosh-the-ultimate-buyers-guide/\">Buyer‘s Guide</a> 主板推荐。如果不幸你已经购买了主板，可是该主板又不在推荐列表上，那么你可能会遇到很多难以表述的问题，增加你安装黑苹果的难度。</p>\n<h3 id=\"如何挑选显卡\"><a href=\"#如何挑选显卡\" class=\"headerlink\" title=\"如何挑选显卡\"></a>如何挑选显卡</h3><p><img src=\"https://cdn.iguan7u.cn/image/AMDvsNVDIA.jpg\" alt=\"AMDvsNVDIA\"></p>\n<p>简单一句话，就是：<strong>AMD Yes!</strong><br>不同于 CPU，在选择 GPU 上要尽可能的选择 AMD，因为苹果跟 AMD 有官方的合作，在高端的 iMac, MacBook Pro, 甚至 Mac Pro 上使用的，都是 AMD 的专业显卡。其实，苹果跟 AMD 一直有签订合作协议，因此在黑苹果上，选择 AMD 显卡是顺理成章的。<br>当然，我也很清楚在 GPU 领域，AMD 是真的 Yes 不起来的，NVDIA 用 12nm 制程工艺依然能将 AMD 的 7nm 制程工艺打到找不着北，AMD 长期使用高端定位的显卡对标 NVDIA 的中端定位，最新的旗舰 RX 5700XT 只能对标到 RTX2070 super (Radeon VII 确实很强，也只能对标 GTX1080Ti，而且 AMD 已经将其停产了)，以至于 NVDIA 当前的市场占用率接近 80%，一骑绝尘。<br>“那么我能不能选择 NVDIA ？”可以是可以，我真的不建议。macOS 在 GTX7XX 显卡后不再原生支持 NVDIA 的显卡，而 NVDIA 在在其后开发了 <a href=\"https://www.tonymacx86.com/nvidia-drivers/\">WebDrivers</a> 驱动，让帕斯卡架构的显卡能在 macOS 上正常驱动，但在 macOS High Sierra 后，苹果不再给英伟达签发证书，导致 WebDriver 无法在 Mojave 上驱动。<a href=\"https://www.jianshu.com/p/3753bbd8cd90\">这里还有个小故事</a></p>\n<blockquote>\n<p>Sierra Forever, or AMD Yes!  </p>\n</blockquote>\n<p>上面说了一大堆，反正就是为了省事，不要执着选择 NVDIA 显卡。当然，也不是所有的 AMD 显卡都能被 macOS 所支持，这里可以参照<a href=\"https://blog.daliansky.net/Mojave-Hardware-Support-List.html\">黑果小兵</a>的硬件支持列表，选择合适的显卡。</p>\n<h2 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h2><p>这个过于复杂，考虑后期单独写一篇文章进行介绍。其实主要的安装过程都能在 tonymacx86 上找到详细的<a href=\"https://www.tonymacx86.com/resources/multibeast-11-3-0-mojave.430/\">安装教程</a>，如果你无法看懂上面的文章，可能后期的排查问题的也会遇到很大的困难，建议还是费点心思将上面的教程啃下来。</p>\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><ol>\n<li>CPU 变频正常</li>\n<li>GPU 正常驱动，硬件加速正常，4k Hidpi 正常显示</li>\n<li>蓝牙启动正常，Clover 启动页面能通过 Magic Keyboard 选择启动项</li>\n<li>Wi-Fi 正常</li>\n<li>关机正常，断电正常</li>\n<li>睡眠基本正常（蓝牙有几率出现小问题）</li>\n<li>iCloud 登录正常，iCloud Drive 使用正常，AppStore 应用下载正常，iMessage 收信正常（没有发送 iMessage 的对象）</li>\n<li>音频输出正常</li>\n<li>所有 USB 接口正常</li>\n<li>Airdrop 正常，handoff 正常</li>\n<li>主板网口正常</li>\n</ol>\n<p>老实说能去到这种驱动程度已经是出乎意料了，很多功能即便是在我 MacBook Pro 上也并没有使用到（还要什么自行车呢）。以上功能对于普通开发者来说，已经完全能正常运用到生产开发中了，对于视频编辑来说，也应该是直接能使用了。<br>对比手上的 MacBook Pro 15” 2018，机子上的 RX580 比 Radeon Pro 555X 真的不知道高上了多少个等级。<br>这里又回到文章的开头，盗版与正版的问题，我真的不否认，如此安装的 macOS 属于盗版，读者看到这里可以开喷。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>启动时几率性会遇到 Clover 的 <code>Couldn&#39;t allocate runtime area</code> 错误，重启后一般正常，功能不受影响，目前正在努力寻找解决方案</li>\n<li>几率性睡眠后蓝牙模块会加载失败，导致 Magic Keyboard 或者 Magic Mouse 无法唤醒主机（因此我尽量关机，不选择睡眠）</li>\n<li>几率性睡眠启动后会黑屏，十秒内重新进入睡眠状态，需要按电源键彻底唤醒</li>\n<li>启动过程中从第一个苹果 loading 到第二个苹果 loading 会闪一下屏幕，进入系统后无任何异常（单纯就闪一下）</li>\n<li>主板 HDMI 无法正常显示，注入 framebuffer 后 RX580 无法驱动，因此选择放弃 framebuffer 注入</li>\n</ol>\n<p>这些问题目前都不影响正常的使用，可是又正如文章开头所描述，我个人是无法对这些问题视而不见的，这些问题是我苦恼的来源，同时也是我的兴趣所在。我会争取将它们都解决完成的。</p>\n<h2 id=\"最后说一句\"><a href=\"#最后说一句\" class=\"headerlink\" title=\"最后说一句\"></a>最后说一句</h2><p>其实这篇文章的目的，就是希望告诉那些仍然在纠结是否选择黑苹果的人一个定心丸，这条路是完全可行的，如果你稍微有点闲暇时间，或者希望找点日常的乐子，可以选择它。这里的乐趣是在工作的应用开发过程中所没有的！</p>\n<p>最后上图一张：<br><img src=\"https://cdn.iguan7u.cn/image/IMG_0515.jpg\" alt=\"成果\"></p>\n<p>#折腾&#x2F;MacOS</p>\n"},{"title":"谈谈敏捷开发","date":"2020-11-08T13:52:51.000Z","_content":"\n# 谈谈敏捷开发\n好久没有更新一下博客，最近有在尝试新的领域，可是一直没能积累下什么重要的知识、或者形成了什么重要的知识体系，就没能写下什么有意义的记录。可是很偶然的机会看到一个视频，里面讲述的，乔布斯谈论关于【流程与人才】的理解，基本可以总结为：苹果没有像 IBM 一样衰落，很大一部分原因是苹果没有执行像 IBM 一样严格的流程管理，使得有能力、有才华的人才能够不受大公司中条条框框的约束，充分发挥自己优势，最终促使苹果一次又一次的震惊世界。\n\n<video id=\"video\" controls=\"\" preload=\"none\" poster=\"https://image-1251248522.cos.ap-guangzhou.myqcloud.com/video/SZ37WnlNCIihpLRV.MP4\"></video>\n\n看到这个视频的时候，脑子中转过了好多好多的话语，没能按耐住自己的情绪，终究还是在 Twitter 中直接开喷。当然，喷的并不是乔布斯或者是他的言论，**乔帮主**在国内一波又一波媒体、开发者的吹捧下，早就已经走上了“冰封王座”。他的一生、创办苹果的风风雨雨，相信拜读过《乔布斯传》的人都能已经耳熟能详了，这里不再细说。总而言之，对于笔者自身，远远还达不到批判他的言辞的资格。\n\n> ~~废话说了那么多，结果原来只是像表达自己的弱小~~\n\n乔布斯确实过于优秀了，以至于越来越多的年轻人、创业者，都想要向他学习，见贤思齐焉。而学习最简单不过的方式，就是模仿。现在越来越容易听到那些晦涩难懂，可是由显得高端深奥的词汇。似乎在这种谈吐中更容易体现出自身对于产品思考的深入。\n\n“把握用户体验”，“重新定义 XX”，甚至 “打破流程”。“ IBM 之所以没落，就是因为他大公司中繁重的流程，约束的条条框框。” 所以我们要注重人才的才华展示，淡化流程。乔布斯所表达的观点，我们全盘接受。\n\n这样子的学习，简单至极。\n\n**流程不再重要了。**—— 这就是为什么现在产品经理跟开发工程师之间存在如此对立的原因。\n\n当然，其实乔布斯并非推动国内各大企业打破传统、废除流程的唯一功臣，另外一个更广为人知的，当然是数早已被广为人知的、被誉为中国第一产品经理的 —— 张小龙。如果你不知道这个人的话，你可以点击 (Ctrl+W) 组合键，快速查询这个人的相关信息。^_^ 得益于他的知名度以及微信的成功，“打破流程”、“简化流程”、“把握用户体验” 获得了一个更加接地气的名称 —— “**小步快跑，敏捷开发**”。\n\n对比于传统应用开发方式，敏捷开发在当前互联网形式上确为更加合适，毫不夸张的说，如果目前的产品开发还按照从前的开发形式，普通创业公司绝大部分会在产品推出之前，就将所有的开发经费耗光。这个时候没有任何知名度、也没有成型的产品，根本无从谈起融资以及上市。\n\n## 小步快跑、敏捷开发\n仔细考虑，其实这种开发方式在起步阶段是比较合理的。一周一个小版本，一个月一个大版本，对每次开发的新功能做好足够的调研以及打点统计，能够在不进行市场调查的前提上获取用户对于功能的喜好程度，从而在后续的开发中对特定的功能进行资源的倾斜，更大程度上去**取悦用户**。\n不得不说，微信在初期发展中，摸索到了**摇一摇**以及**朋友圈**这两大功能，然后持续在上面增加功能，优化体验，让用户真正的粘附在了微信生态上，也算是对小步快跑、敏捷开发的很好体现。微信的成功，也让更多的公司相信这种开发模式的正确性。\n\n我们来仔细捋一下这种开发模式的要点：\n\n1. 小版本周期短\n2. 小版本所携带新功能有针对性\n3. 开发过程中对新功能做好打点统计\n4. 产品上线后进行需求复盘，通过统计上报，得知用户对于新功能的喜好程度\n5. 对下一新版本的开发计划进行评估\n\n其中，复盘步骤对于敏捷开发的模式尤为重要。并且不仅是产品经理，包括开发人员都需要参与到复盘的步骤中。对于一个开发人员，得知自己所开发功能受到用户的喜爱，自身对于下个版本的开发积极性也会有相应的提高。\n\n## 真实的敏捷开发\n可是，有多少公司又能很好地在版本迭代的过程中持续遵循上述的要点呢？不少的公司更多的只是喊着敏捷开发的口号，在更短的时间内，往产品中堆砌着更多的功能，从而导致开发人员在长时间内一直保持着难以接受的开发强度，最终导致人员的流失，项目的失败。\n\n笔者从自身的工作环境中，感受到两点：\n\n- 老板过多地参与进项目开发的细节中\n- 复盘步骤的缺失，或者复盘步骤对于产品经理们的负反馈缺失\n\n笔者对于第一点真是深有体会。其实老板们关注细节无可厚非，可是过多的参与到项目开发中，很容易导致到开发节奏混乱，无法保持小版本迭代的步骤中。因为版本开发迭代期间，并不会频繁地推送到老板处体验，只能在项目上线阶段提交给老板进行上线前的最后体验。正常情况下，老板应该对这个功能开发进行最后的确认，确认这个版本是否与开发初期所定下的发展方向一致，而不应该对细节进行过多的反馈，一来这个环节在开发过程中早就经过产品经理的把控；二来开发人员、乃至于产品经理，都很难对老板所提出的细节要求说不，容易导致项目进度一拖再拖。~~三来甚至会过度打击产品经理的积极性，最终导致产品经理不再创新，只会揣测老板的心思。~~\n\n即便是成功至此的微信，笔者感觉它都已经不再是认真遵循着敏捷开发的模式了，大家可以从微信的招聘口号中可以感受一下：\n\n> 做一个伟大的产品来取悦**自己**。\n\n## 后注\n毕竟这片文章只是有感而发，想到哪写到哪，尚未经过深入思考。请读者们轻喷。\n","source":"_posts/谈谈敏捷开发.md","raw":"---\ntitle: 谈谈敏捷开发\ndate: 2020-11-08 21:52:51\ntags:\n---\n\n# 谈谈敏捷开发\n好久没有更新一下博客，最近有在尝试新的领域，可是一直没能积累下什么重要的知识、或者形成了什么重要的知识体系，就没能写下什么有意义的记录。可是很偶然的机会看到一个视频，里面讲述的，乔布斯谈论关于【流程与人才】的理解，基本可以总结为：苹果没有像 IBM 一样衰落，很大一部分原因是苹果没有执行像 IBM 一样严格的流程管理，使得有能力、有才华的人才能够不受大公司中条条框框的约束，充分发挥自己优势，最终促使苹果一次又一次的震惊世界。\n\n<video id=\"video\" controls=\"\" preload=\"none\" poster=\"https://image-1251248522.cos.ap-guangzhou.myqcloud.com/video/SZ37WnlNCIihpLRV.MP4\"></video>\n\n看到这个视频的时候，脑子中转过了好多好多的话语，没能按耐住自己的情绪，终究还是在 Twitter 中直接开喷。当然，喷的并不是乔布斯或者是他的言论，**乔帮主**在国内一波又一波媒体、开发者的吹捧下，早就已经走上了“冰封王座”。他的一生、创办苹果的风风雨雨，相信拜读过《乔布斯传》的人都能已经耳熟能详了，这里不再细说。总而言之，对于笔者自身，远远还达不到批判他的言辞的资格。\n\n> ~~废话说了那么多，结果原来只是像表达自己的弱小~~\n\n乔布斯确实过于优秀了，以至于越来越多的年轻人、创业者，都想要向他学习，见贤思齐焉。而学习最简单不过的方式，就是模仿。现在越来越容易听到那些晦涩难懂，可是由显得高端深奥的词汇。似乎在这种谈吐中更容易体现出自身对于产品思考的深入。\n\n“把握用户体验”，“重新定义 XX”，甚至 “打破流程”。“ IBM 之所以没落，就是因为他大公司中繁重的流程，约束的条条框框。” 所以我们要注重人才的才华展示，淡化流程。乔布斯所表达的观点，我们全盘接受。\n\n这样子的学习，简单至极。\n\n**流程不再重要了。**—— 这就是为什么现在产品经理跟开发工程师之间存在如此对立的原因。\n\n当然，其实乔布斯并非推动国内各大企业打破传统、废除流程的唯一功臣，另外一个更广为人知的，当然是数早已被广为人知的、被誉为中国第一产品经理的 —— 张小龙。如果你不知道这个人的话，你可以点击 (Ctrl+W) 组合键，快速查询这个人的相关信息。^_^ 得益于他的知名度以及微信的成功，“打破流程”、“简化流程”、“把握用户体验” 获得了一个更加接地气的名称 —— “**小步快跑，敏捷开发**”。\n\n对比于传统应用开发方式，敏捷开发在当前互联网形式上确为更加合适，毫不夸张的说，如果目前的产品开发还按照从前的开发形式，普通创业公司绝大部分会在产品推出之前，就将所有的开发经费耗光。这个时候没有任何知名度、也没有成型的产品，根本无从谈起融资以及上市。\n\n## 小步快跑、敏捷开发\n仔细考虑，其实这种开发方式在起步阶段是比较合理的。一周一个小版本，一个月一个大版本，对每次开发的新功能做好足够的调研以及打点统计，能够在不进行市场调查的前提上获取用户对于功能的喜好程度，从而在后续的开发中对特定的功能进行资源的倾斜，更大程度上去**取悦用户**。\n不得不说，微信在初期发展中，摸索到了**摇一摇**以及**朋友圈**这两大功能，然后持续在上面增加功能，优化体验，让用户真正的粘附在了微信生态上，也算是对小步快跑、敏捷开发的很好体现。微信的成功，也让更多的公司相信这种开发模式的正确性。\n\n我们来仔细捋一下这种开发模式的要点：\n\n1. 小版本周期短\n2. 小版本所携带新功能有针对性\n3. 开发过程中对新功能做好打点统计\n4. 产品上线后进行需求复盘，通过统计上报，得知用户对于新功能的喜好程度\n5. 对下一新版本的开发计划进行评估\n\n其中，复盘步骤对于敏捷开发的模式尤为重要。并且不仅是产品经理，包括开发人员都需要参与到复盘的步骤中。对于一个开发人员，得知自己所开发功能受到用户的喜爱，自身对于下个版本的开发积极性也会有相应的提高。\n\n## 真实的敏捷开发\n可是，有多少公司又能很好地在版本迭代的过程中持续遵循上述的要点呢？不少的公司更多的只是喊着敏捷开发的口号，在更短的时间内，往产品中堆砌着更多的功能，从而导致开发人员在长时间内一直保持着难以接受的开发强度，最终导致人员的流失，项目的失败。\n\n笔者从自身的工作环境中，感受到两点：\n\n- 老板过多地参与进项目开发的细节中\n- 复盘步骤的缺失，或者复盘步骤对于产品经理们的负反馈缺失\n\n笔者对于第一点真是深有体会。其实老板们关注细节无可厚非，可是过多的参与到项目开发中，很容易导致到开发节奏混乱，无法保持小版本迭代的步骤中。因为版本开发迭代期间，并不会频繁地推送到老板处体验，只能在项目上线阶段提交给老板进行上线前的最后体验。正常情况下，老板应该对这个功能开发进行最后的确认，确认这个版本是否与开发初期所定下的发展方向一致，而不应该对细节进行过多的反馈，一来这个环节在开发过程中早就经过产品经理的把控；二来开发人员、乃至于产品经理，都很难对老板所提出的细节要求说不，容易导致项目进度一拖再拖。~~三来甚至会过度打击产品经理的积极性，最终导致产品经理不再创新，只会揣测老板的心思。~~\n\n即便是成功至此的微信，笔者感觉它都已经不再是认真遵循着敏捷开发的模式了，大家可以从微信的招聘口号中可以感受一下：\n\n> 做一个伟大的产品来取悦**自己**。\n\n## 后注\n毕竟这片文章只是有感而发，想到哪写到哪，尚未经过深入思考。请读者们轻喷。\n","slug":"谈谈敏捷开发","published":1,"updated":"2022-02-23T13:14:20.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hf000drv05g4gg6p6u","content":"<h1 id=\"谈谈敏捷开发\"><a href=\"#谈谈敏捷开发\" class=\"headerlink\" title=\"谈谈敏捷开发\"></a>谈谈敏捷开发</h1><p>好久没有更新一下博客，最近有在尝试新的领域，可是一直没能积累下什么重要的知识、或者形成了什么重要的知识体系，就没能写下什么有意义的记录。可是很偶然的机会看到一个视频，里面讲述的，乔布斯谈论关于【流程与人才】的理解，基本可以总结为：苹果没有像 IBM 一样衰落，很大一部分原因是苹果没有执行像 IBM 一样严格的流程管理，使得有能力、有才华的人才能够不受大公司中条条框框的约束，充分发挥自己优势，最终促使苹果一次又一次的震惊世界。</p>\n<p><video id=\"video\" controls=\"\" preload=\"none\" poster=\"https://image-1251248522.cos.ap-guangzhou.myqcloud.com/video/SZ37WnlNCIihpLRV.MP4\"></video></p>\n<p>看到这个视频的时候，脑子中转过了好多好多的话语，没能按耐住自己的情绪，终究还是在 Twitter 中直接开喷。当然，喷的并不是乔布斯或者是他的言论，<strong>乔帮主</strong>在国内一波又一波媒体、开发者的吹捧下，早就已经走上了“冰封王座”。他的一生、创办苹果的风风雨雨，相信拜读过《乔布斯传》的人都能已经耳熟能详了，这里不再细说。总而言之，对于笔者自身，远远还达不到批判他的言辞的资格。</p>\n<blockquote>\n<p><del>废话说了那么多，结果原来只是像表达自己的弱小</del></p>\n</blockquote>\n<p>乔布斯确实过于优秀了，以至于越来越多的年轻人、创业者，都想要向他学习，见贤思齐焉。而学习最简单不过的方式，就是模仿。现在越来越容易听到那些晦涩难懂，可是由显得高端深奥的词汇。似乎在这种谈吐中更容易体现出自身对于产品思考的深入。</p>\n<p>“把握用户体验”，“重新定义 XX”，甚至 “打破流程”。“ IBM 之所以没落，就是因为他大公司中繁重的流程，约束的条条框框。” 所以我们要注重人才的才华展示，淡化流程。乔布斯所表达的观点，我们全盘接受。</p>\n<p>这样子的学习，简单至极。</p>\n<p><strong>流程不再重要了。</strong>—— 这就是为什么现在产品经理跟开发工程师之间存在如此对立的原因。</p>\n<p>当然，其实乔布斯并非推动国内各大企业打破传统、废除流程的唯一功臣，另外一个更广为人知的，当然是数早已被广为人知的、被誉为中国第一产品经理的 —— 张小龙。如果你不知道这个人的话，你可以点击 (Ctrl+W) 组合键，快速查询这个人的相关信息。^_^ 得益于他的知名度以及微信的成功，“打破流程”、“简化流程”、“把握用户体验” 获得了一个更加接地气的名称 —— “<strong>小步快跑，敏捷开发</strong>”。</p>\n<p>对比于传统应用开发方式，敏捷开发在当前互联网形式上确为更加合适，毫不夸张的说，如果目前的产品开发还按照从前的开发形式，普通创业公司绝大部分会在产品推出之前，就将所有的开发经费耗光。这个时候没有任何知名度、也没有成型的产品，根本无从谈起融资以及上市。</p>\n<h2 id=\"小步快跑、敏捷开发\"><a href=\"#小步快跑、敏捷开发\" class=\"headerlink\" title=\"小步快跑、敏捷开发\"></a>小步快跑、敏捷开发</h2><p>仔细考虑，其实这种开发方式在起步阶段是比较合理的。一周一个小版本，一个月一个大版本，对每次开发的新功能做好足够的调研以及打点统计，能够在不进行市场调查的前提上获取用户对于功能的喜好程度，从而在后续的开发中对特定的功能进行资源的倾斜，更大程度上去<strong>取悦用户</strong>。<br>不得不说，微信在初期发展中，摸索到了<strong>摇一摇</strong>以及<strong>朋友圈</strong>这两大功能，然后持续在上面增加功能，优化体验，让用户真正的粘附在了微信生态上，也算是对小步快跑、敏捷开发的很好体现。微信的成功，也让更多的公司相信这种开发模式的正确性。</p>\n<p>我们来仔细捋一下这种开发模式的要点：</p>\n<ol>\n<li>小版本周期短</li>\n<li>小版本所携带新功能有针对性</li>\n<li>开发过程中对新功能做好打点统计</li>\n<li>产品上线后进行需求复盘，通过统计上报，得知用户对于新功能的喜好程度</li>\n<li>对下一新版本的开发计划进行评估</li>\n</ol>\n<p>其中，复盘步骤对于敏捷开发的模式尤为重要。并且不仅是产品经理，包括开发人员都需要参与到复盘的步骤中。对于一个开发人员，得知自己所开发功能受到用户的喜爱，自身对于下个版本的开发积极性也会有相应的提高。</p>\n<h2 id=\"真实的敏捷开发\"><a href=\"#真实的敏捷开发\" class=\"headerlink\" title=\"真实的敏捷开发\"></a>真实的敏捷开发</h2><p>可是，有多少公司又能很好地在版本迭代的过程中持续遵循上述的要点呢？不少的公司更多的只是喊着敏捷开发的口号，在更短的时间内，往产品中堆砌着更多的功能，从而导致开发人员在长时间内一直保持着难以接受的开发强度，最终导致人员的流失，项目的失败。</p>\n<p>笔者从自身的工作环境中，感受到两点：</p>\n<ul>\n<li>老板过多地参与进项目开发的细节中</li>\n<li>复盘步骤的缺失，或者复盘步骤对于产品经理们的负反馈缺失</li>\n</ul>\n<p>笔者对于第一点真是深有体会。其实老板们关注细节无可厚非，可是过多的参与到项目开发中，很容易导致到开发节奏混乱，无法保持小版本迭代的步骤中。因为版本开发迭代期间，并不会频繁地推送到老板处体验，只能在项目上线阶段提交给老板进行上线前的最后体验。正常情况下，老板应该对这个功能开发进行最后的确认，确认这个版本是否与开发初期所定下的发展方向一致，而不应该对细节进行过多的反馈，一来这个环节在开发过程中早就经过产品经理的把控；二来开发人员、乃至于产品经理，都很难对老板所提出的细节要求说不，容易导致项目进度一拖再拖。<del>三来甚至会过度打击产品经理的积极性，最终导致产品经理不再创新，只会揣测老板的心思。</del></p>\n<p>即便是成功至此的微信，笔者感觉它都已经不再是认真遵循着敏捷开发的模式了，大家可以从微信的招聘口号中可以感受一下：</p>\n<blockquote>\n<p>做一个伟大的产品来取悦<strong>自己</strong>。</p>\n</blockquote>\n<h2 id=\"后注\"><a href=\"#后注\" class=\"headerlink\" title=\"后注\"></a>后注</h2><p>毕竟这片文章只是有感而发，想到哪写到哪，尚未经过深入思考。请读者们轻喷。</p>\n","site":{"data":{}},"excerpt":"谈谈敏捷开发\n好久没有更新一下博客，最近有在尝试新的领域，可是一直没能积累下什么重要的知识、或者形成了什么重要的知识体系，就没能写下什么有意义的记录。可是很偶然的机会看到一个视频，里面讲述的，乔布斯谈论关于【流程与人才】的理解，基本可以总结为：苹果没有像 IBM 一样衰落，很大一部分原因是苹果没有执行像 IBM 一样严格的流程管理，使得有能力、有才华的人才能够不受大公司中条条框框的约束，充分发挥自","more":"<h1 id=\"谈谈敏捷开发\"><a href=\"#谈谈敏捷开发\" class=\"headerlink\" title=\"谈谈敏捷开发\"></a>谈谈敏捷开发</h1><p>好久没有更新一下博客，最近有在尝试新的领域，可是一直没能积累下什么重要的知识、或者形成了什么重要的知识体系，就没能写下什么有意义的记录。可是很偶然的机会看到一个视频，里面讲述的，乔布斯谈论关于【流程与人才】的理解，基本可以总结为：苹果没有像 IBM 一样衰落，很大一部分原因是苹果没有执行像 IBM 一样严格的流程管理，使得有能力、有才华的人才能够不受大公司中条条框框的约束，充分发挥自己优势，最终促使苹果一次又一次的震惊世界。</p>\n<p><video id=\"video\" controls=\"\" preload=\"none\" poster=\"https://image-1251248522.cos.ap-guangzhou.myqcloud.com/video/SZ37WnlNCIihpLRV.MP4\"></video></p>\n<p>看到这个视频的时候，脑子中转过了好多好多的话语，没能按耐住自己的情绪，终究还是在 Twitter 中直接开喷。当然，喷的并不是乔布斯或者是他的言论，<strong>乔帮主</strong>在国内一波又一波媒体、开发者的吹捧下，早就已经走上了“冰封王座”。他的一生、创办苹果的风风雨雨，相信拜读过《乔布斯传》的人都能已经耳熟能详了，这里不再细说。总而言之，对于笔者自身，远远还达不到批判他的言辞的资格。</p>\n<blockquote>\n<p><del>废话说了那么多，结果原来只是像表达自己的弱小</del></p>\n</blockquote>\n<p>乔布斯确实过于优秀了，以至于越来越多的年轻人、创业者，都想要向他学习，见贤思齐焉。而学习最简单不过的方式，就是模仿。现在越来越容易听到那些晦涩难懂，可是由显得高端深奥的词汇。似乎在这种谈吐中更容易体现出自身对于产品思考的深入。</p>\n<p>“把握用户体验”，“重新定义 XX”，甚至 “打破流程”。“ IBM 之所以没落，就是因为他大公司中繁重的流程，约束的条条框框。” 所以我们要注重人才的才华展示，淡化流程。乔布斯所表达的观点，我们全盘接受。</p>\n<p>这样子的学习，简单至极。</p>\n<p><strong>流程不再重要了。</strong>—— 这就是为什么现在产品经理跟开发工程师之间存在如此对立的原因。</p>\n<p>当然，其实乔布斯并非推动国内各大企业打破传统、废除流程的唯一功臣，另外一个更广为人知的，当然是数早已被广为人知的、被誉为中国第一产品经理的 —— 张小龙。如果你不知道这个人的话，你可以点击 (Ctrl+W) 组合键，快速查询这个人的相关信息。^_^ 得益于他的知名度以及微信的成功，“打破流程”、“简化流程”、“把握用户体验” 获得了一个更加接地气的名称 —— “<strong>小步快跑，敏捷开发</strong>”。</p>\n<p>对比于传统应用开发方式，敏捷开发在当前互联网形式上确为更加合适，毫不夸张的说，如果目前的产品开发还按照从前的开发形式，普通创业公司绝大部分会在产品推出之前，就将所有的开发经费耗光。这个时候没有任何知名度、也没有成型的产品，根本无从谈起融资以及上市。</p>\n<h2 id=\"小步快跑、敏捷开发\"><a href=\"#小步快跑、敏捷开发\" class=\"headerlink\" title=\"小步快跑、敏捷开发\"></a>小步快跑、敏捷开发</h2><p>仔细考虑，其实这种开发方式在起步阶段是比较合理的。一周一个小版本，一个月一个大版本，对每次开发的新功能做好足够的调研以及打点统计，能够在不进行市场调查的前提上获取用户对于功能的喜好程度，从而在后续的开发中对特定的功能进行资源的倾斜，更大程度上去<strong>取悦用户</strong>。<br>不得不说，微信在初期发展中，摸索到了<strong>摇一摇</strong>以及<strong>朋友圈</strong>这两大功能，然后持续在上面增加功能，优化体验，让用户真正的粘附在了微信生态上，也算是对小步快跑、敏捷开发的很好体现。微信的成功，也让更多的公司相信这种开发模式的正确性。</p>\n<p>我们来仔细捋一下这种开发模式的要点：</p>\n<ol>\n<li>小版本周期短</li>\n<li>小版本所携带新功能有针对性</li>\n<li>开发过程中对新功能做好打点统计</li>\n<li>产品上线后进行需求复盘，通过统计上报，得知用户对于新功能的喜好程度</li>\n<li>对下一新版本的开发计划进行评估</li>\n</ol>\n<p>其中，复盘步骤对于敏捷开发的模式尤为重要。并且不仅是产品经理，包括开发人员都需要参与到复盘的步骤中。对于一个开发人员，得知自己所开发功能受到用户的喜爱，自身对于下个版本的开发积极性也会有相应的提高。</p>\n<h2 id=\"真实的敏捷开发\"><a href=\"#真实的敏捷开发\" class=\"headerlink\" title=\"真实的敏捷开发\"></a>真实的敏捷开发</h2><p>可是，有多少公司又能很好地在版本迭代的过程中持续遵循上述的要点呢？不少的公司更多的只是喊着敏捷开发的口号，在更短的时间内，往产品中堆砌着更多的功能，从而导致开发人员在长时间内一直保持着难以接受的开发强度，最终导致人员的流失，项目的失败。</p>\n<p>笔者从自身的工作环境中，感受到两点：</p>\n<ul>\n<li>老板过多地参与进项目开发的细节中</li>\n<li>复盘步骤的缺失，或者复盘步骤对于产品经理们的负反馈缺失</li>\n</ul>\n<p>笔者对于第一点真是深有体会。其实老板们关注细节无可厚非，可是过多的参与到项目开发中，很容易导致到开发节奏混乱，无法保持小版本迭代的步骤中。因为版本开发迭代期间，并不会频繁地推送到老板处体验，只能在项目上线阶段提交给老板进行上线前的最后体验。正常情况下，老板应该对这个功能开发进行最后的确认，确认这个版本是否与开发初期所定下的发展方向一致，而不应该对细节进行过多的反馈，一来这个环节在开发过程中早就经过产品经理的把控；二来开发人员、乃至于产品经理，都很难对老板所提出的细节要求说不，容易导致项目进度一拖再拖。<del>三来甚至会过度打击产品经理的积极性，最终导致产品经理不再创新，只会揣测老板的心思。</del></p>\n<p>即便是成功至此的微信，笔者感觉它都已经不再是认真遵循着敏捷开发的模式了，大家可以从微信的招聘口号中可以感受一下：</p>\n<blockquote>\n<p>做一个伟大的产品来取悦<strong>自己</strong>。</p>\n</blockquote>\n<h2 id=\"后注\"><a href=\"#后注\" class=\"headerlink\" title=\"后注\"></a>后注</h2><p>毕竟这片文章只是有感而发，想到哪写到哪，尚未经过深入思考。请读者们轻喷。</p>\n"},{"title":"深入了解 Service Worker","date":"2020-03-15T15:05:23.000Z","_content":"\n前言\n在笔者的项目中，加快页面加载速度一直是提高用户体验的重点，优化页面加载速度的手段也有很多：\n\n- 使用 CDN 网络缓存代码资源\n- 使用 webpack 等开发工具合并细小资源，减少 HTTP 请求数量\n- 使用 UglifyJS 等工具压缩 Javascript 代码，减少网络传输数据\n- 使用 SVG 资源代替 PNG 等图片资源\n等等…\n\n 然而上述的优化手段都是通过减少网络请求开销从而达到优化加载页面速度的目的，但对于类似在线文档这类用户较为频繁使用的产品，更加需要关注用户缓存的方向。在此之前，前端页面一直依赖浏览器的缓存管理，因此我们需要更精细化地管理用户的缓存，为了达到这个目的，我们需要使用到 **Service Worker**。\n\n## 什么是 Service Worker\nService Worker 属于其中一个 Web Worker 技术，部分中文文档会将其翻译为 `服务工作线程` ，它是脱离于网页 Javascript 环境的一个独立的线程。因此 Service Worker 的生命周期完全独立于网页，在页面刷新时，依然能存活并且接受页面刷新所发送的事件。Service Worker 主要有三个作用：\n\n1. 拦截网页请求，并返回指定响应\n2. 后台同步功能\n3. 消息推送功能\n\n后台同步功能是得益于 Service Worker 独特的生命周期，使得网页在用户关闭后，Service Worker 线程依然能存活一定时间，将未成功的网络请求发送到服务器中。\n\n消息推送是 Service Worker 另外一个重要的场景，它使得用户在没有打开网页的情况下，能够收到服务器推送过来的提醒消息。这种功能类似于如今 iOS 上的推送消息。消息推送依赖于浏览器厂商提供的推送服务，不幸的是，Chrome 浏览器的厂商 Google，被隔绝于 GFW 之外，使得 Chrome 的推送服务无法正常使用。\n\n拦截网络请求功能是 Service Worker 使用最为广泛的功能。在 Service Worker 中，它能收到管辖区域内的所有资源发起的网络请求，同时能对这部分的网络请求进行自定义的处理。并且，在 Service Worker 环境中，浏览器提供了一套完备的 Cache API，能够对网络的 `Request` 以及 `Response` 进行保存处理。正式因为这两种技术，使得 Service Worker 能够为网页提供一个离线运行的环境，成为 Progress Web Application（PWA）的核心部分。\n\n## Service Worker 的优势\n本地缓存并非什么新的技术，早在 Service Worker 技术出现以前，各种浏览器对于网络请求都有进行缓存处理，为的就是提高网络的响应速度、加快页面加载时间，从而吸引更多的用户使用。而在此之后，为了方面开发者对于缓存的管理，提出了 LocalStorage、Web SQL Database、indexdDB 等技术。对比这些技术，Service Worker 的优势在哪里呢？\n\n### Service Worker 能保存更多的数据\n根据 [Wikipedia](https://en.wikipedia.org/wiki/Web_Storage) 上的描述 ，开发者通过 LocalStorage 使用的缓存限制大小为 `5MB-10MB` ，而通过 indexedDB 缓存的大小限制最大为 `50MB` 。\n这容量限制对于保存普通用户数据来说已经足够，可是对于缓存脚本文件、样式文件却显得捉襟见肘。\n根据 [Google 开发文档](https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/offline-for-pwa)中显示，Service Worker 所能使用的容量大小不再做统一限制，而是由当前电脑的磁盘空间所限制。\n\n![ServiceWorker容量限制.png](https://cdn.iguan7u.cn/image/ServiceWorker容量限制.png)\n\n> 在 iOS Safari 中，Service Worker 保存的数据依然限制 50MB。\n\n### Service Worker 与业务逻辑的耦合更低\n不同于 LocalStoage 、indexDB 等需要对不同的模块代码手动处理缓存逻辑，Service Worker 在独立的线程中，统一处理网页所发送的网络请求，能够做到对业务逻辑代码零侵入。\n\n### Service Worker 能在无网络状态下返回页面\nService Worker 处理一个独立的线程，生命周期也独立网页，因此在页面关闭或者是刷新时，Service Worker 能持续地处于存活状态。如果 Service Worker  缓存 HTML 数据，那在其存活的时间内，能够在无网络的环境下返回缓存的页面数据，让网页离线使用成为了可能。\n\n## Service Worker 的生命周期\n![LifeCycle.png](https://cdn.iguan7u.cn/image/ServiceWorkerLifeCycle.png)\n\nService Worker 的生命周期主要在 4 个阶段：\n\n1. 安装\n2. 等待\n3. 活跃\n4. 废弃\n\n在浏览器下载完成 Service Worker 脚本资源后，浏览器会初始化 Worker 线程并加载脚本资源。在完成上述步骤后，浏览器会分发一个 `install` 事件给 Service Worker 线程，等待线程完成 install 事件的相关操作，通常在这个阶段，我们能预加载一下网页所需要的资源。而这个阶段，我们称之为**安装阶段**。\n\n在安装完成后，Service Worker 并没有马上被激活，如果在此之前已经有正在处于激活态 Service Worker 线程，那么新安装的线程会一直处于**等待阶段**，等待前一个工作线程废弃。\n\n如果在此之前没有另外的 Service Worker，那么它将马上进入**活跃状态**。在这个状态下，Service Worker 将会收到页面发起请求所触发的 `fetch` 事件，以及 `push` 和 `sync` 的功能性事件。\n\n如果 Service Worker 在安装阶段预加载网络资源失败了，那个它将会进入**废弃阶段**，这个阶段 Service Worker 并不会生效，也无法监听到网页触发的所有事件。\n\n## Service Worker 的使用流程\nService Worker 的使用方法较为简单，需要经过以下几个步骤：\n\n### 注册 Service Worker 线程\n```javascript\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/sw.js').then(function(registration) {\n    /* 注册 Service Worker 成功 */\n    console.log('ServiceWorker registration successful with scope: ', registration.scope);\n  }).catch(function(err) {\n    /* 注册 Service Worker 失败 */\n    console.log('ServiceWorker registration failed: ', err);\n  });\n}\n```\n\n`navigator.serviceWorker.register` 方法会返回一个 Promise，注册成功后该 Promise 会触发 then 方法，如果不成功会抛出对应异常。\n\n注册成功后，我们可以在 Chrome 中打开 `chrome://inspect/#service-workers` 查看注册成功的 Service Worker。\n\n![ServiceWorkerChrome.png](https://cdn.iguan7u.cn/image/ServiceWorkerChrome.png)\n\n### 在 Service Worker 中监听 Install 事件\n```javascript\nself.addEventListener('install', function(event) {\n  // 收到 install 事件，处理资源预加载的逻辑\n});\n```\n\n在 install 回调的内部，我们需要执行以下步骤：\n1. `caches.open()` 打开缓存仓库。\n2. `cache.addAll()` 缓存所需的资源文件。\n3. 确认所有需要的资源是否已缓存。\n\n```javascript\n// serviceWorker.js\nvar CACHE_NAME = 'my-site-cache-v1';\nvar urlsToCache = [\n  '/',\n  '/styles/main.css',\n  '/script/main.js'\n];\n\nself.addEventListener('install', function(event) {\n  // Perform install steps\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(function(cache) {\n        console.log('Opened cache');\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n```\n\n需要注意的是，如果 `cache.addAll()` 方法缓存的其中一个资源失败了，会导致 Service Worker 进入废弃模式，直到页面刷新后，Service Worker 重新 install 再次尝试缓存。\n\n### 在 Service Worker 中缓存以及返回请求\n在 Service Worker 激活后，它将开始接收网页所发送的 fetch 事件，并且通过 `event.responseWith()` 方法，返回自定义的响应。结合 Cache API 中的 `cache.put()` 、`caches.match()` 方法，我们能够将请求的响应保存起来，在再次收到相同请求时，返回上一次的缓存响应结果。\n\n```javascript\n// serviceWorker.js\nself.addEventListener('fetch', function(event) {\n  event.respondWith(\n    // 根据请求 URL，查找缓存是否对应的缓存响应\n    caches.match(event.request)\n      .then(function(response) {\n        if (response) {\n\t\t\t// 判断存在缓存响应，直接返回\n          return response;\n        }\n        return fetch(event.request);\n      }\n    )\n  );\n});\n```\n\n## Service Worker 使用细节\n### Service Worker 必须在 HTTPS 协议下使用\n因为 Service Worker 能捕捉其作用域下的所有网络请求，为了保证其不会因为中间人篡改了 serviceWorker 脚本而导致隐私泄漏，W3C 协会规定 Service Worker 必须要在 HTTPS 协议下使用。\n\n### Service Worker 脚本必须与网页处于同一个 Origin  下\n脚本资源必须与网页资源处于同一个 Origin 下，导致了脚本资源无法部署到 CDN 独立域名上。\n这可能与 Service Worker 的机制有关系：在浏览器访问网页的时候，它会根据网页的 Domain Origin 匹配之前是否已经有注册成功的 Service Worker，如果匹配存在的话，会在发起请求之前先将 Service Worker 线程安装并启动。因此这里严格地要求了 Service Worker 的脚本资源路径。\n\n### Service Worker 的作用域限制在其脚本存放路径上\n根绝文档描述，Service Worker 所能捕捉的网络请求跟脚本所在的路径有关。若脚本路径在 `/sw.js` 上，Service Worker 默认能够捕捉到 `/` 范围内的所有网络请求。当前，`register()` 方法能够进一步通过 `scope` 参数限制 Service Worker 的作用域范围：\n\n```javascript\nnavigator.serviceWorker.register('/sw.js', { scope: '/subdomain/' }).then(function(registration) {\n  // Registration was successful\n  console.log('ServiceWorker registration successful with scope: ', registration.scope);\n}, function(err) {\n  // registration failed :(\n  console.log('ServiceWorker registration failed: ', err);\n});\n```\n\n通过上述指定 `scope` 参数的方法，Service Worker 就只会收到 `/subdomain` 下的网络 fetch 事件。\n\n但如果我们将 Service Worker 脚本存放在 `/subdomain/sw.js` 上，那么 Service Worker 默认只会收到 `/subdomain/` 作用域下的网络请求，并不会再收到 `/` 域名下的网络请求。\n如果我们强制将 `scope` 参数配置为 `/` 上，就会收到 `register()` 方法的失败响应：\n```\nServiceWorker registration failed:  DOMException: Failed to register a ServiceWorker for scope ('https://www.qq.com/subdomain') with script ('https://www.qq.com/subdomain/sw.js'): The path of the provided scope ('/') is not under the max scope allowed ('/subdomain/'). Adjust the scope, move the Service Worker script, or use the Service-Worker-Allowed HTTP header to allow the scope.\n```\n我们需要在 `sw.js` 脚本的返回头部加入 `Service-Worker-Allowed: '/‘` 才能正确接受 `/` 作用域的网络请求事件。\n\n> 但实际上，笔者在 Chrome/78.0.3904.113 版本上测试，`/subdomain/sw.js` 脚本注册的 Service Worker 不仅无法接收到 `/` 作用域的网络请求，甚至连其合法的 `/subdomain/` 作用域下的网络请求都无法接收。这里并不确定是 Service Worker 规范变更了， 还是 Chrome 浏览器的问题。所以还是建议 Service Worker 脚本**最好配置在网页资源的同级目录下**。","source":"_posts/深入了解-Service-Worker.md","raw":"---\ntitle: 深入了解 Service Worker\ndate: 2020-03-15 23:05:23\ntags:\n---\n\n前言\n在笔者的项目中，加快页面加载速度一直是提高用户体验的重点，优化页面加载速度的手段也有很多：\n\n- 使用 CDN 网络缓存代码资源\n- 使用 webpack 等开发工具合并细小资源，减少 HTTP 请求数量\n- 使用 UglifyJS 等工具压缩 Javascript 代码，减少网络传输数据\n- 使用 SVG 资源代替 PNG 等图片资源\n等等…\n\n 然而上述的优化手段都是通过减少网络请求开销从而达到优化加载页面速度的目的，但对于类似在线文档这类用户较为频繁使用的产品，更加需要关注用户缓存的方向。在此之前，前端页面一直依赖浏览器的缓存管理，因此我们需要更精细化地管理用户的缓存，为了达到这个目的，我们需要使用到 **Service Worker**。\n\n## 什么是 Service Worker\nService Worker 属于其中一个 Web Worker 技术，部分中文文档会将其翻译为 `服务工作线程` ，它是脱离于网页 Javascript 环境的一个独立的线程。因此 Service Worker 的生命周期完全独立于网页，在页面刷新时，依然能存活并且接受页面刷新所发送的事件。Service Worker 主要有三个作用：\n\n1. 拦截网页请求，并返回指定响应\n2. 后台同步功能\n3. 消息推送功能\n\n后台同步功能是得益于 Service Worker 独特的生命周期，使得网页在用户关闭后，Service Worker 线程依然能存活一定时间，将未成功的网络请求发送到服务器中。\n\n消息推送是 Service Worker 另外一个重要的场景，它使得用户在没有打开网页的情况下，能够收到服务器推送过来的提醒消息。这种功能类似于如今 iOS 上的推送消息。消息推送依赖于浏览器厂商提供的推送服务，不幸的是，Chrome 浏览器的厂商 Google，被隔绝于 GFW 之外，使得 Chrome 的推送服务无法正常使用。\n\n拦截网络请求功能是 Service Worker 使用最为广泛的功能。在 Service Worker 中，它能收到管辖区域内的所有资源发起的网络请求，同时能对这部分的网络请求进行自定义的处理。并且，在 Service Worker 环境中，浏览器提供了一套完备的 Cache API，能够对网络的 `Request` 以及 `Response` 进行保存处理。正式因为这两种技术，使得 Service Worker 能够为网页提供一个离线运行的环境，成为 Progress Web Application（PWA）的核心部分。\n\n## Service Worker 的优势\n本地缓存并非什么新的技术，早在 Service Worker 技术出现以前，各种浏览器对于网络请求都有进行缓存处理，为的就是提高网络的响应速度、加快页面加载时间，从而吸引更多的用户使用。而在此之后，为了方面开发者对于缓存的管理，提出了 LocalStorage、Web SQL Database、indexdDB 等技术。对比这些技术，Service Worker 的优势在哪里呢？\n\n### Service Worker 能保存更多的数据\n根据 [Wikipedia](https://en.wikipedia.org/wiki/Web_Storage) 上的描述 ，开发者通过 LocalStorage 使用的缓存限制大小为 `5MB-10MB` ，而通过 indexedDB 缓存的大小限制最大为 `50MB` 。\n这容量限制对于保存普通用户数据来说已经足够，可是对于缓存脚本文件、样式文件却显得捉襟见肘。\n根据 [Google 开发文档](https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/offline-for-pwa)中显示，Service Worker 所能使用的容量大小不再做统一限制，而是由当前电脑的磁盘空间所限制。\n\n![ServiceWorker容量限制.png](https://cdn.iguan7u.cn/image/ServiceWorker容量限制.png)\n\n> 在 iOS Safari 中，Service Worker 保存的数据依然限制 50MB。\n\n### Service Worker 与业务逻辑的耦合更低\n不同于 LocalStoage 、indexDB 等需要对不同的模块代码手动处理缓存逻辑，Service Worker 在独立的线程中，统一处理网页所发送的网络请求，能够做到对业务逻辑代码零侵入。\n\n### Service Worker 能在无网络状态下返回页面\nService Worker 处理一个独立的线程，生命周期也独立网页，因此在页面关闭或者是刷新时，Service Worker 能持续地处于存活状态。如果 Service Worker  缓存 HTML 数据，那在其存活的时间内，能够在无网络的环境下返回缓存的页面数据，让网页离线使用成为了可能。\n\n## Service Worker 的生命周期\n![LifeCycle.png](https://cdn.iguan7u.cn/image/ServiceWorkerLifeCycle.png)\n\nService Worker 的生命周期主要在 4 个阶段：\n\n1. 安装\n2. 等待\n3. 活跃\n4. 废弃\n\n在浏览器下载完成 Service Worker 脚本资源后，浏览器会初始化 Worker 线程并加载脚本资源。在完成上述步骤后，浏览器会分发一个 `install` 事件给 Service Worker 线程，等待线程完成 install 事件的相关操作，通常在这个阶段，我们能预加载一下网页所需要的资源。而这个阶段，我们称之为**安装阶段**。\n\n在安装完成后，Service Worker 并没有马上被激活，如果在此之前已经有正在处于激活态 Service Worker 线程，那么新安装的线程会一直处于**等待阶段**，等待前一个工作线程废弃。\n\n如果在此之前没有另外的 Service Worker，那么它将马上进入**活跃状态**。在这个状态下，Service Worker 将会收到页面发起请求所触发的 `fetch` 事件，以及 `push` 和 `sync` 的功能性事件。\n\n如果 Service Worker 在安装阶段预加载网络资源失败了，那个它将会进入**废弃阶段**，这个阶段 Service Worker 并不会生效，也无法监听到网页触发的所有事件。\n\n## Service Worker 的使用流程\nService Worker 的使用方法较为简单，需要经过以下几个步骤：\n\n### 注册 Service Worker 线程\n```javascript\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/sw.js').then(function(registration) {\n    /* 注册 Service Worker 成功 */\n    console.log('ServiceWorker registration successful with scope: ', registration.scope);\n  }).catch(function(err) {\n    /* 注册 Service Worker 失败 */\n    console.log('ServiceWorker registration failed: ', err);\n  });\n}\n```\n\n`navigator.serviceWorker.register` 方法会返回一个 Promise，注册成功后该 Promise 会触发 then 方法，如果不成功会抛出对应异常。\n\n注册成功后，我们可以在 Chrome 中打开 `chrome://inspect/#service-workers` 查看注册成功的 Service Worker。\n\n![ServiceWorkerChrome.png](https://cdn.iguan7u.cn/image/ServiceWorkerChrome.png)\n\n### 在 Service Worker 中监听 Install 事件\n```javascript\nself.addEventListener('install', function(event) {\n  // 收到 install 事件，处理资源预加载的逻辑\n});\n```\n\n在 install 回调的内部，我们需要执行以下步骤：\n1. `caches.open()` 打开缓存仓库。\n2. `cache.addAll()` 缓存所需的资源文件。\n3. 确认所有需要的资源是否已缓存。\n\n```javascript\n// serviceWorker.js\nvar CACHE_NAME = 'my-site-cache-v1';\nvar urlsToCache = [\n  '/',\n  '/styles/main.css',\n  '/script/main.js'\n];\n\nself.addEventListener('install', function(event) {\n  // Perform install steps\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(function(cache) {\n        console.log('Opened cache');\n        return cache.addAll(urlsToCache);\n      })\n  );\n});\n```\n\n需要注意的是，如果 `cache.addAll()` 方法缓存的其中一个资源失败了，会导致 Service Worker 进入废弃模式，直到页面刷新后，Service Worker 重新 install 再次尝试缓存。\n\n### 在 Service Worker 中缓存以及返回请求\n在 Service Worker 激活后，它将开始接收网页所发送的 fetch 事件，并且通过 `event.responseWith()` 方法，返回自定义的响应。结合 Cache API 中的 `cache.put()` 、`caches.match()` 方法，我们能够将请求的响应保存起来，在再次收到相同请求时，返回上一次的缓存响应结果。\n\n```javascript\n// serviceWorker.js\nself.addEventListener('fetch', function(event) {\n  event.respondWith(\n    // 根据请求 URL，查找缓存是否对应的缓存响应\n    caches.match(event.request)\n      .then(function(response) {\n        if (response) {\n\t\t\t// 判断存在缓存响应，直接返回\n          return response;\n        }\n        return fetch(event.request);\n      }\n    )\n  );\n});\n```\n\n## Service Worker 使用细节\n### Service Worker 必须在 HTTPS 协议下使用\n因为 Service Worker 能捕捉其作用域下的所有网络请求，为了保证其不会因为中间人篡改了 serviceWorker 脚本而导致隐私泄漏，W3C 协会规定 Service Worker 必须要在 HTTPS 协议下使用。\n\n### Service Worker 脚本必须与网页处于同一个 Origin  下\n脚本资源必须与网页资源处于同一个 Origin 下，导致了脚本资源无法部署到 CDN 独立域名上。\n这可能与 Service Worker 的机制有关系：在浏览器访问网页的时候，它会根据网页的 Domain Origin 匹配之前是否已经有注册成功的 Service Worker，如果匹配存在的话，会在发起请求之前先将 Service Worker 线程安装并启动。因此这里严格地要求了 Service Worker 的脚本资源路径。\n\n### Service Worker 的作用域限制在其脚本存放路径上\n根绝文档描述，Service Worker 所能捕捉的网络请求跟脚本所在的路径有关。若脚本路径在 `/sw.js` 上，Service Worker 默认能够捕捉到 `/` 范围内的所有网络请求。当前，`register()` 方法能够进一步通过 `scope` 参数限制 Service Worker 的作用域范围：\n\n```javascript\nnavigator.serviceWorker.register('/sw.js', { scope: '/subdomain/' }).then(function(registration) {\n  // Registration was successful\n  console.log('ServiceWorker registration successful with scope: ', registration.scope);\n}, function(err) {\n  // registration failed :(\n  console.log('ServiceWorker registration failed: ', err);\n});\n```\n\n通过上述指定 `scope` 参数的方法，Service Worker 就只会收到 `/subdomain` 下的网络 fetch 事件。\n\n但如果我们将 Service Worker 脚本存放在 `/subdomain/sw.js` 上，那么 Service Worker 默认只会收到 `/subdomain/` 作用域下的网络请求，并不会再收到 `/` 域名下的网络请求。\n如果我们强制将 `scope` 参数配置为 `/` 上，就会收到 `register()` 方法的失败响应：\n```\nServiceWorker registration failed:  DOMException: Failed to register a ServiceWorker for scope ('https://www.qq.com/subdomain') with script ('https://www.qq.com/subdomain/sw.js'): The path of the provided scope ('/') is not under the max scope allowed ('/subdomain/'). Adjust the scope, move the Service Worker script, or use the Service-Worker-Allowed HTTP header to allow the scope.\n```\n我们需要在 `sw.js` 脚本的返回头部加入 `Service-Worker-Allowed: '/‘` 才能正确接受 `/` 作用域的网络请求事件。\n\n> 但实际上，笔者在 Chrome/78.0.3904.113 版本上测试，`/subdomain/sw.js` 脚本注册的 Service Worker 不仅无法接收到 `/` 作用域的网络请求，甚至连其合法的 `/subdomain/` 作用域下的网络请求都无法接收。这里并不确定是 Service Worker 规范变更了， 还是 Chrome 浏览器的问题。所以还是建议 Service Worker 脚本**最好配置在网页资源的同级目录下**。","slug":"深入了解-Service-Worker","published":1,"updated":"2022-02-23T13:14:20.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hg000erv05dhi4f42a","content":"<p>前言<br>在笔者的项目中，加快页面加载速度一直是提高用户体验的重点，优化页面加载速度的手段也有很多：</p>\n<ul>\n<li>使用 CDN 网络缓存代码资源</li>\n<li>使用 webpack 等开发工具合并细小资源，减少 HTTP 请求数量</li>\n<li>使用 UglifyJS 等工具压缩 Javascript 代码，减少网络传输数据</li>\n<li>使用 SVG 资源代替 PNG 等图片资源<br>等等…</li>\n</ul>\n<p> 然而上述的优化手段都是通过减少网络请求开销从而达到优化加载页面速度的目的，但对于类似在线文档这类用户较为频繁使用的产品，更加需要关注用户缓存的方向。在此之前，前端页面一直依赖浏览器的缓存管理，因此我们需要更精细化地管理用户的缓存，为了达到这个目的，我们需要使用到 <strong>Service Worker</strong>。</p>\n<h2 id=\"什么是-Service-Worker\"><a href=\"#什么是-Service-Worker\" class=\"headerlink\" title=\"什么是 Service Worker\"></a>什么是 Service Worker</h2><p>Service Worker 属于其中一个 Web Worker 技术，部分中文文档会将其翻译为 <code>服务工作线程</code> ，它是脱离于网页 Javascript 环境的一个独立的线程。因此 Service Worker 的生命周期完全独立于网页，在页面刷新时，依然能存活并且接受页面刷新所发送的事件。Service Worker 主要有三个作用：</p>\n<ol>\n<li>拦截网页请求，并返回指定响应</li>\n<li>后台同步功能</li>\n<li>消息推送功能</li>\n</ol>\n<p>后台同步功能是得益于 Service Worker 独特的生命周期，使得网页在用户关闭后，Service Worker 线程依然能存活一定时间，将未成功的网络请求发送到服务器中。</p>\n<p>消息推送是 Service Worker 另外一个重要的场景，它使得用户在没有打开网页的情况下，能够收到服务器推送过来的提醒消息。这种功能类似于如今 iOS 上的推送消息。消息推送依赖于浏览器厂商提供的推送服务，不幸的是，Chrome 浏览器的厂商 Google，被隔绝于 GFW 之外，使得 Chrome 的推送服务无法正常使用。</p>\n<p>拦截网络请求功能是 Service Worker 使用最为广泛的功能。在 Service Worker 中，它能收到管辖区域内的所有资源发起的网络请求，同时能对这部分的网络请求进行自定义的处理。并且，在 Service Worker 环境中，浏览器提供了一套完备的 Cache API，能够对网络的 <code>Request</code> 以及 <code>Response</code> 进行保存处理。正式因为这两种技术，使得 Service Worker 能够为网页提供一个离线运行的环境，成为 Progress Web Application（PWA）的核心部分。</p>\n<h2 id=\"Service-Worker-的优势\"><a href=\"#Service-Worker-的优势\" class=\"headerlink\" title=\"Service Worker 的优势\"></a>Service Worker 的优势</h2><p>本地缓存并非什么新的技术，早在 Service Worker 技术出现以前，各种浏览器对于网络请求都有进行缓存处理，为的就是提高网络的响应速度、加快页面加载时间，从而吸引更多的用户使用。而在此之后，为了方面开发者对于缓存的管理，提出了 LocalStorage、Web SQL Database、indexdDB 等技术。对比这些技术，Service Worker 的优势在哪里呢？</p>\n<h3 id=\"Service-Worker-能保存更多的数据\"><a href=\"#Service-Worker-能保存更多的数据\" class=\"headerlink\" title=\"Service Worker 能保存更多的数据\"></a>Service Worker 能保存更多的数据</h3><p>根据 <a href=\"https://en.wikipedia.org/wiki/Web_Storage\">Wikipedia</a> 上的描述 ，开发者通过 LocalStorage 使用的缓存限制大小为 <code>5MB-10MB</code> ，而通过 indexedDB 缓存的大小限制最大为 <code>50MB</code> 。<br>这容量限制对于保存普通用户数据来说已经足够，可是对于缓存脚本文件、样式文件却显得捉襟见肘。<br>根据 <a href=\"https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/offline-for-pwa\">Google 开发文档</a>中显示，Service Worker 所能使用的容量大小不再做统一限制，而是由当前电脑的磁盘空间所限制。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ServiceWorker%E5%AE%B9%E9%87%8F%E9%99%90%E5%88%B6.png\" alt=\"ServiceWorker容量限制.png\"></p>\n<blockquote>\n<p>在 iOS Safari 中，Service Worker 保存的数据依然限制 50MB。</p>\n</blockquote>\n<h3 id=\"Service-Worker-与业务逻辑的耦合更低\"><a href=\"#Service-Worker-与业务逻辑的耦合更低\" class=\"headerlink\" title=\"Service Worker 与业务逻辑的耦合更低\"></a>Service Worker 与业务逻辑的耦合更低</h3><p>不同于 LocalStoage 、indexDB 等需要对不同的模块代码手动处理缓存逻辑，Service Worker 在独立的线程中，统一处理网页所发送的网络请求，能够做到对业务逻辑代码零侵入。</p>\n<h3 id=\"Service-Worker-能在无网络状态下返回页面\"><a href=\"#Service-Worker-能在无网络状态下返回页面\" class=\"headerlink\" title=\"Service Worker 能在无网络状态下返回页面\"></a>Service Worker 能在无网络状态下返回页面</h3><p>Service Worker 处理一个独立的线程，生命周期也独立网页，因此在页面关闭或者是刷新时，Service Worker 能持续地处于存活状态。如果 Service Worker  缓存 HTML 数据，那在其存活的时间内，能够在无网络的环境下返回缓存的页面数据，让网页离线使用成为了可能。</p>\n<h2 id=\"Service-Worker-的生命周期\"><a href=\"#Service-Worker-的生命周期\" class=\"headerlink\" title=\"Service Worker 的生命周期\"></a>Service Worker 的生命周期</h2><p><img src=\"https://cdn.iguan7u.cn/image/ServiceWorkerLifeCycle.png\" alt=\"LifeCycle.png\"></p>\n<p>Service Worker 的生命周期主要在 4 个阶段：</p>\n<ol>\n<li>安装</li>\n<li>等待</li>\n<li>活跃</li>\n<li>废弃</li>\n</ol>\n<p>在浏览器下载完成 Service Worker 脚本资源后，浏览器会初始化 Worker 线程并加载脚本资源。在完成上述步骤后，浏览器会分发一个 <code>install</code> 事件给 Service Worker 线程，等待线程完成 install 事件的相关操作，通常在这个阶段，我们能预加载一下网页所需要的资源。而这个阶段，我们称之为<strong>安装阶段</strong>。</p>\n<p>在安装完成后，Service Worker 并没有马上被激活，如果在此之前已经有正在处于激活态 Service Worker 线程，那么新安装的线程会一直处于<strong>等待阶段</strong>，等待前一个工作线程废弃。</p>\n<p>如果在此之前没有另外的 Service Worker，那么它将马上进入<strong>活跃状态</strong>。在这个状态下，Service Worker 将会收到页面发起请求所触发的 <code>fetch</code> 事件，以及 <code>push</code> 和 <code>sync</code> 的功能性事件。</p>\n<p>如果 Service Worker 在安装阶段预加载网络资源失败了，那个它将会进入<strong>废弃阶段</strong>，这个阶段 Service Worker 并不会生效，也无法监听到网页触发的所有事件。</p>\n<h2 id=\"Service-Worker-的使用流程\"><a href=\"#Service-Worker-的使用流程\" class=\"headerlink\" title=\"Service Worker 的使用流程\"></a>Service Worker 的使用流程</h2><p>Service Worker 的使用方法较为简单，需要经过以下几个步骤：</p>\n<h3 id=\"注册-Service-Worker-线程\"><a href=\"#注册-Service-Worker-线程\" class=\"headerlink\" title=\"注册 Service Worker 线程\"></a>注册 Service Worker 线程</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&#x27;serviceWorker&#x27;</span> <span class=\"hljs-keyword\">in</span> navigator) &#123;<br>  navigator.<span class=\"hljs-property\">serviceWorker</span>.<span class=\"hljs-title function_\">register</span>(<span class=\"hljs-string\">&#x27;/sw.js&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">registration</span>) &#123;<br>    <span class=\"hljs-comment\">/* 注册 Service Worker 成功 */</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.<span class=\"hljs-property\">scope</span>);<br>  &#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) &#123;<br>    <span class=\"hljs-comment\">/* 注册 Service Worker 失败 */</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration failed: &#x27;</span>, err);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>navigator.serviceWorker.register</code> 方法会返回一个 Promise，注册成功后该 Promise 会触发 then 方法，如果不成功会抛出对应异常。</p>\n<p>注册成功后，我们可以在 Chrome 中打开 <code>chrome://inspect/#service-workers</code> 查看注册成功的 Service Worker。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ServiceWorkerChrome.png\" alt=\"ServiceWorkerChrome.png\"></p>\n<h3 id=\"在-Service-Worker-中监听-Install-事件\"><a href=\"#在-Service-Worker-中监听-Install-事件\" class=\"headerlink\" title=\"在 Service Worker 中监听 Install 事件\"></a>在 Service Worker 中监听 Install 事件</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">self.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;install&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-comment\">// 收到 install 事件，处理资源预加载的逻辑</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>在 install 回调的内部，我们需要执行以下步骤：</p>\n<ol>\n<li><code>caches.open()</code> 打开缓存仓库。</li>\n<li><code>cache.addAll()</code> 缓存所需的资源文件。</li>\n<li>确认所有需要的资源是否已缓存。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// serviceWorker.js</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable constant_\">CACHE_NAME</span> = <span class=\"hljs-string\">&#x27;my-site-cache-v1&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> urlsToCache = [<br>  <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;/styles/main.css&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;/script/main.js&#x27;</span><br>];<br><br>self.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;install&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-comment\">// Perform install steps</span><br>  event.<span class=\"hljs-title function_\">waitUntil</span>(<br>    caches.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-variable constant_\">CACHE_NAME</span>)<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cache</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Opened cache&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> cache.<span class=\"hljs-title function_\">addAll</span>(urlsToCache);<br>      &#125;)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>需要注意的是，如果 <code>cache.addAll()</code> 方法缓存的其中一个资源失败了，会导致 Service Worker 进入废弃模式，直到页面刷新后，Service Worker 重新 install 再次尝试缓存。</p>\n<h3 id=\"在-Service-Worker-中缓存以及返回请求\"><a href=\"#在-Service-Worker-中缓存以及返回请求\" class=\"headerlink\" title=\"在 Service Worker 中缓存以及返回请求\"></a>在 Service Worker 中缓存以及返回请求</h3><p>在 Service Worker 激活后，它将开始接收网页所发送的 fetch 事件，并且通过 <code>event.responseWith()</code> 方法，返回自定义的响应。结合 Cache API 中的 <code>cache.put()</code> 、<code>caches.match()</code> 方法，我们能够将请求的响应保存起来，在再次收到相同请求时，返回上一次的缓存响应结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// serviceWorker.js</span><br>self.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;fetch&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  event.<span class=\"hljs-title function_\">respondWith</span>(<br>    <span class=\"hljs-comment\">// 根据请求 URL，查找缓存是否对应的缓存响应</span><br>    caches.<span class=\"hljs-title function_\">match</span>(event.<span class=\"hljs-property\">request</span>)<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">response</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (response) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 判断存在缓存响应，直接返回</span><br>          <span class=\"hljs-keyword\">return</span> response;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetch</span>(event.<span class=\"hljs-property\">request</span>);<br>      &#125;<br>    )<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Service-Worker-使用细节\"><a href=\"#Service-Worker-使用细节\" class=\"headerlink\" title=\"Service Worker 使用细节\"></a>Service Worker 使用细节</h2><h3 id=\"Service-Worker-必须在-HTTPS-协议下使用\"><a href=\"#Service-Worker-必须在-HTTPS-协议下使用\" class=\"headerlink\" title=\"Service Worker 必须在 HTTPS 协议下使用\"></a>Service Worker 必须在 HTTPS 协议下使用</h3><p>因为 Service Worker 能捕捉其作用域下的所有网络请求，为了保证其不会因为中间人篡改了 serviceWorker 脚本而导致隐私泄漏，W3C 协会规定 Service Worker 必须要在 HTTPS 协议下使用。</p>\n<h3 id=\"Service-Worker-脚本必须与网页处于同一个-Origin-下\"><a href=\"#Service-Worker-脚本必须与网页处于同一个-Origin-下\" class=\"headerlink\" title=\"Service Worker 脚本必须与网页处于同一个 Origin  下\"></a>Service Worker 脚本必须与网页处于同一个 Origin  下</h3><p>脚本资源必须与网页资源处于同一个 Origin 下，导致了脚本资源无法部署到 CDN 独立域名上。<br>这可能与 Service Worker 的机制有关系：在浏览器访问网页的时候，它会根据网页的 Domain Origin 匹配之前是否已经有注册成功的 Service Worker，如果匹配存在的话，会在发起请求之前先将 Service Worker 线程安装并启动。因此这里严格地要求了 Service Worker 的脚本资源路径。</p>\n<h3 id=\"Service-Worker-的作用域限制在其脚本存放路径上\"><a href=\"#Service-Worker-的作用域限制在其脚本存放路径上\" class=\"headerlink\" title=\"Service Worker 的作用域限制在其脚本存放路径上\"></a>Service Worker 的作用域限制在其脚本存放路径上</h3><p>根绝文档描述，Service Worker 所能捕捉的网络请求跟脚本所在的路径有关。若脚本路径在 <code>/sw.js</code> 上，Service Worker 默认能够捕捉到 <code>/</code> 范围内的所有网络请求。当前，<code>register()</code> 方法能够进一步通过 <code>scope</code> 参数限制 Service Worker 的作用域范围：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">navigator.<span class=\"hljs-property\">serviceWorker</span>.<span class=\"hljs-title function_\">register</span>(<span class=\"hljs-string\">&#x27;/sw.js&#x27;</span>, &#123; <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-string\">&#x27;/subdomain/&#x27;</span> &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">registration</span>) &#123;<br>  <span class=\"hljs-comment\">// Registration was successful</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.<span class=\"hljs-property\">scope</span>);<br>&#125;, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) &#123;<br>  <span class=\"hljs-comment\">// registration failed :(</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration failed: &#x27;</span>, err);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>通过上述指定 <code>scope</code> 参数的方法，Service Worker 就只会收到 <code>/subdomain</code> 下的网络 fetch 事件。</p>\n<p>但如果我们将 Service Worker 脚本存放在 <code>/subdomain/sw.js</code> 上，那么 Service Worker 默认只会收到 <code>/subdomain/</code> 作用域下的网络请求，并不会再收到 <code>/</code> 域名下的网络请求。<br>如果我们强制将 <code>scope</code> 参数配置为 <code>/</code> 上，就会收到 <code>register()</code> 方法的失败响应：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">ServiceWorker registration failed:  DOMException: Failed to register a ServiceWorker for scope (&#x27;https://www.qq.com/subdomain&#x27;) with script (&#x27;https://www.qq.com/subdomain/sw.js&#x27;): The path of the provided scope (&#x27;/&#x27;) is not under the max scope allowed (&#x27;/subdomain/&#x27;). Adjust the scope, move the Service Worker script, or use the Service-Worker-Allowed HTTP header to allow the scope.<br></code></pre></td></tr></table></figure>\n<p>我们需要在 <code>sw.js</code> 脚本的返回头部加入 <code>Service-Worker-Allowed: &#39;/‘</code> 才能正确接受 <code>/</code> 作用域的网络请求事件。</p>\n<blockquote>\n<p>但实际上，笔者在 Chrome&#x2F;78.0.3904.113 版本上测试，<code>/subdomain/sw.js</code> 脚本注册的 Service Worker 不仅无法接收到 <code>/</code> 作用域的网络请求，甚至连其合法的 <code>/subdomain/</code> 作用域下的网络请求都无法接收。这里并不确定是 Service Worker 规范变更了， 还是 Chrome 浏览器的问题。所以还是建议 Service Worker 脚本<strong>最好配置在网页资源的同级目录下</strong>。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"前言\n在笔者的项目中，加快页面加载速度一直是提高用户体验的重点，优化页面加载速度的手段也有很多：\n\n * 使用 CDN 网络缓存代码资源\n * 使用 webpack 等开发工具合并细小资源，减少 HTTP 请求数量\n * 使用 UglifyJS 等工具压缩 Javascript 代码，减少网络传输数据\n * 使用 SVG 资源代替 PNG 等图片资源\n   等等…\n\n 然而上述的优化手段都是通过减","more":"<p>前言<br>在笔者的项目中，加快页面加载速度一直是提高用户体验的重点，优化页面加载速度的手段也有很多：</p>\n<ul>\n<li>使用 CDN 网络缓存代码资源</li>\n<li>使用 webpack 等开发工具合并细小资源，减少 HTTP 请求数量</li>\n<li>使用 UglifyJS 等工具压缩 Javascript 代码，减少网络传输数据</li>\n<li>使用 SVG 资源代替 PNG 等图片资源<br>等等…</li>\n</ul>\n<p> 然而上述的优化手段都是通过减少网络请求开销从而达到优化加载页面速度的目的，但对于类似在线文档这类用户较为频繁使用的产品，更加需要关注用户缓存的方向。在此之前，前端页面一直依赖浏览器的缓存管理，因此我们需要更精细化地管理用户的缓存，为了达到这个目的，我们需要使用到 <strong>Service Worker</strong>。</p>\n<h2 id=\"什么是-Service-Worker\"><a href=\"#什么是-Service-Worker\" class=\"headerlink\" title=\"什么是 Service Worker\"></a>什么是 Service Worker</h2><p>Service Worker 属于其中一个 Web Worker 技术，部分中文文档会将其翻译为 <code>服务工作线程</code> ，它是脱离于网页 Javascript 环境的一个独立的线程。因此 Service Worker 的生命周期完全独立于网页，在页面刷新时，依然能存活并且接受页面刷新所发送的事件。Service Worker 主要有三个作用：</p>\n<ol>\n<li>拦截网页请求，并返回指定响应</li>\n<li>后台同步功能</li>\n<li>消息推送功能</li>\n</ol>\n<p>后台同步功能是得益于 Service Worker 独特的生命周期，使得网页在用户关闭后，Service Worker 线程依然能存活一定时间，将未成功的网络请求发送到服务器中。</p>\n<p>消息推送是 Service Worker 另外一个重要的场景，它使得用户在没有打开网页的情况下，能够收到服务器推送过来的提醒消息。这种功能类似于如今 iOS 上的推送消息。消息推送依赖于浏览器厂商提供的推送服务，不幸的是，Chrome 浏览器的厂商 Google，被隔绝于 GFW 之外，使得 Chrome 的推送服务无法正常使用。</p>\n<p>拦截网络请求功能是 Service Worker 使用最为广泛的功能。在 Service Worker 中，它能收到管辖区域内的所有资源发起的网络请求，同时能对这部分的网络请求进行自定义的处理。并且，在 Service Worker 环境中，浏览器提供了一套完备的 Cache API，能够对网络的 <code>Request</code> 以及 <code>Response</code> 进行保存处理。正式因为这两种技术，使得 Service Worker 能够为网页提供一个离线运行的环境，成为 Progress Web Application（PWA）的核心部分。</p>\n<h2 id=\"Service-Worker-的优势\"><a href=\"#Service-Worker-的优势\" class=\"headerlink\" title=\"Service Worker 的优势\"></a>Service Worker 的优势</h2><p>本地缓存并非什么新的技术，早在 Service Worker 技术出现以前，各种浏览器对于网络请求都有进行缓存处理，为的就是提高网络的响应速度、加快页面加载时间，从而吸引更多的用户使用。而在此之后，为了方面开发者对于缓存的管理，提出了 LocalStorage、Web SQL Database、indexdDB 等技术。对比这些技术，Service Worker 的优势在哪里呢？</p>\n<h3 id=\"Service-Worker-能保存更多的数据\"><a href=\"#Service-Worker-能保存更多的数据\" class=\"headerlink\" title=\"Service Worker 能保存更多的数据\"></a>Service Worker 能保存更多的数据</h3><p>根据 <a href=\"https://en.wikipedia.org/wiki/Web_Storage\">Wikipedia</a> 上的描述 ，开发者通过 LocalStorage 使用的缓存限制大小为 <code>5MB-10MB</code> ，而通过 indexedDB 缓存的大小限制最大为 <code>50MB</code> 。<br>这容量限制对于保存普通用户数据来说已经足够，可是对于缓存脚本文件、样式文件却显得捉襟见肘。<br>根据 <a href=\"https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/offline-for-pwa\">Google 开发文档</a>中显示，Service Worker 所能使用的容量大小不再做统一限制，而是由当前电脑的磁盘空间所限制。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ServiceWorker%E5%AE%B9%E9%87%8F%E9%99%90%E5%88%B6.png\" alt=\"ServiceWorker容量限制.png\"></p>\n<blockquote>\n<p>在 iOS Safari 中，Service Worker 保存的数据依然限制 50MB。</p>\n</blockquote>\n<h3 id=\"Service-Worker-与业务逻辑的耦合更低\"><a href=\"#Service-Worker-与业务逻辑的耦合更低\" class=\"headerlink\" title=\"Service Worker 与业务逻辑的耦合更低\"></a>Service Worker 与业务逻辑的耦合更低</h3><p>不同于 LocalStoage 、indexDB 等需要对不同的模块代码手动处理缓存逻辑，Service Worker 在独立的线程中，统一处理网页所发送的网络请求，能够做到对业务逻辑代码零侵入。</p>\n<h3 id=\"Service-Worker-能在无网络状态下返回页面\"><a href=\"#Service-Worker-能在无网络状态下返回页面\" class=\"headerlink\" title=\"Service Worker 能在无网络状态下返回页面\"></a>Service Worker 能在无网络状态下返回页面</h3><p>Service Worker 处理一个独立的线程，生命周期也独立网页，因此在页面关闭或者是刷新时，Service Worker 能持续地处于存活状态。如果 Service Worker  缓存 HTML 数据，那在其存活的时间内，能够在无网络的环境下返回缓存的页面数据，让网页离线使用成为了可能。</p>\n<h2 id=\"Service-Worker-的生命周期\"><a href=\"#Service-Worker-的生命周期\" class=\"headerlink\" title=\"Service Worker 的生命周期\"></a>Service Worker 的生命周期</h2><p><img src=\"https://cdn.iguan7u.cn/image/ServiceWorkerLifeCycle.png\" alt=\"LifeCycle.png\"></p>\n<p>Service Worker 的生命周期主要在 4 个阶段：</p>\n<ol>\n<li>安装</li>\n<li>等待</li>\n<li>活跃</li>\n<li>废弃</li>\n</ol>\n<p>在浏览器下载完成 Service Worker 脚本资源后，浏览器会初始化 Worker 线程并加载脚本资源。在完成上述步骤后，浏览器会分发一个 <code>install</code> 事件给 Service Worker 线程，等待线程完成 install 事件的相关操作，通常在这个阶段，我们能预加载一下网页所需要的资源。而这个阶段，我们称之为<strong>安装阶段</strong>。</p>\n<p>在安装完成后，Service Worker 并没有马上被激活，如果在此之前已经有正在处于激活态 Service Worker 线程，那么新安装的线程会一直处于<strong>等待阶段</strong>，等待前一个工作线程废弃。</p>\n<p>如果在此之前没有另外的 Service Worker，那么它将马上进入<strong>活跃状态</strong>。在这个状态下，Service Worker 将会收到页面发起请求所触发的 <code>fetch</code> 事件，以及 <code>push</code> 和 <code>sync</code> 的功能性事件。</p>\n<p>如果 Service Worker 在安装阶段预加载网络资源失败了，那个它将会进入<strong>废弃阶段</strong>，这个阶段 Service Worker 并不会生效，也无法监听到网页触发的所有事件。</p>\n<h2 id=\"Service-Worker-的使用流程\"><a href=\"#Service-Worker-的使用流程\" class=\"headerlink\" title=\"Service Worker 的使用流程\"></a>Service Worker 的使用流程</h2><p>Service Worker 的使用方法较为简单，需要经过以下几个步骤：</p>\n<h3 id=\"注册-Service-Worker-线程\"><a href=\"#注册-Service-Worker-线程\" class=\"headerlink\" title=\"注册 Service Worker 线程\"></a>注册 Service Worker 线程</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&#x27;serviceWorker&#x27;</span> <span class=\"hljs-keyword\">in</span> navigator) &#123;<br>  navigator.<span class=\"hljs-property\">serviceWorker</span>.<span class=\"hljs-title function_\">register</span>(<span class=\"hljs-string\">&#x27;/sw.js&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">registration</span>) &#123;<br>    <span class=\"hljs-comment\">/* 注册 Service Worker 成功 */</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.<span class=\"hljs-property\">scope</span>);<br>  &#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) &#123;<br>    <span class=\"hljs-comment\">/* 注册 Service Worker 失败 */</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration failed: &#x27;</span>, err);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>navigator.serviceWorker.register</code> 方法会返回一个 Promise，注册成功后该 Promise 会触发 then 方法，如果不成功会抛出对应异常。</p>\n<p>注册成功后，我们可以在 Chrome 中打开 <code>chrome://inspect/#service-workers</code> 查看注册成功的 Service Worker。</p>\n<p><img src=\"https://cdn.iguan7u.cn/image/ServiceWorkerChrome.png\" alt=\"ServiceWorkerChrome.png\"></p>\n<h3 id=\"在-Service-Worker-中监听-Install-事件\"><a href=\"#在-Service-Worker-中监听-Install-事件\" class=\"headerlink\" title=\"在 Service Worker 中监听 Install 事件\"></a>在 Service Worker 中监听 Install 事件</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">self.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;install&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-comment\">// 收到 install 事件，处理资源预加载的逻辑</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>在 install 回调的内部，我们需要执行以下步骤：</p>\n<ol>\n<li><code>caches.open()</code> 打开缓存仓库。</li>\n<li><code>cache.addAll()</code> 缓存所需的资源文件。</li>\n<li>确认所有需要的资源是否已缓存。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// serviceWorker.js</span><br><span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable constant_\">CACHE_NAME</span> = <span class=\"hljs-string\">&#x27;my-site-cache-v1&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> urlsToCache = [<br>  <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;/styles/main.css&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;/script/main.js&#x27;</span><br>];<br><br>self.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;install&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  <span class=\"hljs-comment\">// Perform install steps</span><br>  event.<span class=\"hljs-title function_\">waitUntil</span>(<br>    caches.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-variable constant_\">CACHE_NAME</span>)<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cache</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Opened cache&#x27;</span>);<br>        <span class=\"hljs-keyword\">return</span> cache.<span class=\"hljs-title function_\">addAll</span>(urlsToCache);<br>      &#125;)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>需要注意的是，如果 <code>cache.addAll()</code> 方法缓存的其中一个资源失败了，会导致 Service Worker 进入废弃模式，直到页面刷新后，Service Worker 重新 install 再次尝试缓存。</p>\n<h3 id=\"在-Service-Worker-中缓存以及返回请求\"><a href=\"#在-Service-Worker-中缓存以及返回请求\" class=\"headerlink\" title=\"在 Service Worker 中缓存以及返回请求\"></a>在 Service Worker 中缓存以及返回请求</h3><p>在 Service Worker 激活后，它将开始接收网页所发送的 fetch 事件，并且通过 <code>event.responseWith()</code> 方法，返回自定义的响应。结合 Cache API 中的 <code>cache.put()</code> 、<code>caches.match()</code> 方法，我们能够将请求的响应保存起来，在再次收到相同请求时，返回上一次的缓存响应结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// serviceWorker.js</span><br>self.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;fetch&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) &#123;<br>  event.<span class=\"hljs-title function_\">respondWith</span>(<br>    <span class=\"hljs-comment\">// 根据请求 URL，查找缓存是否对应的缓存响应</span><br>    caches.<span class=\"hljs-title function_\">match</span>(event.<span class=\"hljs-property\">request</span>)<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">response</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (response) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 判断存在缓存响应，直接返回</span><br>          <span class=\"hljs-keyword\">return</span> response;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetch</span>(event.<span class=\"hljs-property\">request</span>);<br>      &#125;<br>    )<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Service-Worker-使用细节\"><a href=\"#Service-Worker-使用细节\" class=\"headerlink\" title=\"Service Worker 使用细节\"></a>Service Worker 使用细节</h2><h3 id=\"Service-Worker-必须在-HTTPS-协议下使用\"><a href=\"#Service-Worker-必须在-HTTPS-协议下使用\" class=\"headerlink\" title=\"Service Worker 必须在 HTTPS 协议下使用\"></a>Service Worker 必须在 HTTPS 协议下使用</h3><p>因为 Service Worker 能捕捉其作用域下的所有网络请求，为了保证其不会因为中间人篡改了 serviceWorker 脚本而导致隐私泄漏，W3C 协会规定 Service Worker 必须要在 HTTPS 协议下使用。</p>\n<h3 id=\"Service-Worker-脚本必须与网页处于同一个-Origin-下\"><a href=\"#Service-Worker-脚本必须与网页处于同一个-Origin-下\" class=\"headerlink\" title=\"Service Worker 脚本必须与网页处于同一个 Origin  下\"></a>Service Worker 脚本必须与网页处于同一个 Origin  下</h3><p>脚本资源必须与网页资源处于同一个 Origin 下，导致了脚本资源无法部署到 CDN 独立域名上。<br>这可能与 Service Worker 的机制有关系：在浏览器访问网页的时候，它会根据网页的 Domain Origin 匹配之前是否已经有注册成功的 Service Worker，如果匹配存在的话，会在发起请求之前先将 Service Worker 线程安装并启动。因此这里严格地要求了 Service Worker 的脚本资源路径。</p>\n<h3 id=\"Service-Worker-的作用域限制在其脚本存放路径上\"><a href=\"#Service-Worker-的作用域限制在其脚本存放路径上\" class=\"headerlink\" title=\"Service Worker 的作用域限制在其脚本存放路径上\"></a>Service Worker 的作用域限制在其脚本存放路径上</h3><p>根绝文档描述，Service Worker 所能捕捉的网络请求跟脚本所在的路径有关。若脚本路径在 <code>/sw.js</code> 上，Service Worker 默认能够捕捉到 <code>/</code> 范围内的所有网络请求。当前，<code>register()</code> 方法能够进一步通过 <code>scope</code> 参数限制 Service Worker 的作用域范围：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">navigator.<span class=\"hljs-property\">serviceWorker</span>.<span class=\"hljs-title function_\">register</span>(<span class=\"hljs-string\">&#x27;/sw.js&#x27;</span>, &#123; <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-string\">&#x27;/subdomain/&#x27;</span> &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">registration</span>) &#123;<br>  <span class=\"hljs-comment\">// Registration was successful</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.<span class=\"hljs-property\">scope</span>);<br>&#125;, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) &#123;<br>  <span class=\"hljs-comment\">// registration failed :(</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;ServiceWorker registration failed: &#x27;</span>, err);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>通过上述指定 <code>scope</code> 参数的方法，Service Worker 就只会收到 <code>/subdomain</code> 下的网络 fetch 事件。</p>\n<p>但如果我们将 Service Worker 脚本存放在 <code>/subdomain/sw.js</code> 上，那么 Service Worker 默认只会收到 <code>/subdomain/</code> 作用域下的网络请求，并不会再收到 <code>/</code> 域名下的网络请求。<br>如果我们强制将 <code>scope</code> 参数配置为 <code>/</code> 上，就会收到 <code>register()</code> 方法的失败响应：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">ServiceWorker registration failed:  DOMException: Failed to register a ServiceWorker for scope (&#x27;https://www.qq.com/subdomain&#x27;) with script (&#x27;https://www.qq.com/subdomain/sw.js&#x27;): The path of the provided scope (&#x27;/&#x27;) is not under the max scope allowed (&#x27;/subdomain/&#x27;). Adjust the scope, move the Service Worker script, or use the Service-Worker-Allowed HTTP header to allow the scope.<br></code></pre></td></tr></table></figure>\n<p>我们需要在 <code>sw.js</code> 脚本的返回头部加入 <code>Service-Worker-Allowed: &#39;/‘</code> 才能正确接受 <code>/</code> 作用域的网络请求事件。</p>\n<blockquote>\n<p>但实际上，笔者在 Chrome&#x2F;78.0.3904.113 版本上测试，<code>/subdomain/sw.js</code> 脚本注册的 Service Worker 不仅无法接收到 <code>/</code> 作用域的网络请求，甚至连其合法的 <code>/subdomain/</code> 作用域下的网络请求都无法接收。这里并不确定是 Service Worker 规范变更了， 还是 Chrome 浏览器的问题。所以还是建议 Service Worker 脚本<strong>最好配置在网页资源的同级目录下</strong>。</p>\n</blockquote>\n"},{"title":"复盘 2018","date":"2019-03-17T12:07:39.000Z","_content":"\n度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。\n从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。\n\n## 2015-2016\n毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。\n\n### Clang Static Analyzer\n\n第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 **clang**，相应的，了解到 **LLVM**、**AST**，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。\n记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。\n假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。\n\n### Fauxpas\n\n那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 [Faux Pas for Xcode](http://fauxpasapp.com/) ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。\n\n优点：\n1. 代码检测规则实用；\n2. 可自行配置实用的规则；\n3. 检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；\n\n缺点：\n1. 收费应用；\n2. 无法自定义规则；\n\n### 持续集成\n\n接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。\n\n## 2016-2017\n众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。\n而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。\n\n##### 热更新\n\n随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 [JSPatch](https://github.com/bang590/JSPatch) 、 [wax](https://github.com/probablycorey/wax) 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。\n在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。\n\n因此热更新修复的流程，及其繁琐：\n1. 开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；\n2. 确认问题，使用原生代码修复该问题；\n3. 改用热更新框架语言，重新实现修复逻辑；\n4. 提单，测试进行介入，确认无误后准备上线现网；\n5. 灰度上线；\n6. 回到主干代码，merge 分支对应修复逻辑；\n7. 测试再次介入，确认问题在主干分支中也同样被解决；\n\n而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。\n在热更新方面，`JSPatch` 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 `wax patch`。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 `JSPatch` 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于**简单语句**，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。\n由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 [ANTLR](https://www.antlr.org)，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。\n\n> 后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  \n\n##### 跨平台开发\n\n在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。\n\n> Code once, run everywhere.  \n\n可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。\n而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。\n然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。\n所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。\n\n## 2017-2018\n终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。\n在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  \n\n与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如**单项数据流**这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。\n\n这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。\n\n而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。\n\n- 在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；\n\t1. JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；\n\t2. JS 逻辑中，根据 `navigator.onLine`属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；\n\t3. Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；\n\n- 离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中\n\t1. 由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护\n\t2. H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：\n\t\t1. sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；\n\t\t2. localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；\n\t\t3. Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案\n\t\t4. Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术\n\t折中取舍，我们最终选择的 localStorage 作为文档操作的存储\t方式。\n\t3. 因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。\n\t4. 离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。\n\n- 作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：\n\t- 考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。\n\t- 虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 `alloc` 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。\n \n老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。\n\n现在，终于可以开始 Enjoy the new beginning! \n","source":"_posts/复盘-2018.md","raw":"---\ntitle: 复盘 2018\ndate: 2019-03-17 20:07:39\ntags:\n---\n\n度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。\n从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。\n\n## 2015-2016\n毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。\n\n### Clang Static Analyzer\n\n第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 **clang**，相应的，了解到 **LLVM**、**AST**，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。\n记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。\n假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。\n\n### Fauxpas\n\n那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 [Faux Pas for Xcode](http://fauxpasapp.com/) ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。\n\n优点：\n1. 代码检测规则实用；\n2. 可自行配置实用的规则；\n3. 检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；\n\n缺点：\n1. 收费应用；\n2. 无法自定义规则；\n\n### 持续集成\n\n接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。\n\n## 2016-2017\n众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。\n而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。\n\n##### 热更新\n\n随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 [JSPatch](https://github.com/bang590/JSPatch) 、 [wax](https://github.com/probablycorey/wax) 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。\n在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。\n\n因此热更新修复的流程，及其繁琐：\n1. 开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；\n2. 确认问题，使用原生代码修复该问题；\n3. 改用热更新框架语言，重新实现修复逻辑；\n4. 提单，测试进行介入，确认无误后准备上线现网；\n5. 灰度上线；\n6. 回到主干代码，merge 分支对应修复逻辑；\n7. 测试再次介入，确认问题在主干分支中也同样被解决；\n\n而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。\n在热更新方面，`JSPatch` 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 `wax patch`。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 `JSPatch` 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于**简单语句**，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。\n由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 [ANTLR](https://www.antlr.org)，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。\n\n> 后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  \n\n##### 跨平台开发\n\n在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。\n\n> Code once, run everywhere.  \n\n可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。\n而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。\n然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。\n所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。\n\n## 2017-2018\n终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。\n在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  \n\n与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如**单项数据流**这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。\n\n这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。\n\n而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。\n\n- 在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；\n\t1. JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；\n\t2. JS 逻辑中，根据 `navigator.onLine`属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；\n\t3. Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；\n\n- 离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中\n\t1. 由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护\n\t2. H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：\n\t\t1. sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；\n\t\t2. localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；\n\t\t3. Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案\n\t\t4. Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术\n\t折中取舍，我们最终选择的 localStorage 作为文档操作的存储\t方式。\n\t3. 因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。\n\t4. 离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。\n\n- 作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：\n\t- 考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。\n\t- 虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 `alloc` 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。\n \n老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。\n\n现在，终于可以开始 Enjoy the new beginning! \n","slug":"复盘-2018","published":1,"updated":"2022-02-23T13:14:20.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4y2f5hg000frv058ct066ob","content":"<p>度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。<br>从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。</p>\n<h2 id=\"2015-2016\"><a href=\"#2015-2016\" class=\"headerlink\" title=\"2015-2016\"></a>2015-2016</h2><p>毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。</p>\n<h3 id=\"Clang-Static-Analyzer\"><a href=\"#Clang-Static-Analyzer\" class=\"headerlink\" title=\"Clang Static Analyzer\"></a>Clang Static Analyzer</h3><p>第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 <strong>clang</strong>，相应的，了解到 <strong>LLVM</strong>、<strong>AST</strong>，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。<br>记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。<br>假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。</p>\n<h3 id=\"Fauxpas\"><a href=\"#Fauxpas\" class=\"headerlink\" title=\"Fauxpas\"></a>Fauxpas</h3><p>那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 <a href=\"http://fauxpasapp.com/\">Faux Pas for Xcode</a> ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。</p>\n<p>优点：</p>\n<ol>\n<li>代码检测规则实用；</li>\n<li>可自行配置实用的规则；</li>\n<li>检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>收费应用；</li>\n<li>无法自定义规则；</li>\n</ol>\n<h3 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h3><p>接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。</p>\n<h2 id=\"2016-2017\"><a href=\"#2016-2017\" class=\"headerlink\" title=\"2016-2017\"></a>2016-2017</h2><p>众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。<br>而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。</p>\n<h5 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h5><p>随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 <a href=\"https://github.com/bang590/JSPatch\">JSPatch</a> 、 <a href=\"https://github.com/probablycorey/wax\">wax</a> 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。<br>在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。</p>\n<p>因此热更新修复的流程，及其繁琐：</p>\n<ol>\n<li>开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；</li>\n<li>确认问题，使用原生代码修复该问题；</li>\n<li>改用热更新框架语言，重新实现修复逻辑；</li>\n<li>提单，测试进行介入，确认无误后准备上线现网；</li>\n<li>灰度上线；</li>\n<li>回到主干代码，merge 分支对应修复逻辑；</li>\n<li>测试再次介入，确认问题在主干分支中也同样被解决；</li>\n</ol>\n<p>而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。<br>在热更新方面，<code>JSPatch</code> 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 <code>wax patch</code>。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 <code>JSPatch</code> 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于<strong>简单语句</strong>，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。<br>由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 <a href=\"https://www.antlr.org/\">ANTLR</a>，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。</p>\n<blockquote>\n<p>后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  </p>\n</blockquote>\n<h5 id=\"跨平台开发\"><a href=\"#跨平台开发\" class=\"headerlink\" title=\"跨平台开发\"></a>跨平台开发</h5><p>在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。</p>\n<blockquote>\n<p>Code once, run everywhere.  </p>\n</blockquote>\n<p>可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。<br>而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。<br>然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。<br>所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。</p>\n<h2 id=\"2017-2018\"><a href=\"#2017-2018\" class=\"headerlink\" title=\"2017-2018\"></a>2017-2018</h2><p>终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。<br>在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：</p>\n<blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  </p>\n</blockquote>\n<p>与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如<strong>单项数据流</strong>这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。</p>\n<p>这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。</p>\n<p>而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。</p>\n<ul>\n<li><p>在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；</p>\n<ol>\n<li>JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；</li>\n<li>JS 逻辑中，根据 <code>navigator.onLine</code>属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；</li>\n<li>Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；</li>\n</ol>\n</li>\n<li><p>离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中</p>\n<ol>\n<li>由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护</li>\n<li>H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：<ol>\n<li>sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；</li>\n<li>localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；</li>\n<li>Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案</li>\n<li>Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术<br>  折中取舍，我们最终选择的 localStorage 作为文档操作的存储    方式。</li>\n</ol>\n</li>\n<li>因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。</li>\n<li>离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。</li>\n</ol>\n</li>\n<li><p>作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：</p>\n<ul>\n<li>考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。</li>\n<li>虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 <code>alloc</code> 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。</li>\n</ul>\n</li>\n</ul>\n<p>老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。</p>\n<p>现在，终于可以开始 Enjoy the new beginning! </p>\n","site":{"data":{}},"excerpt":"度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。\n从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。\n\n2015-2016\n毕业刚刚进入公司，对","more":"<p>度过了进入公司的第三年，需要开始深切的回顾自己的工作历程，认真考虑自己的职业生涯了。<br>从进入公司的第一年开始，Leader 就已经认真地跟我说明了：“进入职场的三年尤其重要，这可能直接间接地确定你以后的职业生涯。”一眨眼，三年转瞬即逝，不太好确定自己在过去三年奠定了什么基础，既有满足，也有懊悔。这里与其说复盘 2018，不如复盘 2015-2018 吧。</p>\n<h2 id=\"2015-2016\"><a href=\"#2015-2016\" class=\"headerlink\" title=\"2015-2016\"></a>2015-2016</h2><p>毕业刚刚进入公司，对技术颇有追求。全身心投入到项目中，对自己的每一个换行、每一个分号都有严格的要求，期待自己能写出完美代码。只是后来发现，这种心理对于项目并无太大意义，这是后话了。</p>\n<h3 id=\"Clang-Static-Analyzer\"><a href=\"#Clang-Static-Analyzer\" class=\"headerlink\" title=\"Clang Static Analyzer\"></a>Clang Static Analyzer</h3><p>第一年 Leader 安排了一个小项目，在项目中接入代码静态分析的检查，我第一次接触到 <strong>clang</strong>，相应的，了解到 <strong>LLVM</strong>、<strong>AST</strong>，老实说，对于刚进入职场的新人来说，这段项目经验并不友好。鉴于大学阶段对于大型项目接触经验较少，接触这个项目时真的是束手无策，C++ 的语法虽然说并不陌生，可是当看到真实项目中的指针、模版，毫无亲切感。<br>记得当时的项目要求中，希望在 clang static analyzer 中添加自定义的检测规则，国内在这方面的分享文档简直少得可怜，所以百度搜索基本毫无结果。官网上有英文文档，对于添加自定义规则的功能也有提及，可是却没有详细说明规则实现的原理、暴露的 API 接口、静态检测的流程，对新手友好度远不及 github 上热门的开源项目。无可厚非，有这方面需求的开发人员，一般对编译器有深入的了解，静态检测虽是开箱即用的工具，可是内部涉及的原理，语法树、编译上下文都是需要优秀开发者所创造的结晶，实在非一个新手开发者所能轻易消化理解。<br>假若当初能一直坚持这个项目的钻研，或许现在对代码底层的认知会更为扎实了。</p>\n<h3 id=\"Fauxpas\"><a href=\"#Fauxpas\" class=\"headerlink\" title=\"Fauxpas\"></a>Fauxpas</h3><p>那时候在项目中除了接入 clang 静态分析以外，还使用了一个国外的代码检测应用 <a href=\"http://fauxpasapp.com/\">Faux Pas for Xcode</a> ，这个应用除了能提供基础的静态分析规则外，还提供了一些实用的分析规则，并且能自行配置需要使用的规则。另外，这个应用对项目进行分析所需要的时间远小于 Clang Static Analyzer，对项目代码质量要求较高的，强烈推荐使用这个应用。</p>\n<p>优点：</p>\n<ol>\n<li>代码检测规则实用；</li>\n<li>可自行配置实用的规则；</li>\n<li>检测结果除了提供页面展示以外，也能在命令行中执行输出 JSON 格式的结果，非常符合接入自动构建系统中；</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>收费应用；</li>\n<li>无法自定义规则；</li>\n</ol>\n<h3 id=\"持续集成\"><a href=\"#持续集成\" class=\"headerlink\" title=\"持续集成\"></a>持续集成</h3><p>接触部署 Clang Static Analyzer 以及 Fauxpas 后，让我明白到自动化跟持续集成对于一个项目发展的重要性，也让我明白了测试开发对于一个项目的支持是多么重要。然而其实国内很多团队都对于这方面要求颇有疏忽，虽然我经过切身体验，这方面的支持是相当繁琐并且无趣的。</p>\n<h2 id=\"2016-2017\"><a href=\"#2016-2017\" class=\"headerlink\" title=\"2016-2017\"></a>2016-2017</h2><p>众所周知，iOS 应用不提供执行应用外部的二进制文件的功能，也就是说，在 iOS 中，从 App Store 下载下来的应用，无论你使用与否，应用中都包含了的所有功能。这点与 Android 应用截然不同。因此一般情况下，iOS 应用包尺寸都会比 Android 应用包要大。<br>而另一方面，苹果禁止了这方面的功能，导致开发者对于发布苹果应用有着异常谨慎的态度，因为一旦发布出去，其中包含了未被测试发现的问题，开发者只能再次等待漫长的应用审核（后来苹果提供了加速审核的途径，只不过严格限制了使用次数），才能重新上架应用修复问题。</p>\n<h5 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h5><p>随着时间推移，开发者们逐渐加入研究如何能在不经过版本审核去修复线上问题，或者提供新功能。后来随着 <a href=\"https://github.com/bang590/JSPatch\">JSPatch</a> 、 <a href=\"https://github.com/probablycorey/wax\">wax</a> 等一系列热更新框架兴起，组内、甚至行业内对 iOS 的热更新兴致达到了前所未有的水平。热更新 (hotfix)，笔者认为，其实很难定义这门技术究竟是好是坏。毫无疑问，它的出现对于 iOS 开发领域来说，是降低的版本发布的风险，让应用发布后修复问题成为了可能。甚至让无需重新提交 App Store 版本审核，直接让应用提供新功能。在 Android 开发中，这种模式是相当常见的。然而它极大的打乱了版本发布流程，让发布前测试在整个应用开发流程中的重要性降低，容易导致项目管理者无法准备把握项目的开发进度。<br>在很长一段时间中，笔者以及周围的同事都对热更新抱以恐惧的心态。因为应用提交审核跟发布之间存在着时间差（没错，就是苹果万恶的审核时间，审核加速前这个时间一般长达 7 到 14 天），而在这段时间内，版本肯定是需要继续迭代的。真正需要热更新修复时，代码早已不是对应版本。</p>\n<p>因此热更新修复的流程，及其繁琐：</p>\n<ol>\n<li>开发者需要回滚代码，或者 checkout 对应的 tag 分支，查阅旧版本逻辑代码；</li>\n<li>确认问题，使用原生代码修复该问题；</li>\n<li>改用热更新框架语言，重新实现修复逻辑；</li>\n<li>提单，测试进行介入，确认无误后准备上线现网；</li>\n<li>灰度上线；</li>\n<li>回到主干代码，merge 分支对应修复逻辑；</li>\n<li>测试再次介入，确认问题在主干分支中也同样被解决；</li>\n</ol>\n<p>而真正令人为此反感的，是这个流程可能随时出现，打断你当前的开发进度。为此笔者跟周围的同事付出了沉重的代价。然而在这个过程中，我们还是作出了一点成绩的。<br>在热更新方面，<code>JSPatch</code> 一直是我们团队中的备选方案，比起 Javascript，我们选择的 lua 语言方案的 <code>wax patch</code>。然而两种方案都有一个固定缺陷，开发者无法使用原生语言进行 hotfix 开发，因此 <code>JSPatch</code> 的作者开发了一个在线转换的小工具，能够对简单的 Objective-C 语句进行转换，这极大的方便了大部分的开发者，也体现了作者对于开源社区生态建设付出的努力。可是这仅限于<strong>简单语句</strong>，对于复杂的语句，那个翻译小工具给出的效果不尽如人意。<br>由此可见，通过简单的字符替换进行语法转换，是在复杂的代码前是无法胜任的。我们使用了 <a href=\"https://www.antlr.org/\">ANTLR</a>，一个语法解析器，将 Objective-C 代码解析成语法树，再根据其语法树转换成 lua 代码，成功解决复杂语法转换的问题。在实践中，我们成功将一个复杂模块全部替换成热更新逻辑，做到动态下发以及热插拔。</p>\n<blockquote>\n<p>后续因为苹果官方严格审查 Patch 等后门，该项目停滞。  </p>\n</blockquote>\n<h5 id=\"跨平台开发\"><a href=\"#跨平台开发\" class=\"headerlink\" title=\"跨平台开发\"></a>跨平台开发</h5><p>在这一年中，也成功接触了跨平台开发的业务，跨平台开发永远是业内讨论不完的话题，从 HTML5，Codova，到 React-Native，甚至到当前的大热门 Flutter，人们一直在探求跨平台开发的最优解。</p>\n<blockquote>\n<p>Code once, run everywhere.  </p>\n</blockquote>\n<p>可是这似乎一直是一个伪命题。因为只要有不少于一家厂商存在于这个世界，它总会想尽办法创造不同于其他厂家的独异之处。差异，这是亮点，也是卖点。在手机行业，乃至于所有行业，厂家都在想方设法找到自己的亮点。因此，笔者认为跨平台方案永远都在路上。<br>而在笔者负责的项目中，跨平台开发的业务逻辑一直都是一个顽疾，所有人都敬而远之，而它的重要性又使得所有同事不得不深入理解那其中的“奥妙”。那是其中包含了 chormium 的 base library，该库是提供跨平台的多进程方案，另外模块中还使用了 cURL，用作网络协议的请求。这方案在初期应该是取得了不错的收益，在 Windows、macOS、iOS、Android 统一使用这套模块方案，base 库极大的消除了平台的差异性，cURL 解决了不同网络协议的传输问题。<br>然而当笔者接触到这个模块的时候，情况已经截然不同了。由于用户对桌面端的需求逐渐减少，Windows、macOS 平台下的客户端已经处于无限期停止开发的状态，Android 平台由于实在无法忍受不能断点调试 C++ 模块的弊端，已经动用大量人力开始进行原生代码的转移，仅剩 iOS 端一直使用该模块。其实跨平台的优势在此时早已荡然无存，弊端却逐渐显现。该模块年久失修，基础库早已落后太多个版本，使得更新风险越来越大，越发难以修改。<br>所以其实选择一个合适的跨平台方案，是尤为重要的，不能单单只看当前方案的成熟度，同时也要考虑开源社区中普遍开发者对于该方案的态度、后期的维护成本，新人上手难度等。当然，这可能已经属于一个架构师需要考虑的了。</p>\n<h2 id=\"2017-2018\"><a href=\"#2017-2018\" class=\"headerlink\" title=\"2017-2018\"></a>2017-2018</h2><p>终于到了这一年了。其实在这一年中，笔者已经很少接触 iOS 开发了，由于这一年需要开发新的项目-一个前端相关的项目，所以笔者被指派到开发新的项目中。本以为说接触一个新的项目就是从零开始，移动端开发的经验毕竟与前端开发并不太吻合，可是当自己亲身切换到新的领域中时，才发现说过于经历的东西其实都会成为你伴随终身的财富。在这里，希望看到这篇文章的读者都能明白，不要害怕陌生的领域，也不要对当前耳熟的东西感到无趣。<br>在这一年中，开始深入接触到了 Javascript，开始不久就已经看到这么一句话：</p>\n<blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript. —— Jeff Atwood  </p>\n</blockquote>\n<p>与 Objective-C 不同，它真的是一门如日中天的语言，用日新月异去形容都不足为奇，从简单的 XMLHttpRequest，发展到 jQuery、React.js、Vue.js、Angular.js，Javascript 的发展速度如此迅猛，以至于刚去接触这个领域的笔者都是瞠目结舌的。然而，得益于 Javascript 的人气，很多优秀的设计思想都能在其中落地，同时可以迅速接受用户们的验证，正如<strong>单项数据流</strong>这种设计思想，在 Vue.js 框架中得到逻辑，迅速受到了开发者们的赞赏，从而极大地推动了这种思想应用到其他领域中。</p>\n<p>这一年中，笔者基本都在维护一个名为 Online Document 的项目，项目中使用到了 Vue.js, pReact, Babel.js, Eslint, Webpack 等技术，在项目初期，很大部分时间都耗费在项目配置中。有经验的读者应该都深有同感，Webpack 的配置是极其繁琐而有难以避免的，然而一旦配置成功后，项目发展阶段就无需变更。这种一次性的体验难以归纳成为系统性的知识。</p>\n<p>而后，Online Document 被要求抽离成为一个 SDK，作为一个 Web 离线应用加入到另外一个项目中，在开始，笔者乐观的评估为其实只需要在应用层捕捉 request，然后返回应用离线的数据即可，类似于 iOS 中的 NSURLProtocol。可是在后面的过程中，了解到问题并没有如此简单。</p>\n<ul>\n<li><p>在离线环境下，返回上一次的最新数据；在有网环境中，优先展示本地的离线数据，然后等最新数据返回成功后，在将其渲染到页面中；</p>\n<ol>\n<li>JS 逻辑中，无论如何，优先请求本地的缓存数据，这里需要对请求作出特殊标识，让 Native 层能够正确识别该请求，并返回本地数据；</li>\n<li>JS 逻辑中，根据 <code>navigator.onLine</code>属性，可以判断当前的网络环境，如果目前是有网状态下，发起正常的网络请求，获取最新的应用数据，并刷新页面展示；</li>\n<li>Native 逻辑中，当最新网络请求成功返回数据后，需要记录其 request 的 URL，以及其 response 的 data，以用于下一次的离线数据相应；</li>\n</ol>\n</li>\n<li><p>离线环境下需要能进行正常的编辑操作，并且在有网环境下将编辑操作重新同步到服务器中</p>\n<ol>\n<li>由于编辑操作都是通过 WebSocket 同步到服务器的，该通讯方式不适用于使用 NSURLProtocol 进行捕捉，因此编辑操作只能依赖 H5 提供的缓存功能，在 JS 逻辑中进行维护</li>\n<li>H5 提供了几种常用的持久化技术，我们在这里逐一分析一下：<ol>\n<li>sessionStorage ：适用于保存会话期间的数据，例如一次性登陆态信息等，在网络窗口关闭后会被清除，该技术不适用保存文档操作信息，因为我们需要在下次文档打开后仍能正常访问该数据；</li>\n<li>localStorage：区别于 sessionStorage，该存储数据能够在下次网页打开后仍能够正常访问，其缺点为仅适用于保存简单类型的数据，不能保存对象实例；</li>\n<li>Web SQL DataBase：该技术为 H5 提供 SQL 操作客户端数据库的 API，可是该方案已经被 W3C 官方在 2011 年宣布不再进行维护，属于废弃过时的技术方案</li>\n<li>Indexed DataBase：作为 Web SQL DataBase 的后继者，该存储技术被各大开发者广泛介绍，其类似于 NoSQL 形式的操作方式也极大的方便了 Web 开发者的使用，然而在移动端中的支持度稍有不足，在 iOS 8-9.2 版本的 WebView 中，尚未完全支持 Indexed DB，因此无法使用这项优秀的技术<br>  折中取舍，我们最终选择的 localStorage 作为文档操作的存储    方式。</li>\n</ol>\n</li>\n<li>因为 webView 随时可能因为用户的操作而销毁，为了避免操作数据的丢失，文档编辑的操作信息必须要优先保存 localStorage，等操作信息成功同步到服务器后，再将 localStorage 的对应操作信息去掉，降低数据丢失的风险。</li>\n<li>离线的环境下，展示文档的信息需要同时结合文档离线返回的快照信息，以及离线环境下的操作记录，才会构造出最终正确的文档内容；在在线环境下，还需要在请求到服务器最新的文档快照信息，再次加入离线环境下的操作信息，构造出真正的文档内容。</li>\n</ol>\n</li>\n<li><p>作为客户端的功能，该表现上需要尽可能的流畅，接近原生体验。考虑到 H5 的操作流畅，iOS 开发者应该是本能性地会想到 WKWebView 的，该控件能提供高达 60 Fps 的渲染速度，同时得益于使用了与 Safari 相同的 Javascript Core，该控件下 JS 的执行效率有了极大的提升。然而在开发过程中，我们否决了使用 WKWebView 的建议，分析如下：</p>\n<ul>\n<li>考虑到我们应用中使用 NSURLProtocol，因为 WKWebView 真实的执行环境是独立于应用的不同进程，因此单纯配置 NSURLProtocol 并不能捕捉到 WKWebView 的请求，虽然可以通过调用其私用 API 强制将 WKWebView 的请求传递到 NSURLProtocol 中，这里出现的跨进程数据传递必定有不可忽视的性能损耗。同时，由于苹果的设计缺陷，即便请求强制经过 NSURLProtocol，可是 WKWebView 并没有将 request body 传递过来，导致 POST 请求会无法正常执行。</li>\n<li>虽然 WKWebView 的执行效率极高，可是可能是因为独立于应用的进程的原因，使得 WKWebView 的初始化速度极慢，其经过 <code>alloc</code> 方法，到真正发起 request 请求，需要接近 0.5 秒的时间，而 UIWebView 则不存在这个问题。这里应该产品体验，初始化页面的白屏时间过长无法接受，因此这里放弃使用 WKWebView。</li>\n</ul>\n</li>\n</ul>\n<p>老实说，经过了这个项目的磨练，算是捡起了前端开发大门的敲门砖，不同于客户端开发，前端开发这个领域有太多新奇的东西，Javascript 这门语言也为这个世界增加了很多有意思的东西。虽然这其中有太多坑，填坑过程中也太过于痛苦（这里必须说一下，iOS WebView 中，只要涉及到跟计算键盘高度的，都是一场灾难），可是真的为开发者成长生涯铺上了一个极其重要的垫脚石。</p>\n<p>现在，终于可以开始 Enjoy the new beginning! </p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl4y2f5ha0002rv057oshgu3t","tag_id":"cl4y2f5ha0004rv05g8gfg2p9","_id":"cl4y2f5hc0008rv05bijy909v"}],"Tag":[{"name":"Electron","_id":"cl4y2f5ha0004rv05g8gfg2p9"}]}}